[
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 1. The Benefits of Using GPUs - The Graphics Processing Unit G...",
    "content": "The Graphics Processing Unit (GPU) $^1$  provides much higher instruction throughput and memory bandwidth than the CPU within a similar price and power envelope. Many applications leverage these higher capabilities to run faster on the GPU than on the CPU (see GPU Applications). Other computing devices, like FPGAs, are also very energy efficient, but offer much less programming flexibility than GPUs."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 1. The Benefits of Using GPUs - This difference in capabilitie......The GPU is specialized for hig...",
    "content": "This difference in capabilities between the GPU and the CPU exists because they are designed with different goals in mind. While the CPU is designed to excel at executing a sequence of operations, called a thread, as fast as possible and can execute a few tens of these threads in parallel, the GPU is designed to excel at executing thousands of them in parallel (amortizing the slower single- thread performance to achieve greater throughput).\n\nThe GPU is specialized for highly parallel computations and therefore designed such that more transistors are devoted to data processing rather than data caching and flow control. The schematic Figure 1 shows an example distribution of chip resources for a CPU versus a GPU."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 1. The Benefits of Using GPUs - httpscdnmineruopenxlaborgcnres......of relying on large data cache...",
    "content": "![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/466a205c7d779a4979bed26c5c06eb096016b4567d26134978f968fd40975dc4.jpg)  \nFig. 1: The GPU Devotes More Transistors to Data Processing\n\nDevoting more transistors to data processing, for example, floating- point computations, is beneficial for highly parallel computations; the GPU can hide memory access latencies with computation, instead\n\nof relying on large data caches and complex flow control to avoid long memory access latencies, both of which are expensive in terms of transistors."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 1. The Benefits of Using GPUs - In general an application has ...",
    "content": "In general, an application has a mix of parallel parts and sequential parts, so systems are designed with a mix of GPUs and CPUs in order to maximize overall performance. Applications with a high degree of parallelism can exploit this massively parallel nature of the GPU to achieve higher performance than on the CPU."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 2. CUDA®: A General-Purpose Parallel Computing Platform and Programming Model - In November 2006 NVIDIA introd......CUDA comes with a softw...",
    "content": "In November 2006, NVIDIA® introduced CUDA®, a general purpose parallel computing platform and programming model that leverages the parallel compute engine in NVIDIA GPUs to solve many complex computational problems in a more efficient way than on a CPU.\n\nCUDA comes with a software environment that allows developers to use C++ as a high- level programming language. As illustrated by Figure 2, other languages, application programming interfaces, or directives- based approaches are supported, such as FORTRAN, DirectCompute, OpenACC."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 2. CUDA®: A General-Purpose Parallel Computing Platform and Programming Model - httpscdnmineruopenxlaborgcnres......Fig 1 GPU Computing App...",
    "content": "![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/d7107f4301490437259d5938047b39a4c9aa35c4a9858dd19e1989b9a6524e7c.jpg)  \nFig. 1: GPU Computing Applications. CUDA is designed to support various languages and application programming interfaces."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 3. A Scalable Programming Model - The advent of multicore CPUs a......At its core are three key abst...",
    "content": "The advent of multicore CPUs and manycore GPUs means that mainstream processor chips are now parallel systems. The challenge is to develop application software that transparently scales its parallelism to leverage the increasing number of processor cores, much as 3D graphics applications transparently scale their parallelism to manycore GPUs with widely varying numbers of cores.\n\nThe CUDA parallel programming model is designed to overcome this challenge while maintaining a low learning curve for programmers familiar with standard programming languages such as C.\n\nAt its core are three key abstractions - a hierarchy of thread groups, shared memories, and barrier synchronization - - that are simply exposed to the programmer as a minimal set of language extensions."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 3. A Scalable Programming Model - These abstractions provide fin...",
    "content": "These abstractions provide fine- grained data parallelism and thread parallelism, nested within coarse- grained data parallelism and task parallelism. They guide the programmer to partition the problem into coarse sub- problems that can be solved independently in parallel by blocks of threads, and each sub- problem into finer pieces that can be solved cooperatively in parallel by all threads within the block."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 3. A Scalable Programming Model - This decomposition preserves l...",
    "content": "This decomposition preserves language expressivity by allowing threads to cooperate when solving each sub- problem, and at the same time enables automatic scalability. Indeed, each block of threads can be scheduled on any of the available multiprocessors within a GPU, in any order, concurrently or sequentially, so that a compiled CUDA program can execute on any number of multiprocessors as illustrated by Figure 3, and only the runtime system needs to know the physical multiprocessor count."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 3. A Scalable Programming Model - This scalable programming mode......Fig 1 Automatic Scalability",
    "content": "This scalable programming model allows the GPU architecture to span a wide market range by simply scaling the number of multiprocessors and memory partitions: from the high- performance enthusiast GeForce GPUs and professional Quadro and Tesla computing products to a variety of inexpensive, mainstream GeForce GPUs (see CUDA- Enabled GPUs for a list of all CUDA- enabled GPUs).\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/afd592fef155de03e25d985a80516244f7b3d4829e4a16db840282e61f09fc25.jpg)  \nFig. 1: Automatic Scalability"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 3. A Scalable Programming Model - Note A GPU is built around an ...",
    "content": "Note: A GPU is built around an array of Streaming Multiprocessors (SMs) (see Hardware Implementation for more details). A multithreaded program is partitioned into blocks of threads that execute independently from each other, so that a GPU with more multiprocessors will automatically execute the program in less time than a GPU with fewer multiprocessors."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 4. Document Structure - This document is organized int...",
    "content": "This document is organized into the following sections:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 4. Document Structure - Introduction is a general intr...",
    "content": "Introduction is a general introduction to CUDA.  - Programming Model outlines the CUDA programming model.  - Programming Interface describes the programming interface.  - Hardware Implementation describes the hardware implementation.  - Performance Guidelines gives some guidance on how to achieve maximum performance.  - CUDA- Enabled GPUs lists all CUDA- enabled devices.  - C++ Language Extensions is a detailed description of all extensions to the C++ language.  - Cooperative Groups describes synchronization primitives for various groups of CUDA threads.  - CUDA Dynamic Parallelism describes how to launch and synchronize one kernel from another.  - Virtual Memory Management describes how to manage the unified virtual address space."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 4. Document Structure - Stream Ordered Memory Allocato...",
    "content": "  - Stream Ordered Memory Allocator describes how applications can order memory allocation and deallocation.  - Graph Memory Nodes describes how graphs can create and own memory allocations.  - Mathematical Functions lists the mathematical functions supported in CUDA.  - C++ Language Support lists the C++ features supported in device code.  - Texture Fetching gives more details on texture fetching.  - Compute Capabilities gives the technical specifications of various devices, as well as more architectural details.  - Driver API introduces the low- level driver API.  - CUDA Environment Variables lists all the CUDA environment variables.  - Unified Memory Programming introduces the Unified Memory programming model."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 5. Programming Model - This chapter introduces the ma......Full code for the vector addit...",
    "content": "\n\n# Chapter 5. Programming Model\nThis chapter introduces the main concepts behind the CUDA programming model by outlining how they are exposed in  $\\mathtt{C + + }$\n\nAn extensive description of CUDA  $\\mathtt{C + + }$  is given in Programming Interface.\n\nFull code for the vector addition example used in this chapter and the next can be found in the vectorAdd CUDA sample."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.1. Kernels - CUDA  mathttC     extends  mat......A kernel is defined using the ...",
    "content": "CUDA  $\\mathtt{C + + }$  extends  $\\mathtt{C + + }$  by allowing the programmer to define  $\\mathtt{C + + }$  functions, called kernels, that, when called, are executed N times in parallel by N different CUDA threads, as opposed to only once like regular  $\\mathtt{C + + }$  functions.\n\nA kernel is defined using the  $\\_$ global  $\\_$ declaration specifier and the number of CUDA threads that execute that kernel for a given kernel call is specified using a new  $\\langle \\langle \\langle \\ldots \\rangle \\rangle \\rangle$  execution configuration syntax (see  $\\mathtt{C + + }$  Language Extensions). Each thread that executes the kernel is given a unique thread  $ID$  that is accessible within the kernel through built- in variables."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.1. Kernels - As an illustration the followi......Here each of the  N  threads t...",
    "content": "As an illustration, the following sample code, using the built- in variable threadIdx, adds two vectors  $A$  and  $B$  of size  $N$  and stores the result into vector  $C$ :\n\n// Kernel definition global__ void VecAdd(float\\* A, float\\* B, float\\* C) { int  $\\textbf{i} =$  threadIdx.x;  $\\texttt{C} [\\texttt{i} ] = \\texttt{A} [\\texttt{i} ] + \\texttt{B} [\\texttt{i} ]$  } int main() { // Kernel invocation with N threads VecAdd  $\\leq \\leq \\leq 1$ $\\mathbb{N} > > > (\\mathbb{A},\\mathbb{B},\\mathbb{C})$  . }\n\nHere, each of the  $N$  threads that execute VecAdd() performs one pair- wise addition."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.2. Thread Hierarchy - For convenience threadIdx is a......The index of a thread and its ...",
    "content": "For convenience, threadIdx is a 3- component vector, so that threads can be identified using a onedimensional, two- dimensional, or three- dimensional thread index, forming a one- dimensional, twodimensional, or three- dimensional block of threads, called a thread block. This provides a natural way to invoke computation across the elements in a domain such as a vector, matrix, or volume.\n\nThe index of a thread and its thread ID relate to each other in a straightforward way: For a onedimensional block, they are the same; for a two- dimensional block of size  $(Dx,Dy)$  , the thread ID of a thread of index  $(x,y)$  is  $(x + yDx)$  , for a three- dimensional block of size  $(Dx,Dy,Dz)$  , the thread ID of a thread of index  $(x,y,z)$  is  $(x + yDx + zDxDy)$"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.2. Thread Hierarchy - As an example the following co......There is a limit to the number...",
    "content": "As an example, the following code adds two matrices  $A$  and  $B$  of size NxN and stores the result into matrix C:\n\n// Kernel definition global_ void MatAdd(float A[N][N], float B[N][N], float C[N][N]) { int  $\\texttt{i} =$  threadIdx.x; int  $\\texttt{j} =$  threadIdx.y; C[i][j]  $=$  A[i][j]  $^+$  B[i][j]; } int main() { // Kernel invocation with one block of  $N*N*1$  threads int numBlocks  $= 1$  . dim3 threadsPerBlock(N, N); MatAdd  $\\epsilon_{*}^{*}$  <numBlocks, threadsPerBlock>>>（A, B, C); }\n\nThere is a limit to the number of threads per block, since all threads of a block are expected to reside on the same streaming multiprocessor core and must share the limited memory resources of that core. On current GPUs, a thread block may contain up to 1024 threads."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.2. Thread Hierarchy - However a kernel can be execut......Blocks are organized into a on...",
    "content": "However, a kernel can be executed by multiple equally- shaped thread blocks, so that the total number of threads is equal to the number of threads per block times the number of blocks.\n\nBlocks are organized into a one- dimensional, two- dimensional, or three- dimensional grid of thread blocks as illustrated by Figure 4. The number of thread blocks in a grid is usually dictated by the size of the data being processed, which typically exceeds the number of processors in the system."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.2. Thread Hierarchy - The number of threads per bloc...",
    "content": "The number of threads per block and the number of blocks per grid specified in the  $\\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon$  syntax can be of type Int or dll3. Two- dimensional blocks or grids can be specified as in the example above."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.2. Thread Hierarchy - Each block within the grid can......continued from previous page",
    "content": "Each block within the grid can be identified by a one- dimensional, two- dimensional, or threedimensional unique index accessible within the kernel through the built- in blockIdx variable. The dimension of the thread block is accessible within the kernel through the built- in blockDim variable.\n\nExtending the previous MatAdd() example to handle multiple blocks, the code becomes as follows.\n\n// Kernel definition global_ void MatAdd(float A[N][N], float B[N][N], float C[N][N])\n\n(continues on next page)\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/c693b1e7039156682f2f5e3d55ee68fcdcb49c83ad49b2574149323043387d99.jpg)  \nFig. 1: Grid of Thread Blocks\n\n(continued from previous page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.2. Thread Hierarchy - int  texttti   blockIdxx  bloc...",
    "content": "{ int  $\\texttt{i} =$  blockIdx.x \\* blockDim.x  $^+$  threadIdx.x; int  $\\texttt{j} =$  blockIdx.y \\* blockDim.y  $^+$  threadIdx.y; if  $(\\texttt{i} < \\texttt{N}\\& \\& \\texttt{j} < \\texttt{N})$  C[i][j] - A[i][j]  $^+$  B[i][j]; } int main() { // Kernel invocation dim3 threadsPerBlock(16, 16); dim3 numBlocks(N / threadsPerBlock.x, N / threadsPerBlock.y); MatAdd  $\\epsilon_{=}^{*}$  <numBlocks, threadsPerBlock  $\\geq \\geq \\geq$  (A, B, C); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.2. Thread Hierarchy - A thread block size of 16x16 2......Thread blocks are required to ...",
    "content": "A thread block size of 16x16 (256 threads), although arbitrary in this case, is a common choice. The grid is created with enough blocks to have one thread per matrix element as before. For simplicity, this example assumes that the number of threads per grid in each dimension is evenly divisible by the number of threads per block in that dimension, although that need not be the case.\n\nThread blocks are required to execute independently: It must be possible to execute them in any order, in parallel or in series. This independence requirement allows thread blocks to be scheduled in any order across any number of cores as illustrated by Figure 3, enabling programmers to write code that scales with the number of cores."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.2. Thread Hierarchy - Threads within a block can coo......For efficient cooperation the ...",
    "content": "Threads within a block can cooperate by sharing data through some shared memory and by synchronizing their execution to coordinate memory accesses. More precisely, one can specify synchronization points in the kernel by calling the __syncthreads() intrinsic function; __syncthreads() acts as a barrier at which all threads in the block must wait before any is allowed to proceed. Shared Memory gives an example of using shared memory. In addition to __syncthreads(), the Cooperative Groups API provides a rich set of thread- synchronization primitives.\n\nFor efficient cooperation, the shared memory is expected to be a low- latency memory near each processor core (much like an L1 cache) and __syncthreads() is expected to be lightweight."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.2.1. Thread Block Clusters - With the introduction of NVIDI...",
    "content": "With the introduction of NVIDIA Compute Capability 9.0, the CUDA programming model introduces an optional level of hierarchy called Thread Block Clusters that are made up of thread blocks. Similar to how threads in a thread block are guaranteed to be co- scheduled on a streaming multiprocessor, thread blocks in a cluster are also guaranteed to be co- scheduled on a GPU Processing Cluster (GPC) in the GPU."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.2.1. Thread Block Clusters - Similar to thread blocks clust...",
    "content": "Similar to thread blocks, clusters are also organized into a one- dimension, two- dimension, or threedimension as illustrated by Figure 5. The number of thread blocks in a cluster can be user- defined, and a maximum of 8 thread blocks in a cluster is supported as a portable cluster size in CUDA. Note that on GPU hardware or MIG configurations which are too small to support 8 multiprocessors the maximum cluster size will be reduced accordingly. Identification of these smaller configurations, as well as of larger configurations supporting a thread block cluster size beyond 8, is architecture- specific and can be queried using the cudaOccupancyMaxPotentialClusterSize API."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.2.1. Thread Block Clusters - httpscdnmineruopenxlaborgcnres......Note In a kernel launched usin...",
    "content": "![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/5e7d86e2e50cdcd94dabe7d4600ac8a3ce393fbcb20c80bb0d4968e7eba41886.jpg)  \nFig. 2: Grid of Thread Block Clusters\n\nNote: In a kernel launched using cluster support, the gridDim variable still denotes the size in terms of number of thread blocks, for compatibility purposes. The rank of a block in a cluster can be found using the Cluster Group API."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.2.1. Thread Block Clusters - A thread block cluster can be ......Kernel definition  Compile tim...",
    "content": "A thread block cluster can be enabled in a kernel either using a compiler time kernel attribute using __cluster_dims__(X, Y, Z) or using the CUDA kernel launch API cudaLaunchKernelEx. The example below shows how to launch a cluster using compiler time kernel attribute. The cluster size using kernel attribute is fixed at compile time and then the kernel can be launched using the classical  $< < <$ $> > >$  . If a kernel uses compile- time cluster size, the cluster size cannot be modified when launching the kernel.\n\n// Kernel definition // Compile time cluster size 2 in X- dimension and 1 in Y and Z dimension. - - global__ void __cluster_dims__(2, 1, 1) cluster_kernel(float *input, float* output) { } int main() { (continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.2.1. Thread Block Clusters - float input output  Kernel inv......A thread block cluster size ca...",
    "content": "float \\*input, \\*output; // Kernel invocation with compile time cluster size dim3 threadsPerBlock(16, 16); dim3 numBlocks(N / threadsPerBlock.x, N / threadsPerBlock.y); // The grid dimension is not affected by cluster launch, and is still enumerated // using number of blocks. // The grid dimension must be a multiple of cluster size. cluster_kernel<<<numBlocks, threadsPerBlock>>> (input, output);\n\nA thread block cluster size can also be set at runtime and the kernel can be launched using the CUDA kernel launch API cudaLaunchKernelEx. The code example below shows how to launch a cluster kernel using the extensible API."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.2.1. Thread Block Clusters - Kernel definition  No compile ...",
    "content": "// Kernel definition // No compile time attribute attached to the kernel - global- void cluster_kernel(float \\*input, float\\* output) { } int main() { float \\*input, \\*output; dim3 threadsPerBlock(16, 16); dim3 numBlocks(N / threadsPerBlock.x, N / threadsPerBlock.y); cluster_kernel<<<numBlocks, threadsPerBlock  $\\geq \\geq$  ); // Kernel invocation with runtime cluster size { cudaLaunchConfig_t config  $=$  {0}; // The grid dimension is not affected by cluster launch, and is still enumerated // using number of blocks. // The grid dimension should be a multiple of cluster size. config.gridDim  $=$  numBlocks; config.blockDim  $=$  threadsPerBlock; cudaLaunchAttribute attribute[1]; attribute[0].id  $=$  cudaLaunchAttributeClusterDimension; attribute[0].val.clusterDim."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.2.1. Thread Block Clusters - x   2    Cluster size in X dim...",
    "content": "x  $= 2$  ; // Cluster size in X- dimension attribute[0].val.clusterDim.y  $= 1$  . attribute[0].val.clusterDim.z  $= 1$  . config.attrs  $=$  attribute; config.numAttrs  $= 1$  cudaLaunchKernelEx(&config, cluster_kernel, input, output); } }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.2.1. Thread Block Clusters - In GPUs with compute capabilit......Thread blocks that belong to a...",
    "content": "In GPUs with compute capability 9.0, all the thread blocks in the cluster are guaranteed to be coscheduled on a single GPU Processing Cluster (GPC) and allow thread blocks in the cluster to perform hardware- supported synchronization using the Cluster Group API cluster.sync(). Cluster group also provides member functions to query cluster group size in terms of number of threads or number of blocks using num_threads() and num_blocks() API respectively. The rank of a thread or block in the cluster group can be queried using dim_threads() and dim_blocks() API respectively.\n\nThread blocks that belong to a cluster have access to the Distributed Shared Memory. Thread blocks"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.2.1. Thread Block Clusters - in a cluster have the ability ...",
    "content": "in a cluster have the ability to read, write, and perform atomics to any address in the distributed shared memory. Distributed Shared Memory gives an example of performing histograms in distributed shared memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.3. Memory Hierarchy - CUDA threads may access data f...",
    "content": "CUDA threads may access data from multiple memory spaces during their execution as illustrated by Figure 6. Each thread has private local memory. Each thread block has shared memory visible to all threads of the block and with the same lifetime as the block. Thread blocks in a thread block cluster can perform read, write, and atomics operations on each other's shared memory. All threads have access to the same global memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.3. Memory Hierarchy - There are also two additional ......Fig 3 Memory Hierarchy",
    "content": "There are also two additional read- only memory spaces accessible by all threads: the constant and texture memory spaces. The global, constant, and texture memory spaces are optimized for different memory usages (see Device Memory Accesses). Texture memory also offers different addressing modes, as well as data filtering, for some specific data formats (see Texture and Surface Memory).\n\nThe global, constant, and texture memory spaces are persistent across kernel launches by the same application.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/991fe58f1393ed55e521eb78364da00a4474165b48bc6eaea2fd5889dc9279ff.jpg)  \nFig. 3: Memory Hierarchy"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.4. Heterogeneous Programming - As illustrated by Figure 7 the...",
    "content": "As illustrated by Figure 7, the CUDA programming model assumes that the CUDA threads execute on a physically separate device that operates as a coprocessor to the host running the  $\\mathtt{C + + }$  program. This is the case, for example, when the kernels execute on a GPU and the rest of the  $\\mathtt{C + + }$  program executes on a CPU."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.4. Heterogeneous Programming - The CUDA programming model als...",
    "content": "The CUDA programming model also assumes that both the host and the device maintain their own separate memory spaces in DRAM, referred to as host memory and device memory, respectively. Therefore, a program manages the global, constant, and texture memory spaces visible to kernels through calls to the CUDA runtime (described in Programming interface). This includes device memory allocation and deallocation as well as data transfer between host and device memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.4. Heterogeneous Programming - Unified Memory provides manage...",
    "content": "Unified Memory provides managed memory to bridge the host and device memory spaces. Managed memory is accessible from all CPUs and GPUs in the system as a single, coherent memory image with a common address space. This capability enables oversubscription of device memory and can greatly simplify the task of porting applications by eliminating the need to explicitly mirror data on host and device. See Unified Memory Programming for an introduction to Unified Memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.5. Asynchronous SIMT Programming Model - In the CUDA programming model ......The asynchronous programming m...",
    "content": "# 5.5. Asynchronous SIMT Programming Model\nIn the CUDA programming model a thread is the lowest level of abstraction for doing a computation or a memory operation. Starting with devices based on the NVIDIA Ampere GPU architecture, the CUDA programming model provides acceleration to memory operations via the asynchronous programming model. The asynchronous programming model defines the behavior of asynchronous operations with respect to CUDA threads.\n\nThe asynchronous programming model defines the behavior of Asynchronous Barrier for synchronization between CUDA threads. The model also explains and defines how cuda::memcpy_async can be used to move data asynchronously from global memory while computing in the GPU."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.5.1. Asynchronous Operations - An asynchronous operation is d......Such an asynchronous thread an...",
    "content": "An asynchronous operation is defined as an operation that is initiated by a CUDA thread and is executed asynchronously as- if by another thread. In a well formed program one or more CUDA threads synchronize with the asynchronous operation. The CUDA thread that initiated the asynchronous operation is not required to be among the synchronizing threads.\n\nSuch an asynchronous thread (an as- if thread) is always associated with the CUDA thread that initiated the asynchronous operation. An asynchronous operation uses a synchronization object to synchronize the completion of the operation. Such a synchronization object can be explicitly managed by a user (e.g., cuda: :memcpy_async) or implicitly managed within a library (e.g., cooperative_groups: :memcpy_async)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.5.1. Asynchronous Operations - A synchronization object could......Fig 4 Heterogeneous Programmin...",
    "content": "A synchronization object could be a cuda: : barrier or a cuda: : pipeline. These objects are explained in detail in Asynchronous Barrier and Asynchronous Data Copies using cuda: :pipeline. These synchronization objects can be used at different thread scopes. A scope defines the set of threads that may use the synchronization object to synchronize with the asynchronous operation. The following table defines the thread scopes available in CUDA  $\\mathtt{C + + }$  and the threads that can be synchronized with each.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/db215d8d1c8ad35052cfa21306d3a1b5ad307257e38a4daaa3edc327b624120b.jpg)  \nFig. 4: Heterogeneous Programming"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.5.1. Asynchronous Operations - tabletrtdThread ScopetdtdDescr...",
    "content": "Note: Serial code executes on the host while parallel code executes on the device.\n\n<table><tr><td>Thread Scope</td><td>Description</td></tr><tr><td>cuda::thread_scope::thread_</td><td>$copythreadCellA thread which initiated asynchronous operations synchronizes.</td></tr><tr><td>cuda::thread_scope::thread_</td><td>$Adper_blyoCUDA threads within the same thread block as the initiating thread synchronizes.</td></tr><tr><td>cuda::thread_scope::thread_</td><td>$Adper_adhyCUDA threads in the same GPU device as the initiating thread synchronizes.</td></tr><tr><td>cuda::thread_scope::thread_</td><td>$Adper_anysteINA or CPU threads in the same system as the initiating thread synchronizes.</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.5.1. Asynchronous Operations - These thread scopes are implem...",
    "content": "These thread scopes are implemented as extensions to standard  $\\mathtt{C + + }$  in the CUDA Standard  $\\mathtt{C + + }$  library."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.6. Compute Capability - The compute capability of a de......The compute capability compris...",
    "content": "The compute capability of a device is represented by a version number, also sometimes called its \"SM version\". This version number identifies the features supported by the GPU hardware and is used by applications at runtime to determine which hardware features and/or instructions are available on the present GPU.\n\nThe compute capability comprises a major revision number  $X$  and a minor revision number  $Y$  and is denoted by X.Y."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.6. Compute Capability - Devices with the same major re......Turing is the architecture for...",
    "content": "Devices with the same major revision number are of the same core architecture. The major revision number is 9 for devices based on the NVIDIA Hopper GPU architecture, 8 for devices based on the NVIDIA Ampere GPU architecture, 7 for devices based on the Volta architecture, 6 for devices based on the Pascal architecture, 5 for devices based on the Maxwell architecture, and 3 for devices based on the Kepler architecture.\n\nThe minor revision number corresponds to an incremental improvement to the core architecture, possibly including new features.\n\nTuring is the architecture for devices of compute capability 7.5, and is an incremental update based on the Volta architecture."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.6. Compute Capability - CUDA Enabled GPUs lists of all...",
    "content": "CUDA- Enabled GPUs lists of all CUDA- enabled devices along with their compute capability. Compute Capabilities gives the technical specifications of each compute capability."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "5.6. Compute Capability - The Tesla and Fermi architectu...",
    "content": "Note: The compute capability version of a particular GPU should not be confused with the CUDA version (for example, CUDA 7.5, CUDA 8, CUDA 9), which is the version of the CUDA software platform. The CUDA platform is used by application developers to create applications that run on many generations of GPU architectures, including future GPU architectures yet to be invented. While new versions of the CUDA platform often add native support for a new GPU architecture by supporting the compute capability version of that architecture, new versions of the CUDA platform typically also include software features that are independent of hardware generation.\n\nThe Tesla and Fermi architectures are no longer supported starting with CUDA 7.0 and CUDA 9.0, respectively."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "CUDA C++ Programming Guide, Release 12.1",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 6. Programming Interface - CUDA  mathttC     provides a s......The core language extensions h...",
    "content": "CUDA  $\\mathtt{C + + }$  provides a simple path for users familiar with the  $\\mathtt{C + + }$  programming language to easily write programs for execution by the device.\n\nIt consists of a minimal set of extensions to the  $\\mathtt{C + + }$  language and a runtime library.\n\nThe core language extensions have been introduced in Programming Model. They allow programmers to define a kernel as a  $\\mathtt{C + + }$  function and use some new syntax to specify the grid and block dimension each time the function is called. A complete description of all extensions can be found in  $\\mathtt{C + + }$  Language Extensions. Any source file that contains some of these extensions must be compiled with nvcc as outlined in Compilation with NVCC."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 6. Programming Interface - The runtime is introduced in C...",
    "content": "The runtime is introduced in CUDA Runtime. It provides C and  $\\mathtt{C + + }$  functions that execute on the host to allocate and deallocate device memory, transfer data between host memory and device memory, manage systems with multiple devices, etc. A complete description of the runtime can be found in the CUDA reference manual."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 6. Programming Interface - The runtime is built on top of...",
    "content": "The runtime is built on top of a lower- level C API, the CUDA driver API, which is also accessible by the application. The driver API provides an additional level of control by exposing lower- level concepts such as CUDA contexts - the analogue of host processes for the device - and CUDA modules - the analogue of dynamically loaded libraries for the device. Most applications do not use the driver API as they do not need this additional level of control and when using the runtime, context and module management are implicit, resulting in more concise code. As the runtime is interoperable with the driver API, most applications that need some driver API features can default to use the runtime API and only use the driver API where needed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 6. Programming Interface - The driver API is introduced i...",
    "content": " The driver API is introduced in Driver API and fully described in the reference manual."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.1.1. Compilation Workflow - Kernels can be written using t......nvcc is a compiler driver that...",
    "content": "# 6.1. Compilation with NVCC\nKernels can be written using the CUDA instruction set architecture, called PTX, which is described in the PTX reference manual. It is however usually more effective to use a high- level programming language such as  $\\mathtt{C + + }$ . In both cases, kernels must be compiled into binary code by nvcc to execute on the device.\n\nnvcc is a compiler driver that simplifies the process of compiling  $\\mathtt{C + + }$  or PTX code: It provides simple and familiar command line options and executes them by invoking the collection of tools that implement the different compilation stages. This section gives an overview of nvcc workflow and command options. A complete description can be found in the nvcc user manual.\n\n# 6.1.1. Compilation Workflow\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.1.1.1 Offline Compilation - Source files compiled with nvc......compiling the device code into...",
    "content": "Source files compiled with nvcc can include a mix of host code (i.e., code that executes on the host) and device code (i.e., code that executes on the device). nvcc's basic workflow consists in separating device code from host code and then:\n\ncompiling the device code into an assembly form (PTX code) and/or binary form (cubin object), and modifying the host code by replacing the  $\\ll \\ll \\ldots \\gg \\gg$  syntax introduced in kernels (and described in more details in Execution Configuration) by the necessary CUDA runtime function calls to load and launch each compiled kernel from the PTX code and/or cubin object."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.1.1.1 Offline Compilation - The modified host code is outp......Applications can then Either l...",
    "content": "The modified host code is output either as  $\\mathtt{C + + }$  code that is left to be compiled using another tool or as object code directly by letting nvcc invoke the host compiler during the last compilation stage.\n\nApplications can then:\n\nApplications can then:- Either link to the compiled host code (this is the most common case),- Or ignore the modified host code (if any) and use the CUDA driver API (see Driver API) to load and execute the PTX code or cubin object."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.1.1.2 Just-in-Time Compilation - Any PTX code loaded by an appl...",
    "content": "Any PTX code loaded by an application at runtime is compiled further to binary code by the device driver. This is called just- in- time compilation. Just- in- time compilation increases application load time, but allows the application to benefit from any new compiler improvements coming with each new device driver. It is also the only way for applications to run on devices that did not exist at the time the application was compiled, as detailed in Application Compatibility."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.1.1.2 Just-in-Time Compilation - When the device driver just in......Environment variables are avai...",
    "content": "When the device driver just- in- time compiles some PTX code for some application, it automatically caches a copy of the generated binary code in order to avoid repeating the compilation in subsequent invocations of the application. The cache - referred to as compute cache - is automatically invalidated when the device driver is upgraded, so that applications can benefit from the improvements in the new just- in- time compiler built into the device driver.\n\nEnvironment variables are available to control just- in- time compilation as described in CUDA Environment Variables"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.1.1.2 Just-in-Time Compilation - As an alternative to using nvc...",
    "content": "As an alternative to using nvcc to compile CUDA  $\\mathtt{C + + }$  device code, NvRTC can be used to compile CUDA  $\\mathtt{C + + }$  device code to PTX at runtime. NvRTC is a runtime compilation library for CUDA  $\\mathtt{C + + }$  ; more information can be found in the NvRTC User guide."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.1.2. Binary Compatibility - 612 Binary CompatibilityBinary......Note Binary compatibility is s...",
    "content": "# 6.1.2. Binary Compatibility\n6.1.2. Binary CompatibilityBinary code is architecture- specific. A cubin object is generated using the compiler option - code that specifies the targeted architecture: For example, compiling with - code=sm_80 produces binary code for devices of compute capability 8.0. Binary compatibility is guaranteed from one minor revision to the next one, but not from one minor revision to the previous one or across major revisions. In other words, a cubin object generated for compute capability X.y will only execute on devices of compute capability X.z where z $\\square$ y.\n\nNote: Binary compatibility is supported only for the desktop. It is not supported for Tegra. Also, the binary compatibility between desktop and Tegra is not supported."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.1.3. PTX Compatibility - Some PTX instructions are only...",
    "content": "Some PTX instructions are only supported on devices of higher compute capabilities. For example, warp Shuffle Functions are only supported on devices of compute capability 5.0 and above. The - arch compiler option specifies the compute capability that is assumed when compiling  $\\mathtt{C + + }$  to PTX code. So, code that contains warp shuffle, for example, must be compiled with - arch  $\\equiv$  compute_30 (or higher)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.1.3. PTX Compatibility - PTX code produced for some spe...",
    "content": "PTX code produced for some specific compute capability can always be compiled to binary code of greater or equal compute capability. Note that a binary compiled from an earlier PTX version may not make use of some hardware features. For example, a binary targeting devices of compute capability 7.0 (Volta) compiled from PTX generated for compute capability 6.0 (Pascal) will not make use of Tensor Core instructions, since these were not available on Pascal. As a result, the final binary may perform worse than would be possible if the binary were generated using the latest version of PTX."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.1.4. Application Compatibility - To execute code on devices of ...",
    "content": "To execute code on devices of specific compute capability, an application must load binary or PTX code that is compatible with this compute capability as described in Binary Compatibility and PTX Compatibility. In particular, to be able to execute code on future architectures with higher compute capability (for which no binary code can be generated yet), an application must load PTX code that will be just- in- time compiled for these devices (see Just- in- Time Compilation)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.1.4. Application Compatibility - Which PTX and binary code gets......Host code is generated to auto...",
    "content": "Which PTX and binary code gets embedded in a CUDA  $\\mathtt{C + + }$  application is controlled by the - arch and - code compiler options or the - gencode compiler option as detailed in the nvcc user manual. For example, nvcc x.cu - gencode arch  $\\equiv$  compute_50,code  $\\equiv$  sm_50 - gencode arch  $\\equiv$  compute_60,code  $\\equiv$  sm_60 - gencode arch  $\\equiv$  compute_70,code  $\\equiv$  \"compute_70,sm_70\"\n\nembeds binary code compatible with compute capability 5.0 and 6.0 (first and second - gencode options) and PTX and binary code compatible with compute capability 7.0 (third - gencode option).\n\nHost code is generated to automatically select at runtime the most appropriate code to load and execute, which, in the above example, will be:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.1.4. Application Compatibility - 50 binary code for devices wit......xcu can have an optimized code...",
    "content": "5.0 binary code for devices with compute capability 5.0 and 5.2, 6.0 binary code for devices with compute capability 6.0 and 6.1, 7.0 binary code for devices with compute capability 7.0 and 7.5, PTX code which is compiled to binary code at runtime for devices with compute capability 8.0 and 8.6.\n\nx.cu can have an optimized code path that uses warp reduction operations, for example, which are only supported in devices of compute capability 8.0 and higher. The  $\\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_$  macro can be"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.1.4. Application Compatibility - used to differentiate various ......Applications using the driver ...",
    "content": "used to differentiate various code paths based on compute capability. It is only defined for device code. When compiling with - arch  $\\equiv$  compute_80 for example, __CUDA_ARCH__ is equal to 800.\n\nApplications using the driver API must compile code to separate files and explicitly load and execute the most appropriate file at runtime."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.1.4. Application Compatibility - The Volta architecture introdu...",
    "content": "The Volta architecture introduces Independent Thread Scheduling which changes the way threads are scheduled on the GPU. For code relying on specific behavior of SIMT scheduling in previous architectures, Independent Thread Scheduling may alter the set of participating threads, leading to incorrect results. To aid migration while implementing the corrective actions detailed in Independent Thread Scheduling, Volta developers can opt- in to Pascal's thread scheduling with the compiler option combination - arch  $\\equiv$  compute_60 - code  $\\equiv$  sim_70."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.1.4. Application Compatibility - The nvcc user manual lists var...",
    "content": "The nvcc user manual lists various shorthands for the - arch, - code, and - gencode compiler options. For example, - arch  $\\equiv$  sm_70 is a shorthand for - arch  $\\equiv$  compute_70 - code  $\\equiv$  compute_70, sm_70 (which is the same as - gencode arch  $\\equiv$  compute_70, code  $\\equiv$  \"compute_70, sm_70\\\")."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.1.6. 64-Bit Compatibility - The front end of the compiler ......The 64 bit version of nvcc com...",
    "content": "# 6.1.5. C++ Compatibility\nThe front end of the compiler processes CUDA source files according to  $\\mathtt{C + + }$  syntax rules. Full  $\\mathtt{C + + }$  is supported for the host code. However, only a subset of  $\\mathtt{C + + }$  is fully supported for the device code as described in  $\\mathtt{C + + }$  Language Support.\n\n# 6.1.6. 64-Bit Compatibility\nThe 64- bit version of nvcc compiles device code in 64- bit mode (i.e., pointers are 64- bit). Device code compiled in 64- bit mode is only supported with host code compiled in 64- bit mode."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2. CUDA Runtime - The runtime is implemented in ......As mentioned in heterogeneous ...",
    "content": "The runtime is implemented in the cudart library, which is linked to the application, either statically via cudart.lib or libcudart.a, or dynamically via cudart.dll or libcudart.so. Applications that require cudart.dll and/or cudart.so for dynamic linking typically include them as part of the application installation package. It is only safe to pass the address of CUDA runtime symbols between components that link to the same instance of the CUDA runtime.\n\nAll its entry points are prefixed with cuda.\n\nAs mentioned in heterogeneous Programming, the CUDA programming model assumes a system composed of a host and a device, each with their own separate memory. Device Memory gives an overview of the runtime functions used to manage device memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2. CUDA Runtime - Shared Memory illustrates the ......Call Stack mentions the runtim...",
    "content": "Shared Memory illustrates the use of shared memory, introduced in Thread Hierarchy, to maximize performance.\n\nPage- Locked Host Memory introduces page- locked host memory that is required to overlap kernel execution with data transfers between host and device memory.\n\nAsynchronous Concurrent Execution describes the concepts and API used to enable asynchronous concurrent execution at various levels in the system.\n\nMulti- Device System shows how the programming model extends to a system with multiple devices attached to the same host.\n\nError Checking describes how to properly check the errors generated by the runtime.\n\nCall Stack mentions the runtime functions used to manage the CUDA C++ call stack."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2. CUDA Runtime - Texture and Surface Memory pre......Graphics Interoperability intr...",
    "content": "Texture and Surface Memory presents the texture and surface memory spaces that provide another way to access device memory; they also expose a subset of the GPU texturing hardware.\n\nGraphics Interoperability introduces the various functions the runtime provides to interoperate with the two main graphics APIs, OpenGL and Direct3D."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.1. Initialization - There is no explicit initializ...",
    "content": "There is no explicit initialization function for the runtime; it initializes the first time a runtime function is called (more specifically any function other than functions from the error handling and version management sections of the reference manual). One needs to keep this in mind when timing runtime function calls and when interpreting the error code from the first call into the runtime."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.1. Initialization - The runtime creates a CUDA con...",
    "content": "The runtime creates a CUDA context for each device in the system (see Context for more details on CUDA contexts). This context is the primary context for this device and is initialized at the first runtime function which requires an active context on this device. It is shared among all the host threads of the application. As part of this context creation, the device code is just- in- time compiled if necessary (see Just- in- Time Compilation) and loaded into device memory. This all happens transparently. If needed, for example, for driver API interoperability, the primary context of a device can be accessed from the driver API as described in Interoperability between Runtime and Driver APIs."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.1. Initialization - When a host thread calls cudaD......Note The CUDA interfaces use g...",
    "content": "When a host thread calls cudaDeviceReset(), this destroys the primary context of the device the host thread currently operates on (i.e., the current device as defined in Device Selection). The next runtime function call made by any host thread that has this device as current will create a new primary context for this device.\n\nNote: The CUDA interfaces use global state that is initialized during host program initiation and destroyed during host program termination. The CUDA runtime and driver cannot detect if this state is invalid, so using any of these interfaces (implicitly or explicitly) during program initiation or termination after main) will result in undefined behavior."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.1. Initialization - As of CUDA 120 cudaSetDevice w...",
    "content": "As of CUDA 12.0, cudaSetDevice() will now explicitly initialize the runtime after changing the current device for the host thread. Previous versions of CUDA delayed runtime initialization on the new device until the first runtime call was made after cudaSetDevice(). This change means that it is now very important to check the return value of cudaSetDevice() for initialization errors."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.2. Device Memory - As mentioned in Heterogeneous ......CUDA arrays are opaque memory ...",
    "content": "As mentioned in Heterogeneous Programming, the CUDA programming model assumes a system composed of a host and a device, each with their own separate memory. Kernels operate out of device memory, so the runtime provides functions to allocate, deallocate, and copy device memory, as well as transfer data between host memory and device memory.\n\nDevice memory can be allocated either as linear memory or as CUDA arrays.\n\nCUDA arrays are opaque memory layouts optimized for texture fetching. They are described in Texture and Surface Memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.2. Device Memory - Linear memory is allocated in ......tabletrtdtdtdx8664 AMD64tdtdPO...",
    "content": "Linear memory is allocated in a single unified address space, which means that separately allocated entities can reference one another via pointers, for example, in a binary tree or linked list. The size of the address space depends on the host system (CPU) and the compute capability of the used GPU:\n\nTable 1: Table 1. Linear Memory Address Space\n\n<table><tr><td></td><td>x86_64 (AMD64)</td><td>POWER (ppc64le)</td><td>ARM64</td></tr><tr><td>up to compute capability 5.3 (Maxwell)</td><td>40bit</td><td>40bit</td><td>40bit</td></tr><tr><td>compute capability 6.0 (Pascal) or newer</td><td>up to 47bit</td><td>up to 49bit</td><td>up to 48bit</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.2. Device Memory - Linear memory is typically all...",
    "content": "Note: On devices of compute capability 5.3 (Maxwell) and earlier, the CUDA driver creates an uncommitted 40bit virtual address reservation to ensure that memory allocations (pointers) fall into the supported range. This reservation appears as reserved virtual memory, but does not occupy any physical memory until the program actually allocates memory.\n\nLinear memory is typically allocated using cudaMalloc () and freed using cudaFree () and data transfer between host memory and device memory are typically done using cudaMempy(). In the vector addition code sample of Kernels, the vectors need to be copied from host memory to device memory:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.2. Device Memory - Device code   global void VecA...",
    "content": "// Device code - - global__ void VecAdd(float\\* A, float\\* B, float\\* C, int N) { int  $\\texttt{i} =$  blockDim.x \\* blockIdx.x  $^+$  threadIdx."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.2. Device Memory - x if  texttti  textttN textttC...",
    "content": "x; if  $(\\texttt{i} < \\texttt{N})$ $\\texttt{C} [\\texttt{i}] = \\texttt{A} [\\texttt{i}] + \\texttt{B} [\\texttt{i} ]$  } // Host code int main() { int  $\\texttt{N} = \\ldots$  size_t size  $= \\texttt{N}^{\\star}$  sizeof(float); // Allocate input vectors h_A and h_B in host memory float\\* h_A  $=$  (float\\*)malloc(size); float\\* h_B  $=$  (float\\*)malloc(size); float\\* h_C  $=$  (float\\*)malloc(size); // Initialize input vectors // Allocate vectors in device memory float\\* d_A; cudaMalloc(&d_A, size); float\\* d_B; cudaMalloc(&d_B, size); float\\* d_C; cudaMalloc(&d_C, size); // Copy vectors from host memory to device memory cudaMempy(d_A, h_A, size, cudaMempyHostToDevice);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.2. Device Memory - continued from previous page...cudaMemoopydB hB size cudaMemo...",
    "content": "(continued from previous page)\n\ncudaMemoopy(d_B, h_B, size, cudaMemoopyHostToDevice); // Invoke kernel int threadsPerBlock  $= 256$  . int blocksPerGrid  $=$  (N  $^+$  threadsPerBlock - 1) / threadsPerBlock; VecAdd<<blocksPerGrid, threadsPerBlock- >=(d_A, d_B, d_C, N); // Copy result from device memory to host memory // h_C contains the result in host memory cudaMemoopy(h_C, d_C, size, cudaMemoopyDeviceToHost); // Free device memory cudaFree(d_A); cudaFree(d_B); cudaFree(d_C); // Free host memory"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.2. Device Memory - Linear memory can also be allo...",
    "content": "Linear memory can also be allocated through cudaMallocPitch() and cudaMalloc3D(). These functions are recommended for allocations of 2D or 3D arrays as it makes sure that the allocation is appropriately padded to meet the alignment requirements described in Device Memory Accesses, therefore ensuring best performance when accessing the row addresses or performing copies between 2D arrays and other regions of device memory (using the cudaMemoopy2D() and cudaMemoopy3D() functions). The returned pitch (or stride) must be used to access array elements. The following code sample allocates a width x height 2D array of floating- point values and shows how to loop over the array elements in device code:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.2. Device Memory - Host code int width   64  heig......The following code sample allo...",
    "content": "// Host code int width  $= 64$  ,height  $= 64$  float\\* devPtr; size_t pitch; cudaMallocPitch(&devPtr, &pitch, width \\* sizeof(float), height); MyKernel  $\\epsilon < < 100$ $512 > > >$  (devPtr, pitch, width, height); // Device code - global__ void MyKernel(float\\* devPtr, size_t pitch, int width, int height) { for (int  $\\texttt{r} = \\texttt{0}$  ;r  $<$  height;  $^{+ + }$  { float\\* row  $=$  (float\\*)((char\\*)devPtr  $^+$  r \\* pitch); for (int  $\\texttt{c} = \\texttt{0}$  ;c  $<$  width;  $^{+ + }$  c) { float element  $=$  row[c]; } } }\n\nThe following code sample allocates a width x height x depth 3D array of floating- point values and shows how to loop over the array elements in device code:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.2. Device Memory - Host code int width   64  heig......continues on next page",
    "content": "// Host code int width  $= 64$  ,height  $= 64$  ,depth  $= 64$  cudaExtent extent  $=$  make_cudaExtent(width \\* sizeof(float),\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.2. Device Memory - height depth cudaPitchedPtr de...",
    "content": "height, depth); cudaPitchedPtr devPitchedPtr; cudaMalloc(&devPitchedPtr, extent); MyKernel  $< < < 100$ $512 > > >$  (devPitchedPtr, width, height, depth); // Device code global__ void MyKernel(cudaPitchedPtr devPitchedPtr, int width, int height, int depth) { char\\* devPtr  $=$  devPitchedPtr.ptr; size_t pitch  $=$  devPitchedPtr.pitch; size_t slicePitch  $=$  pitch \\* height; for (int  $z = 0$  .  $z<$  depth;  $^{+ + z}$  ){ char\\* slice  $=$  devPtr  $^+$  z \\* slicePitch; for (int  $y = 0$  .  $y<$  height;  $^{+ + y}$  ){ float\\* row  $=$  (float\\*)(slice  $^+$  y \\* pitch); for (int  $x = 0$  .  $x<$  width;  $^{+ + x}$  ){ float element  $=$  row[x]; } } } } } } }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.2. Device Memory - The reference manual lists all...",
    "content": "Note: To avoid allocating too much memory and thus impacting system- wide performance, request the allocation parameters from the user based on the problem size. If the allocation fails, you can fallback to other slower memory types (cudaMalloc(), cudaHostRegister(), etc.), or return an error telling the user how much memory was needed that was denied. If your application cannot request the allocation parameters for some reason, we recommend using cudaMallocManaged() for platforms that support it.\n\nThe reference manual lists all the various functions used to copy memory between linear memory allocated with cudaMalloc(), linear memory allocated with cudaMallocPitch() or cudaMalloc3D(), CUDA arrays, and memory allocated for variables declared in global or constant memory space."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.2. Device Memory - The following code sample illu......cudaGetSymbolAddress is used t...",
    "content": "The following code sample illustrates various ways of accessing global variables via the runtime API:\n\nconstant float constData[256]; float data[256]; cudaMempcyToSymbol(constData, data, sizeof(data)); cudaMempcyFromSymbol(data, constData, sizeof(data)); device float devData; float value  $= 3$  .14f; cudaMempcyToSymbol(devData, &value, sizeof(float)); device float\\* devPointer; float\\* ptr; cudaMalloc(&ptr, 256 \\* sizeof(float)); cudaMempcyToSymbol(devPointer, &ptr, sizeof(ptr));\n\ncudaGetSymbolAddress() is used to retrieve the address pointing to the memory allocated for a variable declared in global memory space. The size of the allocated memory is obtained through cudaGetSymbolSize()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.3. Device Memory L2 Access Management - When a CUDA kernel accesses a ......Starting with CUDA 10 devices ...",
    "content": "When a CUDA kernel accesses a data region in the global memory repeatedly, such data accesses can be considered to be persisting. On the other hand, if the data is only accessed once, such data accesses can be considered to be streaming.\n\nStarting with CUDA 1.0, devices of compute capability 8.0 and above have the capability to influence persistence of data in the L2 cache, potentially providing higher bandwidth and lower latency accesses to global memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.3.1 L2 cache Set-Aside for Persisting Accesses - A portion of the L2 cache can ......When the GPU is configured in ...",
    "content": "A portion of the L2 cache can be set aside to be used for persisting data accesses to global memory. Persisting accesses have prioritized use of this set- aside portion of L2 cache, whereas normal or streaming, accesses to global memory can only utilize this portion of L2 when it is unused by persisting accesses.\n\nThe L2 cache set- aside size for persisting accesses may be adjusted, within limits:\n\ncudaGetDeviceProperties(&prop, device_id); size_t size = min(int(prop.l2CacheSize * 0.75), prop.persistingL2CacheMaxSize); cudaDeviceSetLimit(cudaLimitPersistingL2CacheSize, size); /* set- aside 3/4 of L2 cache for persisting accesses or the max allowed*/\n\nWhen the GPU is configured in Multi- Instance GPU (MIG) mode, the L2 cache set- aside functionality is disabled."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.3.1 L2 cache Set-Aside for Persisting Accesses - When using the Multi Process S...",
    "content": "When using the Multi- Process Service (MPS), the L2 cache set- aside size cannot be changed by cudaDeviceSetLimit. Instead, the set- aside size can only be specified at start up of MPS server through the environment variable CUDA_DEVICE_DEFAULT_PERSISTING_L2_CACHE_PERCENTAGE_LIMIT."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.3.2 L2 Policy for Persisting Accesses - An access policy window specif......The code example below shows h...",
    "content": "An access policy window specifies a contiguous region of global memory and a persistence property in the L2 cache for accesses within that region.\n\nThe code example below shows how to set an L2 persisting access window using a CUDA Stream."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "CUDA Stream Example - cudaStreamAttribute streamattr......continued from previous page",
    "content": "cudaStreamAttribute stream_attribute; // Stream level attributes data structure stream_attribute.accessPolicyWindow.base_ptr = reinterpret_cast<void*>(ptr); // Global Memory data pointer stream_attribute.accessPolicyWindow.num_bytes = num_bytes; // Number of bytes for persistence access. // (Must be less than cudaDeviceProp::accessPolicyMaxWindowSize) stream_attribute.accessPolicyWindow.hitRatio = 0.6; // Hint for cache hit ratio stream_attribute.accessPolicyWindow.hitProp = cudaAccessPropertyPersisting; // Type of access property on cache hit stream_attribute.accessPolicyWindow.missProp = cudaAccessPropertyStreaming; // Type of access property on cache miss.\n\n(continues on next page)\n\n(continued from previous page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "CUDA Stream Example - Set the attributes to a CUDA s......L2 persistence can also be set...",
    "content": "//Set the attributes to a CUDA stream of type cudaStream_t cudaStreamSetAttribute(stream, cudaStreamAttributeAccessPolicyWindow, &stream_  $\\rightarrow$  attribute);\n\nWhen a kernel subsequently executes in CUDA stream, memory accesses within the global memory extent [ptr..ptr+num_bytes) are more likely to persist in the L2 cache than accesses to other global memory locations.\n\nL2 persistence can also be set for a CUDA Graph Kernel Node as shown in the example below:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "CUDA GraphKernelNode Example - cudaKernelNodeAttrValue nodeat...",
    "content": "cudaKernelNodeAttrValue node_attribute; // Kernel  $\\hookrightarrow$  level attributes data structure node_attribute.accessPolicyWindow.base_ptr  $=$  reinterpret_cast<void\\*>(ptr); // Global  $\\hookrightarrow$  Memory data pointer node_attribute.accessPolicyWindow.num_bytes  $=$  num_bytes; // Number  $\\hookrightarrow$  of bytes for persistence access. // (Must  $\\hookrightarrow$  be less than cudaDeviceProp::accessPolicyMaxWindowSize) node_attribute.accessPolicyWindow.hitRatio  $=$  0.6; // Hint  $\\hookrightarrow$  for cache hit ratio node_attribute.accessPolicyWindow.hitProp  $=$  cudaAccessPropertyPersisting; // Type of  $\\hookrightarrow$  access property on cache hit node_attribute.accessPolicyWindow."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "CUDA GraphKernelNode Example - missProp    cudaAccessProperty...",
    "content": "missProp  $=$  cudaAccessPropertyStreaming; // Type of  $\\hookrightarrow$  access property on cache miss. //Set the attributes to a CUDA Graph Kernel node of type cudaGraphNode_t cudaGraphKernelNodeSetAttribute(node, cudaKernelNodeAttributeAccessPolicyWindow,  $\\mathcal{O}$ $\\hookrightarrow$  node_attribute);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "CUDA GraphKernelNode Example - The hitRatio parameter can be ......For example if the L2 set asid...",
    "content": "The hitRatio parameter can be used to specify the fraction of accesses that receive the hitProp property. In both of the examples above,  $60\\%$  of the memory accesses in the global memory region [ptr..ptr+num_bytes) have the persisting property and  $40\\%$  of the memory accesses have the streaming property. Which specific memory accesses are classified as persisting (the hitProp) is random with a probability of approximately hitRatio; the probability distribution depends upon the hardware architecture and the memory extent.\n\nFor example, if the L2 set- aside cache size is 16KB and the num_bytes in the accessPolicyWindow is 32KB:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "CUDA GraphKernelNode Example - With a hitRatio of 05 the hard......The hitRatio can therefore be ...",
    "content": "With a hitRatio of 0.5, the hardware will select, at random, 16KB of the 32KB window to be designated as persisting and cached in the set- aside L2 cache area. With a hitRatio of 1.0, the hardware will attempt to cache the whole 32KB window in the setaside L2 cache area. Since the set- aside area is smaller than the window, cache lines will be evicted to keep the most recently used 16KB of the 32KB data in the set- aside portion of the L2 cache.\n\nThe hitRatio can therefore be used to avoid thrashing of cache lines and overall reduce the amount of data moved into and out of the L2 cache."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "CUDA GraphKernelNode Example - A hitRatio value below 10 can ...",
    "content": "A hitRatio value below 1.0 can be used to manually control the amount of data different accessPolicyWindows from concurrent CUDA streams can cache in L2. For example, let the L2 set- aside cache size be 16KB; two concurrent kernels in two different CUDA streams, each with a 16KB accessPolicyWindow, and both with hitRatio value 1.0, might evict each others' cache lines when competing for the shared L2 resource. However, if both accessPolicyWindows have a hitRatio value of 0.5, they will be less likely to evict their own or each others' persisting cache lines."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.3.3 L2 Access Properties - Three types of access properti...",
    "content": "Three types of access properties are defined for different global memory data accesses:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.3.3 L2 Access Properties - 1 cudaAccessPropertyStreaming ...",
    "content": "1. cudaAccessPropertyStreaming: Memory accesses that occur with the streaming property are less likely to persist in the L2 cache because these accesses are preferentially evicted.  2. cudaAccessPropertyPersisting: Memory accesses that occur with the persisting property are more likely to persist in the L2 cache because these accesses are preferentially retained in the set-aside portion of L2 cache.  3. cudaAccessPropertyNormal: This access property forcibly resets previously applied persisting access property to a normal status. Memory accesses with the persisting property from previous CUDA kernels may be retained in L2 cache long after their intended use. This persistence-after-use reduces the amount of L2 cache available to subsequent kernels that do not use the persisting property."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.3.3 L2 Access Properties - Resetting an access property w...",
    "content": " Resetting an access property window with the cudaAccessPropertyNormal property removes the persisting (preferential retention) status of the prior access, as if the prior access had been without an access property."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.3.4 L2 Persistence Example - The following example shows ho...",
    "content": "The following example shows how to set- aside L2 cache for persistent accesses, use the set- aside L2 cache in CUDA kernels via CUDA Stream and then reset the L2 cache."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.3.4 L2 Persistence Example - cudaStreamt stream cudaStreamC...",
    "content": "cudaStream_t stream; cudaStreamCreate(&stream); // Create CUDA stream cudaDeviceProp prop; // CUDA device properties variable cudaGetDeviceProperties( &prop, device_id); // Query GPU properties size_t size = min( int(prop.l2CacheSize * 0.75) , prop.persistingL2CacheMaxSize ); cudaDeviceSetLimit( cudaLimitPersistingL2CacheSize, size); // set- aside 3/4 of L2 cache for persisting accesses or the max allowed size_t window_size = min(prop.accessPolicyMaxWindowSize, num_bytes); // Select minimum of user defined num_bytes and max window size. cudaStreamAttrValue stream_attribute; // Stream level attributes data structure stream_attribute. accessPolicyWindow.base_ptr = reinterpret_cast<void*>(data1); // Global Memory data pointer stream_attribute.accessPolicyWindow."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.3.4 L2 Persistence Example - numbytes  windowsize  Number o...",
    "content": "num_bytes = window_size; // Number of bytes for persistence access stream_attribute.accessPolicyWindow.hitRatio = 0.6; // Hint for cache hit ratio stream_attribute.accessPolicyWindow.hitProp = cudaAccessPropertyPersisting; // Persistence Property stream_attribute.accessPolicyWindow.missProp = cudaAccessPropertyStreaming; // Type of access property on cache miss cudaStreamSetAttribute(stream, cudaStreamAttributeAccessPolicyWindow, &stream_attribute); // Set the attributes to a CUDA Stream for(int i = 0; i < 10; i++) {"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.3.4 L2 Persistence Example - continues on next page",
    "content": "(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.3.4 L2 Persistence Example - cudakernelAgridsizeblocksize0s...",
    "content": "cuda_kernelA<<grid_size,block_size,0,stream>>>data1); // This data1 is used by a kernel multiple times } // [data1  $^+$  num_bytes) benefits from L2 persistence cuda_kernelB  $\\epsilon_{*}^{*}$  grid_size,block_size,0,stream>>>data1);  $\\leftrightarrow$  // A different kernel in the same stream can also benefit  $\\leftrightarrow$  // from the persistence of data1 stream_attribute.accessPolicyWindow.num_bytes  $= 0$  ."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.3.4 L2 Persistence Example - leftrightarrow   Setting the w...",
    "content": "  $\\leftrightarrow$  // Setting the window size to 0 disable it cudaStreamSetAttribute(stream, cudaStreamAttributeAccessPolicyWindow, &stream_  $\\leftrightarrow$  attribute); // Overwrite the access policy attribute to a CUDA Stream cudaCtxResetPersistingL2Cache();  $\\leftrightarrow$  // Remove any persistent lines in L2 cuda_kernelc  $\\epsilon_{*}^{*}$  grid_size,block_size,0,stream>>>data2);  $\\leftrightarrow$  // data2 can now benefit from full L2 in normal mode"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.3.5 Reset L2 Access to Normal - A persisting L2 cache line fro......3 Eventually untouched lines a...",
    "content": "# 6.2.3.5 Reset L2 Access to Normal\nA persisting L2 cache line from a previous CUDA kernel may persist in L2 long after it has been used. Hence, a reset to normal for L2 cache is important for streaming or normal memory accesses to utilize the L2 cache with normal priority. There are three ways a persisting access can be reset to normal status.\n\n1. Reset a previous persisting memory region with the access property, cudaAccessProper tyNormal. \n2. Reset all persisting L2 cache lines to normal by calling cudaCtxResetPersistingL2Cache(). \n3. Eventually untouched lines are automatically reset to normal. Reliance on automatic reset is strongly discouraged because of the undetermined length of time required for automatic reset to occur."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.3.6 Manage Utilization of L2 set-aside cache - Multiple CUDA kernels executin......To manage utilization of the s...",
    "content": "Multiple CUDA kernels executing concurrently in different CUDA streams may have a different access policy window assigned to their streams. However, the L2 set- aside cache portion is shared among all these concurrent CUDA kernels. As a result, the net utilization of this set- aside cache portion is the sum of all the concurrent kernels' individual use. The benefits of designating memory accesses as persisting diminish as the volume of persisting accesses exceeds the set- aside L2 cache capacity.\n\nTo manage utilization of the set- aside L2 cache portion, an application must consider the following:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.3.6 Manage Utilization of L2 set-aside cache - Size of L2 set aside cache CUD...",
    "content": "Size of L2 set- aside cache. CUDA kernels that may concurrently execute. The access policy window for all the CUDA kernels that may concurrently execute. When and how L2 reset is required to allow normal or streaming accesses to utilize the previously set- aside L2 cache with equal priority."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.3.8 Control L2 Cache Set-Aside Size for Persisting Memory Access - Properties related to L2 cache......The L2 set aside cache size fo...",
    "content": "Properties related to L2 cache are a part of cudaDeviceProp struct and can be queried using CUDA runtime API cudaGetDeviceProperties\n\nCUDA Device Properties include:\n\n12CacheSize: The amount of available L2 cache on the GPU. persistingL2CacheMaxSize: The maximum amount of L2 cache that can be set- aside for persisting memory accesses. accessPolicyMaxWindowsize: The maximum size of the access policy window.\n\n# 6.2.3.8 Control L2 Cache Set-Aside Size for Persisting Memory Access\nThe L2 set- aside cache size for persisting memory accesses is queried using CUDA runtime API cudaDeviceGetLimit and set using CUDA runtime API cudaDeviceSetLimit as a cudaLimit. The maximum value for setting this limit is cudaDeviceProp::persistingL2CacheMaxSize."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.3.8 Control L2 Cache Set-Aside Size for Persisting Memory Access - enum cudalimit   other fields ...",
    "content": "enum cudalimit { /* other fields not shown */ cudalimitPersistingL2CacheSize };"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.4. Shared Memory - As detailed in Variable Memory......The following code sample is a...",
    "content": "As detailed in Variable Memory Space Specifiers shared memory is allocated using the __shared__ memory space specifier.\n\nShared memory is expected to be much faster than global memory as mentioned in Thread Hierarchy and detailed in Shared Memory. It can be used as scratchpad memory (or software managed cache) to minimize global memory accesses from a CUDA block as illustrated by the following matrix multiplication example.\n\nThe following code sample is a straightforward implementation of matrix multiplication that does not take advantage of shared memory. Each thread reads one row of A and one column of  $B$  and computes the corresponding element of C as illustrated in Figure 8. A is therefore read B.width times from global memory and  $B$  is read A.height times."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.4. Shared Memory - Matrices are stored in row maj......Matrix dA dAwidth  Awidth dAhe...",
    "content": "// Matrices are stored in row- major order: // M(row, col) = *(M.elements + row * M.width + col) typedef struct { int width; int height; float* elements; } Matrix; // Thread block size #define BLOCK_SIZE 16 // Forward declaration of the matrix multiplication kernel __global__ void MatMulKernel(const Matrix, const Matrix, Matrix);\n\n(continues on next page)\n\n// Matrix multiplication - Host code // Matrix dimensions are assumed to be multiples of BLOCK_SIZE void MatMul(const Matrix A, const Matrix B, Matrix C) {\n\n// Load A and B to device memory\n\nMatrix d_A; d_A.width = A.width; d_A.height = A.height; size_t size = A.width * A.height * sizeof(float); cudaMalloc(&d_A.elements, size); cuda memcpy(d_A.elements, A.elements, size, cudaMalloc(&d_A.elements, size, cudaMalloc(&d_B.width);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.4. Shared Memory - Matrix dB dBwidth  Bwidth dBhe......Matrix dC dCwidth  Cwidth dChe...",
    "content": "Matrix d_B; d_B.width = B.width; d_B.height = B.height; size = B.width * B.height * sizeof(float); cudaMalloc(&d_B.elements, size); cudaMalloc(&d_B.elements, B.elements, size, cudaMalloc(&d_B.elements, size);\n\n// Allocate C in device memory\n\nMatrix d_C; d_C.width = C.width; d_C.height = C.height; size = C.width * C.height * sizeof(float); cudaMalloc(&d_C.elements, size);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "// Invoke kernel - dim3 dimBlockBLOCKSIZE BLOCKSI......Matrix multiplication kernel c...",
    "content": "dim3 dimBlock(BLOCK_SIZE, BLOCK_SIZE); dim3 dimGrid(B.width / dimBlock.x, A.height / dimBlock.y); MatMulKernel<<<dimGrid, dimBlock>>> (d_A, d_B, d_C);\n\n// Read C from device memory cudaMalloc(C.elements, d_C.elements, size, cudaMalloc(DeviceToHost);\n\n// Free device memory\n\ncudaFree(d_A.elements); cudaFree(d_B.elements); cudaFree(d_C.elements);\n\n}\n\n// Matrix multiplication kernel called by MatMul() global__ void MatMulKernel(Matrix A, Matrix B, Matrix C) {"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "// Invoke kernel - Each thread computes one eleme......The following code sample is a...",
    "content": "// Each thread computes one element of C // by accumulating results into Cvalue float Cvalue = 0; int row = blockIdx.y * blockDim.y + threadIdx.y; int col = blockIdx.x * blockDim.x + threadIdx.x; for (int e = 0; e < A.width; ++e) Cvalue += A.elements[row * A.width + e] * B.elements[e * B.width + col]; C.elements[row * C.width + col] = Cvalue; }\n\nThe following code sample is an implementation of matrix multiplication that does take advantage of shared memory. In this implementation, each thread block is responsible for computing one square sub- matrix Csub of C and each thread within the block is responsible for computing one element of Csub. As illustrated in Figure 9, Csub is equal to the product of two rectangular matrices: the sub-"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "// Invoke kernel - httpscdnmineruopenxlaborgcnres......Fig 1 Matrix Multiplication wi...",
    "content": "![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/158c470520c868862e060781bd7244b304e305b24148510ae66ad32ccd087369.jpg)  \nFig. 1: Matrix Multiplication without Shared Memory"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "// Invoke kernel - matrix of A of dimension Awidt...",
    "content": "matrix of A of dimension (A.width, block_size) that has the same row indices as Csub, and the sub- matrix of B of dimension (block_size, A.width) that has the same column indices as Csub. In order to fit into the device's resources, these two rectangular matrices are divided into as many square matrices of dimension block_size as necessary and Csub is computed as the sum of the products of these square matrices. Each of these products is performed by first loading the two corresponding square matrices from global memory to shared memory with one thread loading one element of each matrix, and then by having each thread compute one element of the product. Each thread accumulates the result of each of these products into a register and once done writes the result to global memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "// Invoke kernel - By blocking the computation th......The Matrix type from the previ...",
    "content": "By blocking the computation this way, we take advantage of fast shared memory and save a lot of global memory bandwidth since A is only read (B.width / block_size) times from global memory and B is read (A.height / block_size) times.\n\nThe Matrix type from the previous code sample is augmented with a stride field, so that sub- matrices can be efficiently represented with the same type. _device_ functions are used to get and set elements and build any sub- matrix from a matrix."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "// Invoke kernel - Matrices are stored in row maj...",
    "content": "// Matrices are stored in row- major order: // M(row, col) = *(M.elements + row * M.string + col) typedef struct { int width; int height; int stride; float* elements; } Matrix; // Get a matrix element __device__ float GetElement(const Matrix A, int row, int col) { return A.elements[row * A.string + col]; } // Set a matrix element __device__ void SetElement(Matrix A, int row, int col, float value) { A.elements[row * A.string + col] = value; } // Get the BLOCK_SIZE * BLOCK_SIZE sub- matrix Asub of A that is // located col sub- matrices to the right and row sub- matrices down // from the upper- left corner of A __device__ Matrix GetSubMatrix(Matrix A, int row, int col) { Matrix Asub; Asub.width = BLOCK_SIZE; Asub.height = BLOCK_SIZE; Asub.string = A.string; Asub.elements = &A.elements[A."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "// Invoke kernel - string  BLOCKSIZE  row  BLOCKS...",
    "content": "string * BLOCK_SIZE * row + BLOCK_SIZE * col]; return Asub; } // Thread block size #define BLOCK_SIZE 16 // Forward declaration of the matrix multiplication kernel __global__ void MatMulKernel(const Matrix, const Matrix, Matrix); // Matrix multiplication - Host code // Matrix dimensions are assumed to be multiples of BLOCK_SIZE void MatMul(const Matrix A, const Matrix B, Matrix C) { // Load A and B to device memory"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "// Invoke kernel - Matrix dA dAwidth  dAstride  A...",
    "content": "Matrix d_A; d_A.width = d_A.stride = A.width; d_A.height = A.height; size_t size = A.width * A.height * sizeof(float); cudaMalloc(&d_A.elements, size); cuda memcpy(d_A.elements, A.elements, size, cudaMemcpyHostToDevice); Matrix d_B; d_B.width = d_B.stride = B.width; d_B.height = B.height; size = B.width * B.height * sizeof(float); cudaMalloc(&d_B.elements, size); cudaMemcpy(d_B.elements, B.elements, size, cudaMemcpyHostToDevice); // Allocate C in device memory Matrix d_C; d_C.width = d_C.stride = C.width; d_C.height = C.height; size = C.width * C.height * sizeof(float); cudaMalloc(&d_C.elements, size); // Invoke kernel dim3 dimBlock(BLOCK_SIZE, BLOCK_SIZE); dim3 dimGrid(B.width / dimBlock.x, A.height / dimBlock."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "// Invoke kernel - y MatMulKerneldimGrid dimBlock...",
    "content": "y); MatMulKernel<<<dimGrid, dimBlock>>(d_A, d_B, d_C); // Read C from device memory cudaMemcpy(C.elements, d_C.elements, size, cudaMemcpyDeviceToHost); // Free device memory cudaFree(d_A.elements); cudaFree(d_B.elements); cudaFree(d_C.elements); // Matrix multiplication kernel called by MatMul() - - global__ void MatMulKernel(Matrix A, Matrix B, Matrix C) { // Block row and column int blockRow = blockIdx.y; int blockCol = blockIdx.x; // Each thread block computes one sub- matrix Csub of C Matrix Csub = GetSubMatrix(C, blockRow, blockCol); // Each thread computes one element of Csub // by accumulating results into Cvalue float Cvalue = 0; // Thread row and column within Csub int row = threadIdx.y; int col = threadIdx."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "// Invoke kernel - x  Loop over all the sub matri...",
    "content": "x; // Loop over all the sub- matrices of A and B that are // required to compute Csub // Multiply each pair of sub- matrices together // and accumulate the results for (int m = 0; m < (A.width / BLOCK_SIZE); ++m) { // Get sub- matrix A sub of A Matrix Asub = GetSubMatrix(A, blockRow, m); // Get sub- matrix Bsub of B Matrix Bsub = GetSubMatrix(B, m, blockCol); // Shared memory used to store Asub and Bsub respectively - - shared__ float As[BLOCK_SIZE][BLOCK_SIZE]; - - shared__ float Bs[BLOCK_SIZE][BLOCK_SIZE]; // Load Asub and Bsub from device memory to shared memory"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "// Invoke kernel - Each thread loads one element ...",
    "content": "// Each thread loads one element of each sub- matrix As[row][col]  $=$  GetElement(Asub, row, col); Bs[row][col]  $=$  GetElement(Bsub, row, col); // Synchronize to make sure the sub- matrices are loaded // before starting the computation - - syncthreads(); // Multiply Asub and Bsub together for (int e  $=$  0; e  $<$  BLOCK_SIZE;  $+ + e$  Cvalue  $+ =$  As[row][e] \\* Bs[e][col]; // Synchronize to make sure that the preceding // computation is done before loading two new // sub- matrices of A and B in the next iteration - - syncthreads(); } // Write Csub to device memory // Each thread writes one element SetElement(Csub, row, col, Cvalue); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.5. Distributed Shared Memory - Thread block clusters introduc...",
    "content": "Thread block clusters introduced in compute capability 9.0 provide the ability for threads in a thread block cluster to access shared memory of all the participating thread blocks in a cluster. This partitioned shared memory is called Distributed Shared Memory, and the corresponding address space is called Distributed shared memory address space. Threads that belong to a thread block cluster, can read, write or perform atomics in the distributed address space, regardless whether the address belongs to the local thread block or a remote thread block. Whether a kernel uses distributed shared memory or not, the shared memory size specifications, static or dynamic is still per thread block."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.5. Distributed Shared Memory - The size of distributed shared...",
    "content": " The size of distributed shared memory is just the number of thread blocks per cluster multiplied by the size of shared memory per thread block."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.5. Distributed Shared Memory - Accessing data in distributed ...",
    "content": "Accessing data in distributed shared memory requires all the thread blocks to exist. A user can guarantee that all thread blocks have started executing using cluster. sync() from Cluster Group API. User also needs to ensure that all the distributed shared memory operations are completed before a thread block exits."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.5. Distributed Shared Memory - CUDA provides a mechanism to a...",
    "content": "CUDA provides a mechanism to access to distributed shared memory, and applications can benefit from leveraging its capabilities. Lets look at a simple histogram computation and how to optimize it on the GPU using thread block cluster. A standard way of computing histograms is do the computation in the shared memory of each thread block and then perform global memory atomics. A limitation of this approach is the shared memory capacity. Once the histogram bins no longer fit in the shared memory, a user needs to directly compute histograms and hence the atomics in the global memory. With distributed shared memory, CUDA provides an intermediate step, where a depending on the histogram bins size, histogram can be computed in shared memory, distributed shared memory or global memory directly."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.5. Distributed Shared Memory - The CUDA kernel example below ......Fig 2 Matrix Multiplication wi...",
    "content": "The CUDA kernel example below shows how to compute histograms in shared memory or distributed shared memory, depending on the number of histogram bins.\n\n```c#include <cooperative_groups.h> // Distributed Shared memory histogram kernel - - global__ void clusterHist_kernel(int *bins, const int nbins, const int bins_per_block, const int *__restrict__ input, (continues on next page)```\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/af44bf22a827facb949c1dcf74e386d28b37546762eb1633b45c3e8a49575f2a.jpg)  \nFig. 2: Matrix Multiplication with Shared Memory"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.5. Distributed Shared Memory - sizet arraysize extern shared ...",
    "content": "(size_t array_size) extern _shared_ int smem[]; namespace cg  $=$  cooperative_groups; int tid  $=$  cg::this_grid().thread_rank(); // Cluster initialization, size and calculating local bin offsets. cg::cluster_group cluster  $=$  cg::this_cluster(); unsigned int clusterBlockRank  $=$  cluster.block_rank(); int cluster_size  $=$  cluster.dim_blocks().x; for (int  $\\textbf{i} =$  threadIdx.x; i  $<$  bins_per_block; i  $+ =$  blockDim.x) { smem[i]  $= \\Theta$  ; //Initialize shared memory histogram to zeros } // cluster synchronization ensures that shared memory is initialized to zero in // all thread blocks in the cluster. It also ensures that all thread blocks // have started executing and they exist concurrently. cluster."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.5. Distributed Shared Memory - sync for int  textbfi   tid i ...",
    "content": "sync(); for (int  $\\textbf{i} =$  tid; i  $<$  array_size; i  $+ =$  blockDim.x \\* gridDim.x) { int ldata  $=$  input[i]; //Find the right histogram bin. int binid  $=$  ldata; if (ldata  $< \\theta$  binid  $= \\Theta$  else if (ldata  $> =$  nbins) binid  $=$  nbins - 1; //Find destination block rank and offset for computing //distributed shared memory histogram int dst_block_rank  $=$  (int)(binid / bins_per_block); int dst_offset  $=$  binid % bins_per_block; //Pointer to target block shared memory int \\*dst_smem  $=$  cluster."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.5. Distributed Shared Memory - mapsharedranksmem dstblockrank...",
    "content": "map_shared_rank(smem, dst_block_rank); //Perform atomic update of the histogram bin atomicAdd(dst_smem  $^+$  dst_offset, 1); } // cluster synchronization is required to ensure all distributed shared // memory operations are completed and no thread block exits while // other thread blocks are still accessing distributed shared memory cluster.sync(); // Perform global memory histogram, using the local distributed memory histogram int \\*lbins  $=$  bins  $^+$  cluster.block_rank() \\* bins_per_block; for (int  $\\textbf{i} =$  threadIdx.x; i  $<$  bins_per_block; i  $+ =$  blockDim.x) { atomicAdd(&lbins[i], smem[i]); } }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.5. Distributed Shared Memory - The above kernel can be launch...",
    "content": "The above kernel can be launched at runtime with a cluster size depending on the amount of distributed shared memory required. If histogram is small enough to fit in shared memory of just one block, user can launch kernel with cluster size 1. The code snippet below shows how to launch a cluster kernel dynamically based depending on shared memory requirements."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.5. Distributed Shared Memory - Launch via extensible launch  ...",
    "content": "// Launch via extensible launch { cudaLaunchConfig_t config  $=$  {0}; config.gridDim  $=$  array_size / threads_per_block; config.blockDim  $=$  threads_per_block; // cluster_size depends on the histogram size. // ( cluster_size  $= = 1$  ) implies no distributed shared memory, just thread block  $\\leftrightarrow$  local shared memory int cluster_size  $= 2$  ; // size 2 is an example here int nbins_per_block  $=$  nbins / cluster_size; //dynamic shared memory size is per block. //Distributed shared memory size  $=$  cluster_size \\* nbins_per_block \\* sizeof(int) config.dynamicSmemBytes  $=$  nbins_per_block \\* sizeof(int); CUDA_CHECK(: cudaFuncSetAttribute((void \\*)clusterHist_kernel, cudaFuncAttributeMaxDynamicSharedMemorySize, config."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.5. Distributed Shared Memory - dynamicSmemBytes cudaLaunchAtt...",
    "content": "dynamicSmemBytes)); cudaLaunchAttribute attribute[1]; attribute[0] id  $=$  cudaLaunchAttributeClusterDimension; attribute[0].val.clusterDim.x  $=$  cluster_size; attribute[0].val.clusterDim.y  $=$  1; attribute[0].val.clusterDim.z  $=$  1; config.numAttrs  $= 1$  . config.attrs  $=$  attribute; cudaLaunchKernelEx(&config, clusterHist_kernel, bins, nbins, nbins_per_block, input,  $\\leftrightarrow$  array_size); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.6. Page-Locked Host Memory - The runtime provides functions......Using page locked host memory ...",
    "content": "The runtime provides functions to allow the use of page- locked (also known as pinned) host memory (as opposed to regular pageable host memory allocated by malloc()):\n\n- cudaHostAlloc() and cudaFreeHost() allocate and free page-locked host memory;- cudaHostRegister() page-locks a range of memory allocated by malloc() (see reference manual for limitations).\n\nUsing page- locked host memory has several benefits:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.6. Page-Locked Host Memory - if host memory is allocated as......Note Page locked host memory i...",
    "content": "- Copies between page-locked host memory and device memory can be performed concurrently with kernel execution for some devices as mentioned in Asynchronous Concurrent Execution.- On some devices, page-locked host memory can be mapped into the address space of the device, eliminating the need to copy it to or from device memory as detailed in Mapped Memory.- On systems with a front-side bus, bandwidth between host memory and device memory is higher\n\nif host memory is allocated as page- locked and even higher if in addition it is allocated as write- combining as described in Write- Combining Memory.\n\nNote: Page- locked host memory is not cached on non I/O coherent Tegra devices. Also, cuda- HostRegister() is not supported on non I/O coherent Tegra devices."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.6. Page-Locked Host Memory - The simple zero copy CUDA samp...",
    "content": "The simple zero- copy CUDA sample comes with a detailed document on the page- locked memory APIs."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.6.1 Portable Memory - A block of page locked memory ...",
    "content": "# 6.2.6.1 Portable Memory\nA block of page- locked memory can be used in conjunction with any device in the system (see Multi- Device System for more details on multi- device systems), but by default, the benefits of using page- locked memory described above are only available in conjunction with the device that was current when the block was allocated (and with all devices sharing the same unified address space, if any, as described in Unified Virtual Address Space). To make these advantages available to all devices, the block needs to be allocated by passing the flag cudaHostAllocPortable to cudaHostAlloc() or page- locked by passing the flag cudaHostRegisterPortable to cudaHostRegister()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.6.2 Write-Combining Memory - By default page locked host me......Using CPU atomic instructions ...",
    "content": "# 6.2.6.2 Write-Combining Memory\nBy default page- locked host memory is allocated as cacheable. It can optionally be allocated as write- combining instead by passing flag cudaHostAllocWriteCombined to cudaHostAlloc(). Write- combining memory frees up the host's L1 and L2 cache resources, making more cache available to the rest of the application. In addition, write- combining memory is not snooped during transfers across the PCI Express bus, which can improve transfer performance by up to  $40\\%$ .\n\nReading from write- combining memory from the host is prohibitively slow, so write- combining memory should in general be used for memory that the host only writes to.\n\nUsing CPU atomic instructions on WC memory should be avoided because not all CPU implementations guarantee that functionality."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.6.3 Mapped Memory - A block of page locked host me......Accessing host memory directly...",
    "content": "A block of page- locked host memory can also be mapped into the address space of the device by passing flag cudaHostAllocMapped to cudaHostAlloc() or by passing flag cudaHostRegisterMapped to cudaHostRegister(). Such a block has therefore in general two addresses: one in host memory that is returned by cudaHostAlloc() or malloc(), and one in device memory that can be retrieved using cudaHostGetDevicePointer() and then used to access the block from within a kernel. The only exception is for pointers allocated with cudaHostAlloc() and when a unified address space is used for the host and the device as mentioned in Unified Virtual Address Space.\n\nAccessing host memory directly from within a kernel does not provide the same bandwidth as device memory, but does have some advantages:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.6.3 Mapped Memory - There is no need to allocate a......Since mapped page locked memor...",
    "content": "There is no need to allocate a block in device memory and copy data between this block and the block in host memory; data transfers are implicitly performed as needed by the kernel; There is no need to use streams (see Concurrent Data Transfers) to overlap data transfers with kernel execution; the kernel- originated data transfers automatically overlap with kernel execution.\n\nSince mapped page- locked memory is shared between host and device however, the application must synchronize memory accesses using streams or events (see Asynchronous Concurrent Execution) to avoid any potential read- after- write, write- after- read, or write- after- write hazards."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.6.3 Mapped Memory - To be able to retrieve the dev......Note that atomic functions see...",
    "content": "To be able to retrieve the device pointer to any mapped page- locked memory, page- locked memory mapping must be enabled by calling cudaSetDeviceFlags() with the cudaDeviceMapHost flag before any other CUDA call is performed. Otherwise, cudaHostGetDevicePointer() will return an error.\n\ncudaHostGetDevicePointer() also returns an error if the device does not support mapped page- locked host memory. Applications may query this capability by checking the canMapHostMemory device property (see Device Enumeration), which is equal to 1 for devices that support mapped page- locked host memory.\n\nNote that atomic functions (see Atomic Functions) operating on mapped page- locked memory are not atomic from the point of view of the host or other devices."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.6.3 Mapped Memory - Also note that CUDA runtime re...",
    "content": "Also note that CUDA runtime requires that 1- byte, 2- byte, 4- byte, and 8- byte naturally aligned loads and stores to host memory initiated from the device are preserved as single accesses from the point of view of the host and other devices. On some platforms, atomics to memory may be broken by the hardware into separate load and store operations. These component load and store operations have the same requirements on preservation of naturally aligned accesses. As an example, the CUDA runtime does not support a PCI Express bus topology where a PCI Express bridge splits 8- byte naturally aligned writes into two 4- byte writes between the device and the host."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.7. Memory Synchronization Domains",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.7.1 Memory Fence Interference - Some CUDA applications may see......assertx  1tdtrtable",
    "content": "Some CUDA applications may see degraded performance due to memory fence/flush operations waiting on more transactions than those necessitated by the CUDA memory consistency model.\n\n<table><tr><td>__managed__ int x = 0;\n__device__ cuda::atomic\n__int, cuda::thread_scope_\n__device&amp;gt; a(0);\n__managed__ cuda::atomic\n__int, cuda::thread_scope_\n__system&amp;gt; b(0);</td><td></td><td></td></tr><tr><td>Thread 1 (SM)</td><td>Thread 2 (SM)</td><td>Thread 3 (CPU)</td></tr><tr><td>x = 1;\na = 1;</td><td>while (a != 1);\nassert(x == 1);\nb = 1;</td><td>while (b != 1);\nassert(x == 1);</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.7.1 Memory Fence Interference - Consider the example above The......The memory ordering provided b...",
    "content": "Consider the example above. The CUDA memory consistency model guarantees that the asserted condition will be true, so the write to x from thread 1 must be visible to thread 3, before the write to b from thread 2.\n\nThe memory ordering provided by the release and acquire of a is only sufficient to make x visible to thread 2, not thread 3, as it is a device- scope operation. The system- scope ordering provided by release and acquire of b, therefore, needs to ensure not only writes issued from thread 2 itself are visible to"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.7.1 Memory Fence Interference - thread 3 but also writes from ......Note that fences may occur exp...",
    "content": "thread 3, but also writes from other threads that are visible to thread 2. This is known as cumulativity. As the GPU cannot know at the time of execution which writes have been guaranteed at the source level to be visible and which are visible only by chance timing, it must cast a conservatively wide net for in- flight memory operations.\n\nThis sometimes leads to interference: because the GPU is waiting on memory operations it is not required to at the source level, the fence/flush may take longer than necessary.\n\nNote that fences may occur explicitly as intrinsics or atomics in code, like in the example, or implicitly to implement synchronizes- with relationships at task boundaries."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.7.1 Memory Fence Interference - A common example is when a ker...",
    "content": "A common example is when a kernel is performing computation in local GPU memory, and a parallel kernel (e.g. from NCCL) is performing communications with a peer. Upon completion, the local kernel will implicitly flush its writes to satisfy any synchronizes- with relationships to downstream work. This may unnecessarily wait, fully or partially, on slower nvlink or PCIe writes from the communication kernel."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.7.2 Isolating Traffic with Domains - Beginning with Hopper architec...",
    "content": "Beginning with Hopper architecture GPUs and CUDA 12.0, the memory synchronization domains feature provides a way to alleviate such interference. In exchange for explicit assistance from code, the GPU can reduce the net cast by a fence operation. Each kernel launch is given a domain ID. Writes and fences are tagged with the ID, and a fence will only order writes matching the fence's domain. In the concurrent compute vs communication example, the communication kernels can be placed in a different domain."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.7.2 Isolating Traffic with Domains - When using domains code must a......Note that this modifies the de...",
    "content": "When using domains, code must abide by the rule that ordering or synchronization between distinct domains on the same GPU requires system- scope fencing. Within a domain, device- scope fencing remains sufficient. This is necessary for cumulativity as one kernel's writes will not be encompassed by a fence issued from a kernel in another domain. In essence, cumulativity is satisfied by ensuring that cross- domain traffic is flushed to the system scope ahead of time.\n\nNote that this modifies the definition of thread_scope_device. However, because kernels will default to domain 0 as described below, backward compatibility is maintained."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.7.3 Using Domains in CUDA - Domains are accessible via the......The domain count can be querie...",
    "content": "Domains are accessible via the new launch attributes cudaLaunchAttributeMemSyncDomain and cudaLaunchAttributeMemSyncDomainMap. The former selects between logical domains cudaLaunchMemSyncDomainDefault and cudaLaunchMemSyncDomainRemote, and the latter provides a mapping from logical to physical domains. The remote domain is intended for kernels performing remote memory access in order to isolate their memory traffic from local kernels. Note, however, the selection of a particular domain does not affect what memory access a kernel may legally perform.\n\nThe domain count can be queried via device attribute cudaDevAttrMemSyncDomainInCount. Hopper has 4 domains. To facilitate portable code, domains functionality can be used on all devices and CUDA will report a count of 1 prior to Hopper."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.7.3 Using Domains in CUDA - Having logical domains eases a...",
    "content": "Having logical domains eases application composition. An individual kernel launch at a low level in the stack, such as from NCCL, can select a semantic logical domain without concern for the surrounding application architecture. Higher levels can steer logical domains using the mapping. The default value for the logical domain if it is not set is the default domain, and the default mapping is to map the default domain to 0 and the remote domain to 1 (on GPUs with more than 1 domain). Specific libraries may tag launches with the remote domain in CUDA 12.0 and later; for example, NCCL 2.16 will do so. Together, this provides a beneficial use pattern for common applications out of the box, with no code"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.7.3 Using Domains in CUDA - changes needed in other compon......Example of launching a kernel ...",
    "content": "changes needed in other components, frameworks, or at application level. An alternative use pattern, for example in an application using nvshmem or with no clear separation of kernel types, could be to partition parallel streams. Stream A may map both logical domains to physical domain O, stream B to 1, and so on.\n\n// Example of launching a kernel with the remote logical domain  cudaLaunchAttribute domainAttr;  domainAttr.id = cudaLaunchAttrMemSyncDomain;  domainAttr.val = cudaLaunchMemSyncDomainRemote;  cudaLaunchConfig_t config;  // Fill out other config fields  config.attrs = &domainAttr;  config.numAttrs = 1;  cudaLaunchKernelEx(&config, myKernel, kernelArg1, kernelArg2...);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.7.3 Using Domains in CUDA - Example of setting a mapping f...",
    "content": "// Example of setting a mapping for a stream  // (This mapping is the default for streams starting on Hopper if not  // explicitly set, and provided for illustration)  cudaLaunchAttributeValue mapAttr;  mapAttr.memSyncDomainMap.default_ = 0;  mapAttr.memSyncDomainMap.remote = 1;  cudaStreamSetAttribute(stream, cudaLaunchAttrMemSyncDomainMap, &mapAttr);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.7.3 Using Domains in CUDA - Example of mapping different s......As with other launch attribute...",
    "content": "// Example of mapping different streams to different physical domains, ignoring  // logical domain settings  cudaLaunchAttributeValue mapAttr;  mapAttr.memSyncDomainMap.default_ = 0;  mapAttr.memSyncDomainMap.remote = 0;  cudaStreamSetAttribute(streamA, cudaLaunchAttrMemSyncDomainMap, &mapAttr);  mapAttr.memSyncDomainMap.default_ = 1;  mapAttr.memSyncDomainMap.remote = 1;  cudaStreamSetAttribute(streamB, cudaLaunchAttrMemSyncDomainMap, &mapAttr);\n\nAs with other launch attributes, these are exposed uniformly on CUDA streams, individual launches using cudaLaunchKernelEx, and kernel nodes in CUDA graphs. A typical use would set the mapping at stream level and the logical domain at launch level (or bracketing a section of stream use) as described above."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.7.3 Using Domains in CUDA - Both attributes are copied to ...",
    "content": "Both attributes are copied to graph nodes during stream capture. Graphs take both attributes from the node itself, essentially an indirect way of specifying a physical domain. Domain- related attributes set on the stream a graph is launched into are not used in execution of the graph."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8. Asynchronous Concurrent Execution - CUDA exposes the following ope......The level of concurrency achie...",
    "content": "CUDA exposes the following operations as independent tasks that can operate concurrently with one another:\n\n- Computation on the host;- Computation on the device;- Memory transfers from the host to the device;- Memory transfers from the device to the host;- Memory transfers within the memory of a given device;\n\n- Memory transfers among devices.\n\nThe level of concurrency achieved between these operations will depend on the feature set and compute capability of the device as described below."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.1 Concurrent Execution between Host and Device - Concurrent host execution is f...",
    "content": "Concurrent host execution is facilitated through asynchronous library functions that return control to the host thread before the device completes the requested task. Using asynchronous calls, many device operations can be queued up together to be executed by the CUDA driver when appropriate device resources are available. This relieves the host thread of much of the responsibility to manage the device, leaving it free for other tasks. The following device operations are asynchronous with respect to the host:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.1 Concurrent Execution between Host and Device - triangleright  Kernel launches......Programmers can globally disab...",
    "content": "$\\triangleright$  Kernel launches;  $\\triangleright$  Memory copies within a single device's memory;  $\\triangleright$  Memory copies from host to device of a memory block of 64 KB or less;  $\\triangleright$  Memory copies performed by functions that are suffixed with Async;  $\\triangleright$  Memory set function calls.\n\nProgrammers can globally disable asynchronicity of kernel launches for all CUDA applications running on a system by setting the CUDA_LAUNCH_BLOCKING environment variable to 1. This feature is provided for debugging purposes only and should not be used as a way to make production software run reliably."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.1 Concurrent Execution between Host and Device - Kernel launches are synchronou...",
    "content": "Kernel launches are synchronous if hardware counters are collected via a profiler (Nisight, Visual Profiler) unless concurrent kernel profiling is enabled. Async memory copies might also be synchronous if they involve host memory that is not page- locked."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.2 Concurrent Kernel Execution - Some devices of compute capabi......Kernels that use many textures...",
    "content": "# 6.2.8.2 Concurrent Kernel Execution\nSome devices of compute capability 2. x and higher can execute multiple kernels concurrently. Applications may query this capability by checking the concurrentKernels device property (see Device Enumeration), which is equal to 1 for devices that support it.\n\nThe maximum number of kernel launches that a device can execute concurrently depends on its compute capability and is listed in Table 15.\n\nA kernel from one CUDA context cannot execute concurrently with a kernel from another CUDA context.\n\nKernels that use many textures or a large amount of local memory are less likely to execute concurrently with other kernels."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.3 Overlap of Data Transfer and Kernel Execution - Some devices can perform an as......It is also possible to perform...",
    "content": "# 6.2.8.3 Overlap of Data Transfer and Kernel Execution\nSome devices can perform an asynchronous memory copy to or from the GPU concurrently with kernel execution. Applications may query this capability by checking the asyncEngineCount device property (see Device Enumeration), which is greater than zero for devices that support it. If host memory is involved in the copy, it must be page- locked.\n\nIt is also possible to perform an intra- device copy simultaneously with kernel execution (on devices that support the concurrentKernels device property) and/or with copies to or from the device (for devices that support the asyncEngineCount property). Intra- device copies are initiated using the standard memory copy functions with destination and source addresses residing on the same device."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.4 Concurrent Data Transfers - Some devices of compute capabi...",
    "content": "Some devices of compute capability 2. x and higher can overlap copies to and from the device. Applications may query this capability by checking the asyncEngineCount device property (see Device Enumeration), which is equal to 2 for devices that support it. In order to be overlapped, any host memory involved in the transfers must be page- locked."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.5 Streams - Applications manage the concur...",
    "content": "# 6.2.8.5 Streams\nApplications manage the concurrent operations described above through streams. A stream is a sequence of commands (possibly issued by different host threads) that execute in order. Different streams, on the other hand, may execute their commands out of order with respect to one another or concurrently; this behavior is not guaranteed and should therefore not be relied upon for correctness (for example, inter- kernel communication is undefined). The commands issued on a stream may execute when all the dependencies of the command are met. The dependencies could be previously launched commands on same stream or dependencies from other streams. The successful completion of synchronize call guarantees that all the commands launched are completed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.5.1 Creation and Destruction - A stream is defined by creatin......Each of these streams is defin...",
    "content": "A stream is defined by creating a stream object and specifying it as the stream parameter to a sequence of kernel launches and host  $< - >$  device memory copies. The following code sample creates two streams and allocates an array hostPtr of float in page- locked memory.\n\ncudaStream_t stream[2]; for (int  $\\texttt{i} = \\texttt{0};\\texttt{i} < 2; + + \\texttt{i})$  cudaStreamCreate(&stream[i]); float\\* hostPtr; cudaMalloc(&hostPtr, 2 \\* size);\n\nEach of these streams is defined by the following code sample as a sequence of one memory copy from host to device, one kernel launch, and one memory copy from device to host:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.5.1 Creation and Destruction - for int  texttti  texttt0textt......continues on next page",
    "content": "for (int  $\\texttt{i} = \\texttt{0};\\texttt{i} < 2; + + \\texttt{i})$  cudaMempcyAsync(inputDevPtr  $^+$  i \\* size, hostPtr  $^+$  i \\* size, size, cudaMempcyHostToDevice, stream[i]); MyKernel  $\\leq \\leq 100$  512,0, stream[i]  $\\geq \\geq 2$  (outputDevPtr  $^+$  i \\* size, inputDevPtr  $^+$  i \\* size, size); cudaMempcyAsync(hostPtr  $^+$  i \\* size, outputDevPtr  $^+$  i \\* size,\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.5.1 Creation and Destruction - Each stream copies its portion......In case the device is still do...",
    "content": "Each stream copies its portion of input array hostPtr to array inputDevPtr in device memory, processes inputDevPtr on the device by calling MyKernel(), and copies the result outputDevPtr back to the same portion of hostPtr. Overlapping Behavior describes how the streams overlap in this example depending on the capability of the device. Note that hostPtr must point to page- locked host memory for any overlap to occur.\n\nStreams are released by calling cudaStreamDestroy()\n\nfor (int i = 0; i < 2; ++i) cudaStreamDestroy(stream[i]);\n\nIn case the device is still doing work in the stream when cudaStreamDestroy() is called, the function will return immediately and the resources associated with the stream will be released automatically once the device has completed all work in the stream."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.5.2 Default Stream - Kernel launches and host      ......For code that is compiled usin...",
    "content": "Kernel launches and host  $< - >$  device memory copies that do not specify any stream parameter, or equivalently that set the stream parameter to zero, are issued to the default stream. They are therefore executed in order.\n\nFor code that is compiled using the - - default- stream per- thread compilation flag (or that defines the CUDA_API_PER_THREAD_DEFAULT_STREAM macro before including CUDA headers (cuda.h and cuda_runtime.h)), the default stream is a regular stream and each host thread has its own default stream."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.5.2 Default Stream - For code that is compiled usin...",
    "content": "Note: #define CUDA_API_PER_THREAD_DEFAULT_STREAM 1 cannot be used to enable this behavior when the code is compiled by nvcc as nvcc implicitly includes cuda_runtime.h at the top of the translation unit. In this case the - - default- stream per- thread compilation flag needs to be used or the CUDA_API_PER_THREAD_DEFAULT_STREAM macro needs to be defined with the - DCUDA_API_PER_THREAD_DEFAULT_STREAM=1 compiler flag.\n\nFor code that is compiled using the - - default- stream legacy compilation flag, the default stream is a special stream called the NULL stream and each device has a single NULL stream used for all host threads. The NULL stream is special as it causes implicit synchronization as described in Implicit Synchronization."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.5.2 Default Stream - For code that is compiled with...",
    "content": "For code that is compiled without specifying a - - default- stream compilation flag, - - default- stream legacy is assumed as the default."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.5.3 Explicit Synchronization - There are various ways to expl......cudaStreamWaitEvent takes a st...",
    "content": "There are various ways to explicitly synchronize streams with each other.\n\ncudaDeviceSynchronize() waits until all preceding commands in all streams of all host threads have completed.\n\ncudaStreamSynchronize() takes a stream as a parameter and waits until all preceding commands in the given stream have completed. It can be used to synchronize the host with a specific stream, allowing other streams to continue executing on the device.\n\ncudaStreamWaitEvent() takes a stream and an event as parameters (see Events for a description of events) and makes all the commands added to the given stream after the call to cudaStreamWaitEvent() delay their execution until the given event has completed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.5.3 Explicit Synchronization - cudaStreamQuery provides appli...",
    "content": "cudaStreamQuery() provides applications with a way to know if all preceding commands in a stream have completed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.5.4 Implicit Synchronization - Two commands from different st......Operations that require a depe...",
    "content": "Two commands from different streams cannot run concurrently if any one of the following operations is issued in- between them by the host thread:\n\na page- locked host memory allocation, a device memory allocation, a device memory set, a memory copy between two addresses to the same device memory, any CUDA command to the NULL stream, a switch between the L1/shared memory configurations described in Compute Capability 7. x.\n\nOperations that require a dependency check include any other commands within the same stream as the launch being checked and any call to cudaStreamQuery() on that stream. Therefore, applications should follow these guidelines to improve their potential for concurrent kernel execution:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.5.4 Implicit Synchronization - All independent operations sho...",
    "content": "All independent operations should be issued before dependent operations, Synchronization of any kind should be delayed as long as possible."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.5.5 Overlapping Behavior - The amount of execution overla...",
    "content": "The amount of execution overlap between two streams depends on the order in which the commands are issued to each stream and whether or not the device supports overlap of data transfer and kernel execution (see Overlap of Data Transfer and Kernel Execution), concurrent kernel execution (see Concurrent Kernel Execution), and/or concurrent data transfers (see Concurrent Data Transfers)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.5.5 Overlapping Behavior - For example on devices that do...",
    "content": "For example, on devices that do not support concurrent data transfers, the two streams of the code sample of Creation and Destruction do not overlap at all because the memory copy from host to device is issued to stream[1] after the memory copy from device to host is issued to stream[0], so it can only start once the memory copy from device to host issued to stream[0] has completed. If the code is rewritten the following way (and assuming the device supports overlap of data transfer and kernel execution)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.5.5 Overlapping Behavior - for int  texttti  texttt0  i2 ......then the memory copy from host...",
    "content": "for (int  $\\texttt{i} = \\texttt{0}$  ;i<2;  $^{+ + 1}$  cudaMempcyAsync(inputDevPtr  $^+$  i \\* size, hostPtr  $^+$  i \\* size, size, cudaMempcyHostToDevice, stream[i]); for (int  $\\texttt{i} = \\texttt{0}$  ;i<2;  $^{+ + 1}$  MyKernel  $\\leq \\leq \\leq 100$  512,0, stream[i]>>> (outputDevPtr  $^+$  i \\* size, inputDevPtr  $^+$  i \\* size, size); for (int  $\\texttt{i} = \\texttt{0}$  ;i<2;  $^{+ + 1}$  cudaMempcyAsync(hostPtr  $^+$  i \\* size, outputDevPtr  $^+$  i \\* size, size, cudaMempcyDeviceToHost, stream[i]);\n\nthen the memory copy from host to device issued to stream[1] overlaps with the kernel launch issued to stream[0]."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.5.5 Overlapping Behavior - On devices that do support con...",
    "content": "On devices that do support concurrent data transfers, the two streams of the code sample of Creation and Destruction do overlap: The memory copy from host to device issued to stream[1] overlaps with the memory copy from device to host issued to stream[0] and even with the kernel launch issued to stream[0] (assuming the device supports overlap of data transfer and kernel execution)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.5.6 Host Functions (Callbacks) - The runtime provides a way to ......The following code sample adds...",
    "content": "The runtime provides a way to insert a CPU function call at any point into a stream via cudaLaunchHostFunc(). The provided function is executed on the host once all commands issued to the stream before the callback have completed.\n\nThe following code sample adds the host function MyCallback to each of two streams after issuing a host- to- device memory copy, a kernel launch and a device- to- host memory copy into each stream. The function will begin execution on the host after each of the device- to- host memory copies completes."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.5.6 Host Functions (Callbacks) - void CUDARTCB MyCallbackcudaSt......The commands that are issued i...",
    "content": "void CUDART_CB MyCallback(cudaStream_t stream, cudaError_t status, void \\*data){ printf(\"Inside callback %d\\n\", (size_t)data); } for (size_t  $\\texttt{i} = \\texttt{0}$  ;i<2;  $^{+ + 1}$  ){ cudaMempcyAsync(devPtrIn[i], hostPtr[i], size, cudaMempcyHostToDevice, stream[i]); MyKernel  $\\leq \\leq \\leq 100$  512,0, stream[i]>>>devPtrOut[i], devPtrIn[i], size); cudaMempcyAsync(hostPtr[i], devPtrOut[i], size, cudaMempcyDeviceToHost,  $\\rightarrow$  stream[i]); cudaLaunchHostFunc(stream[i], MyCallback, (void\\*)i); }\n\nThe commands that are issued in a stream after a host function do not start executing before the function has completed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.5.6 Host Functions (Callbacks) - A host function enqueued into ...",
    "content": "A host function enqueued into a stream must not make CUDA API calls (directly or indirectly), as it might end up waiting on itself if it makes such a call leading to a deadlock."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.5.7 Stream Priorities - The relative priorities of str......The following code sample obta...",
    "content": "The relative priorities of streams can be specified at creation using cudaStreamCreateWithPriority(). The range of allowable priorities, ordered as [ highest priority, lowest priority ] can be obtained using the cudaDeviceGetStreamPriorityRange() function. At runtime, pending work in higherpriority streams takes preference over pending work in low- priority streams.\n\nThe following code sample obtains the allowable range of priorities for the current device, and creates streams with the highest and lowest available priorities."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.5.7 Stream Priorities - get the range of stream priori...",
    "content": "// get the range of stream priorities for this device int priority_high, priority_low; cudaDeviceGetStreamPriorityRange(&priority_low, &priority_high); // create streams with highest and lowest available priorities cudaStream_t st_high, st_low; cudaStreamCreateWithPriority(&st_high, cudaStreamNonBlocking, priority_high); cudaStreamCreateWithPriority(&st_low, cudaStreamNonBlocking, priority_low);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.6 Programmatic Dependent Launch and Synchronization - The Programmatic Dependent Lau...",
    "content": "The Programmatic Dependent Launch mechanism allows for a dependent secondary kernel to launch before the primary kernel it depends on in the same CUDA stream has finished executing. Available starting with devices of compute capability 9.0, this technique can provide performance benefits when the secondary kernel can complete significant work that does not depend on the results of the primary kernel."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.6.1 Background - A CUDA application utilizes th......Fig 3 Figure 10 GPU activity t...",
    "content": "A CUDA application utilizes the GPU by launching and executing multiple kernels on it. A typical GPU activity timeline is shown in Figure 10.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/3a0500bbdc7d91eddbde5850ee4f5dc1fc2fd7a8c99c5c690ac2c1d516ad7936.jpg)  \nFig. 3: Figure 10: GPU activity timeline"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.6.1 Background - Here secondarykernel is launch...",
    "content": "Here, secondary_kernel is launched after primary_kernel finishes its execution. Serialized execution is usually necessary because secondary_kernel depends on result data produced by primary_kernel. If secondary_kernel has no dependency on primary_kernel, both of them can be launched concurrently by using CUDA streams. Even if secondary_kernel is dependent on primary_kernel, there is some potential for concurrent execution. For example, almost all the kernels have some sort of preamble section during which tasks such as zeroing buffers or loading constant values are performed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.6.1 Background - Figure 11 demonstrates the por......Fig 5 Figure 12 Concurrent exe...",
    "content": "Figure 11 demonstrates the portion of secondary_kernel that could be executed concurrently without impacting the application. Note that concurrent launch also allows us to hide the launch latency of secondary_kernel behind the execution of primary_kernel.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/3367dd40caa74d489399187886c6ecbe90b9785073c757698b7c421a939b321c.jpg)  \nFig. 4: Figure 11: Preamble section of secondary_kernel\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/d04ddef72ef313f12abdb961774dd7d982fe261903df3799d49e2f02e96a6dae.jpg)  \nFig. 5: Figure 12: Concurrent execution of primary_kernel and secondary_kernel"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.6.1 Background - The concurrent launch and exec......Programmatic Dependent Launch ...",
    "content": "The concurrent launch and execution of secondary_kernel shown in Figure 12 is achievable using Programmatic Dependent Launch.\n\nProgrammatic Dependent Launch introduces changes to the CUDA kernel launch APIs as explained in following section. These APIs require at least compute capability 9.0 to provide overlapping execution."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.6.2 API Description - In Programmatic Dependent Laun......cppglobal void primarykernel  ...",
    "content": "In Programmatic Dependent Launch, a primary and a secondary kernel are launched in the same CUDA stream. The primary kernel should execute cudaTriggerProgrammaticLaunchCompletion with all thread blocks when it's ready for the secondary kernel to launch. The secondary kernel must be launched using the extensible launch API as shown.\n\n```cpp__global__ void primary_kernel() {    // Initial work that should finish before starting secondary kernel    // Trigger the secondary kernel    cudaTriggerProgrammaticLaunchCompletion();    // Work that can coincide with the secondary kernel}__global__ void secondary_kernel() {    // Independent work    // Will block until all primary kernels the secondary kernel is dependent on have completed and flushed results to global memory}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.6.2 API Description - continues on next page...When the secondary kernel is l...",
    "content": "(continues on next page)\n\ncudaGridDependencySynchronize(); // Dependent work } cudaLaunchAttribute attribute[1]; attribute[0].id = cudaLaunchAttributeProgrammaticStreamSerialization; attribute[0].val.programmaticStreamSerializationAllowed = 1; configSecondary.attrs = attribute; configSecondary.numAttrs = 1; primary_kernel<<grid_dim, block_dim, 0, stream>>>(); cudaLaunchKernelEx(&configSecondary, secondary_kernel);\n\nWhen the secondary kernel is launched using the cudaLaunchAttributeProgrammaticStreamSe. rialization attribute, the CUDA driver is safe to launch the secondary kernel early and not wait on the completion and memory flush of the primary before launching the secondary."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.6.2 API Description - The CUDA driver can launch the......In either case the secondary t...",
    "content": "The CUDA driver can launch the secondary kernel when all primary thread blocks have launched and executed cudaTriggerProgrammaticLaunchCompletion. If the primary kernel doesn't execute the trigger, it implicitly occurs after all thread blocks in the primary kernel exit.\n\nIn either case, the secondary thread blocks might launch before data written by the primary kernel is visible. As such, when the secondary kernel is configured with Programmatic Dependent Launch, it must always use cudaGridDependencySynchronize or other means to verify that the result data from the primary is available."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.6.2 API Description - Please note that these methods...",
    "content": "Please note that these methods provide the opportunity for the primary and secondary kernels to execute concurrently, however this behavior is opportunistic and not guaranteed to lead to concurrent kernel execution. Reliance on concurrent execution in this manner is unsafe and can lead to deadlock."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7 CUDA Graphs - CUDA Graphs present a new mode...",
    "content": "CUDA Graphs present a new model for work submission in CUDA. A graph is a series of operations, such as kernel launches, connected by dependencies, which is defined separately from its execution. This allows a graph to be defined once and then launched repeatedly. Separating out the definition of a graph from its execution enables a number of optimizations: first, CPU launch costs are reduced compared to streams, because much of the setup is done in advance; second, presenting the whole workflow to CUDA enables optimizations which might not be possible with the piecewise work submission mechanism of streams."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7 CUDA Graphs - To see the optimizations possi......Work submission using graphs i...",
    "content": "To see the optimizations possible with graphs, consider what happens in a stream: when you place a kernel into a stream, the host driver performs a sequence of operations in preparation for the execution of the kernel on the GPU. These operations, necessary for setting up and launching the kernel, are an overhead cost which must be paid for each kernel that is issued. For a GPU kernel with a short execution time, this overhead cost can be a significant fraction of the overall end- to- end execution time.\n\nWork submission using graphs is separated into three distinct stages: definition, instantiation, and execution."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7 CUDA Graphs - During the definition phase a ......An executable graph may be lau...",
    "content": "During the definition phase, a program creates a description of the operations in the graph along with the dependencies between them. Instantiation takes a snapshot of the graph template, validates it, and performs much of the setup and initialization of work with the aim of minimizing what needs to be done at launch. The\n\nresulting instance is known as an executable graph.\n\nAn executable graph may be launched into a stream, similar to any other CUDA work. It may be launched any number of times without repeating the instantiation."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.1.1 Node Types - An operation forms a node in a......kernel CPU function call memor...",
    "content": "An operation forms a node in a graph. The dependencies between the operations are the edges. These dependencies constrain the execution sequence of the operations.\n\nAn operation may be scheduled at any time once the nodes on which it depends are complete. Scheduling is left up to the CUDA system.\n\n# 6.2.8.7.1.1 Node Types\nA graph node can be one of:\n\n- kernel- CPU function call- memory copy- memset- empty node- waiting on an event- recording an event- signalling an external semaphore- waiting on an external semaphore- child graph: To execute a separate nested graph, as shown in the following figure."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.1.1 Node Types - httpscdnmineruopenxlaborgcnres......Fig 6 Child Graph Example",
    "content": "![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/18371adbd35d3fcc2ff98b23ea39b5acf44ae49f487e2c26d3ea0fbe9f819366.jpg)  \nFig. 6: Child Graph Example"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.2 Creating a Graph Using Graph APIs - Graphs can be created via two ......Create the graph  it starts ou...",
    "content": "Graphs can be created via two mechanisms: explicit API and stream capture. The following is an example of creating and executing the below graph.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/9b62e63a2d1e1a42ba4646ffe2d4178e5b36cb7213d8bccde6309e9bdf079f34.jpg)  \nFig. 7: Creating a Graph Using Graph APIs Example\n\n// Create the graph - it starts out empty cudaGraphCreate(&graph, 0);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.2 Creating a Graph Using Graph APIs - For the purpose of this exampl......Now set up dependencies on eac...",
    "content": "// For the purpose of this example, we'll create // the nodes separately from the dependencies to // demonstrate that it can be done in two stages. // Note that dependencies can also be specified // at node creation. cudaGraphAddKernelNode(&a, graph, NULL, 0, &nodeParams); cudaGraphAddKernelNode(&b, graph, NULL, 0, &nodeParams); cudaGraphAddKernelNode(&c, graph, NULL, 0, &nodeParams); cudaGraphAddKernelNode(&d, graph, NULL, 0, &nodeParams);\n\n// Now set up dependencies on each node cudaGraphAddDependencies(graph, &a, &b, 1); // A- >BCudaGraphAddDependencies(graph, &a, &c, 1); // A- >CCudaGraphAddDependencies(graph, &b, &d, 1); // B- >DCudaGraphAddDependencies(graph, &c, &d, 1); // C- >D"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.3 Creating a Graph Using Stream Capture - Stream capture provides a mech......cudaGrapht graph cudaStreamBeg...",
    "content": "Stream capture provides a mechanism to create a graph from existing stream- based APIs. A section of code which launches work into streams, including existing code, can be bracketed with calls to cudaStreamBeginCapture() and cudaStreamEndCapture(). See below.\n\ncudaGraph_t graph; cudaStreamBeginCapture(stream); kernel_A<<< stream >>>(...); kernel_B<<< stream >>>(...); libraryCall(stream); kernel_C<<< stream >>>(...); cudaStreamEndCapture(stream, &graph);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.3 Creating a Graph Using Stream Capture - A call to cudaStreamBeginCaptu......Stream capture can be used on ...",
    "content": "A call to cudaStreamBeginCapture() places a stream in capture mode. When a stream is being captured, work launched into the stream is not enqueued for execution. It is instead appended to an internal graph that is progressively being built up. This graph is then returned by calling cudaStreamEndCapture(), which also ends capture mode for the stream. A graph which is actively being constructed by stream capture is referred to as a capture graph.\n\nStream capture can be used on any CUDA stream except cudaStreamLegacy (the \"NULL stream\"). Note that it can be used on cudaStreamPerThread. If a program is using the legacy stream, it may be possible to redefine stream O to be the per- thread stream with no functional change. See Default Stream."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.3 Creating a Graph Using Stream Capture - Whether a stream is being capt...",
    "content": "Whether a stream is being captured can be queried with cudaStreamIsCapturing()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.3.1 Cross-stream Dependencies and Events - Stream capture can handle cros......When a captured event is waite...",
    "content": "Stream capture can handle cross- stream dependencies expressed with cudaEventRecord() and cudaStreamWaitEvent(), provided the event being waited upon was recorded into the same capture graph.\n\nWhen an event is recorded in a stream that is in capture mode, it results in a capture event. A captured event represents a set of nodes in a capture graph.\n\nWhen a captured event is waited on by a stream, it places the stream in capture mode if it is not already, and the next item in the stream will have additional dependencies on the nodes in the captured event. The two streams are then being captured to the same capture graph."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.3.1 Cross-stream Dependencies and Events - When cross stream dependencies......continued from previous page",
    "content": "When cross- stream dependencies are present in stream capture, cudaStreamEndCapture() must still be called in the same stream where cudaStreamBeginCapture() was called; this is the origin stream. Any other streams which are being captured to the same capture graph, due to event- based dependencies, must also be joined back to the origin stream. This is illustrated below. All streams being captured to the same capture graph are taken out of capture mode upon cudaStreamEndCapture(). Failure to rejoin to the origin stream will result in failure of the overall capture operation.\n\n// stream1 is the origin stream cudaStreamBeginCapture(stream1); kernel_A<<< stream1 >>>(...); // Fork into stream2\n\n(continues on next page)\n\n(continued from previous page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.3.1 Cross-stream Dependencies and Events - cudaEventRecordevent1 stream1 ......Note When a stream is taken ou...",
    "content": "cudaEventRecord(event1, stream1); cudaStreamWaitEvent(stream2, event1); kernel_B<<< ... stream1 >>>(...); kernel_C<<< ... stream2 >>>(...); // Join stream2 back to origin stream (stream1) cudaEventRecord(event2, stream2); cudaStreamWaitEvent(stream1, event2); kernel_D<<< ... stream1 >>>(...); // End capture in the origin stream cudaStreamEndCapture(stream1, &graph); // stream1 and stream2 no longer in capture mode\n\nGraph returned by the above code is shown in Figure 13.\n\nNote: When a stream is taken out of capture mode, the next non- captured item in the stream (if any) will still have a dependency on the most recent prior non- captured item, despite intermediate items having been removed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.3.2 Prohibited and Unhandled Operations - It is invalid to synchronize o...",
    "content": "It is invalid to synchronize or query the execution status of a stream which is being captured or a captured event, because they do not represent items scheduled for execution. It is also invalid to query the execution status of or synchronize a broader handle which encompasses an active stream capture, such as a device or context handle when any associated stream is in capture mode."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.3.2 Prohibited and Unhandled Operations - When any stream in the same co......It is therefore also invalid t...",
    "content": "When any stream in the same context is being captured, and it was not created with cudaStream- NonBlocking, any attempted use of the legacy stream is invalid. This is because the legacy stream handle at all times encompasses these other streams; enqueueing to the legacy stream would create a dependency on the streams being captured, and querying it or synchronizing it would query or synchronize the streams being captured.\n\nIt is therefore also invalid to call synchronous APIs in this case. Synchronous APIs, such as cudaMemory(), enqueue work to the legacy stream and synchronize it before returning."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.3.2 Prohibited and Unhandled Operations - It is invalid to merge two sep...",
    "content": "Note: As a general rule, when a dependency relation would connect something that is captured with something that was not captured and instead enqueued for execution, CUDA prefers to return an error rather than ignore the dependency. An exception is made for placing a stream into or out of capture mode; this severs a dependency relation between items added to the stream immediately before and after the mode transition.\n\nIt is invalid to merge two separate capture graphs by waiting on a captured event from a stream which is being captured and is associated with a different capture graph than the event. It is invalid to wait on a non- captured event from a stream which is being captured without specifying the cudaEventWaitExternal flag."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.3.2 Prohibited and Unhandled Operations - A small number of APIs that en......aStreamAttachMemAsync",
    "content": "A small number of APIs that enqueue asynchronous operations into streams are not currently supported in graphs and will return an error if called with a stream which is being captured, such as cud\n\naStreamAttachMemAsync()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.3.3 Invalidation - When an invalid operation is a...",
    "content": "When an invalid operation is attempted during stream capture, any associated capture graphs are invalidated. When a capture graph is invalidated, further use of any streams which are being captured or captured events associated with the graph is invalid and will return an error, until stream capture is ended with cudaStreamEndCapture(). This call will take the associated streams out of capture mode, but will also return an error value and a NULL graph."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.4 Updating Instantiated Graphs - Work submission using graphs i......A graph is a snapshot of a wor...",
    "content": "Work submission using graphs is separated into three distinct stages: definition, instantiation, and execution. In situations where the workflow is not changing, the overhead of definition and instantiation can be amortized over many executions, and graphs provide a clear advantage over streams.\n\nA graph is a snapshot of a workflow, including kernels, parameters, and dependencies, in order to replay it as rapidly and efficiently as possible. In situations where the workflow changes the graph becomes out of date and must be modified. Major changes to graph structure such as topology or types of nodes will require re- instantiation of the source graph because various topology- related optimization techniques must be re- applied."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.4 Updating Instantiated Graphs - The cost of repeated instantia......Updates will take effect the n...",
    "content": "The cost of repeated instantiation can reduce the overall performance benefit from graph execution, but it is common for only node parameters, such as kernel parameters and cudaMembcpy addresses, to change while graph topology remains the same. For this case, CUDA provides a lightweight mechanism known as \"Graph Update,\" which allows certain node parameters to be modified in- place without having to rebuild the entire graph. This is much more efficient than re- instantiation.\n\nUpdates will take effect the next time the graph is launched, so they will not impact previous graph launches, even if they are running at the time of the update. A graph may be updated and relaunched repeatedly, so multiple updates/launches can be queued on a stream."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.4 Updating Instantiated Graphs - CUDA provides two mechanisms f...",
    "content": "CUDA provides two mechanisms for updating instantiated graph parameters, whole graph update and individual node update. Whole graph update allows the user to supply a topologically identical cudaGraph_t object whose nodes contain updated parameters. Individual node update allows the user to explicitly update the parameters of individual nodes. Using an updated cudaGraph_t is more convenient when a large number of nodes are being updated, or when the graph topology is unknown to the caller (i.e., The graph resulted from stream capture of a library call). Using individual node update is preferred when the number of changes is small and the user has the handles to the nodes requiring updates."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.4 Updating Instantiated Graphs - Individual node update skips t...",
    "content": " Individual node update skips the topology checks and comparisons for unchanged nodes, so it can be more efficient in many cases."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.4 Updating Instantiated Graphs - CUDA also provides a mechanism......The following sections explain...",
    "content": "CUDA also provides a mechanism for enabling and disabling individual nodes without affecting their current parameters.\n\nThe following sections explain each approach in more detail."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.4.1 Graph Update Limitations - Kernel nodes...Changing the number of semapho...",
    "content": "Kernel nodes:\n\nThe owning context of the function cannot change. A node whose function originally did not use CUDA dynamic parallelism cannot be updated to a function which uses CUDA dynamic parallelism.\n\ncudaMemset and cudaMempcy nodes:\n\nThe CUDA device(s) to which the operand(s) was allocated/mapped cannot change. The source/destination memory must be allocated from the same context as the original source/destination memory. Only 1D cudaMemset/cudaMempcy nodes can be changed.\n\nAdditional memcpy node restrictions:\n\nChanging either the source or destination memory type (i.e., cudaPitchedPtr, cudaArray_t, etc.), or the type of transfer (i.e., cudaMempcyKind) is not supported.\n\nExternal semaphore wait nodes and record nodes:\n\nChanging the number of semaphores is not supported."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.4.1 Graph Update Limitations - There are no restrictions on u...",
    "content": "There are no restrictions on updates to host nodes, event record nodes, or event wait nodes."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.4.2 Whole Graph Update - cudaGraphExecUpdate allows an ......More explicitly following the ...",
    "content": "cudaGraphExecUpdate() allows an instantiated graph (the \"original graph\") to be updated with the parameters from a topologically identical graph (the \"updating\" graph). The topology of the updating graph must be identical to the original graph used to instantiate the cudaGraphExec_t. In addition, the order in which the dependencies are specified must match. Finally, CUDA needs to consistently order the sink nodes (nodes with no dependencies). CUDA relies on the order of specific api calls to achieve consistent sink node ordering.\n\nMore explicitly, following the following rules will cause cudaGraphExecUpdate() to pair the nodes in the original graph and the updating graph deterministically:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.4.2 Whole Graph Update - 1 For any capturing stream the...",
    "content": "1. For any capturing stream, the API calls operating on that stream must be made in the same order, including event wait and other api calls not directly corresponding to node creation. 2. The API calls which directly manipulate a given graph node's incoming edges (including captured stream APIs, node add APIs, and edge addition / removal APIs) must be made in the same order. Moreover, when dependencies are specified in arrays to these APIs, the order in which the dependencies are specified inside those arrays must match. 3. Sink nodes must be consistently ordered. Sink nodes are nodes without dependent nodes / outgoing edges in the final graph at the time of the cudaGraphExecUpdate() invocation."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.4.2 Whole Graph Update - The following operations affec...",
    "content": " The following operations affect sink node ordering (if present) and must (as a combined set) be made in the same order:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.4.2 Whole Graph Update - Node add APIs resulting in a s......The following example shows ho...",
    "content": "Node add APIs resulting in a sink node. Edge removal resulting in a node becoming a sink node. cudaStreamUpdateCaptureDependencies(), if it removes a sink node from a capturing stream's dependency set. cudaStreamEndCapture().\n\nThe following example shows how the API could be used to update an instantiated graph:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.4.2 Whole Graph Update - The following example shows ho...",
    "content": "The following example shows how the API could be used to update an instantiated graph:```cudaGraphExec_t graphExec = NULL;for (int i = 0; i < 10; i++) {    cudaGraph_t graph;    cudaGraphExecUpdateResult updateResult;    cudaGraphNode_t errorNode;    // In this example we use stream capture to create the graph.    // You can also use the Graph API to produce a graph.    cudaStreamRegInCapture(stream, cudaStreamRegInGlobal);    // Call a user- defined, stream based workload, for example    do_cuda_work(stream);    cudaStreamRegCapture(stream, &graph);    // If we've already instantiated the graph, try to update it directly    // and avoid the instantiation overhead    if (graphExec !"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.4.2 Whole Graph Update - NULL          If the graph fai...",
    "content": "= NULL) {        // If the graph fails to update, errorNode will be set to the        // node causing the failure and updateResult will be set to a        // reason code.        cudaGraphExecUpdate(graphExec, graph, &errorNode, &updateResult);    }    // Instantiate during the first iteration or whenever the update    // fails for any reason    if (graphExec == NULL || updateResult != cudaGraphExecUpdateSuccess) {        // If a previous update failed, destroy the cudaGraphExec_t        // before re- instantiating it        if (graphExec != NULL) {            cudaGraphExecDestroy(graphExec);        }        // Instantiate graphExec from graph. The error node and        // error message parameters are unused here."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.4.2 Whole Graph Update - cudaGraphInstantiategraphExec ...",
    "content": "        cudaGraphInstantiate(&graphExec, graph, NULL, NULL, 0);    }    cudaGraphDestroy(graph);    cudaGraphLaunch(graphExec, stream);    cudaStreamSynchronize(stream);}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.4.2 Whole Graph Update - A typical workflow is to creat...",
    "content": "A typical workflow is to create the initial cudaGraph_t using either the stream capture or graph API. The cudaGraph_t is then instantiated and launched as normal. After the initial launch, a new cudaGraph_t is created using the same method as the initial graph and cudaGraphExecUpdate() is called. If the graph update is successful, indicated by the updateResult parameter in the above example, the updated cudaGraphExec_t is launched. If the update fails for any reason, the cudaGraphExecDestroy() and cudaGraphInstantiate() are called to destroy the original cudaGraphExec_t and instantiate a new one."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.4.2 Whole Graph Update - It is also possible to update ......Please see the Graph API for m...",
    "content": "It is also possible to update the cudaGraph_t nodes directly (i.e., Using cudaGraphKernelNodeSetParams()) and subsequently update the cudaGraphExec_t, however it is more efficient to use the explicit node update APIs covered in the next section.\n\nPlease see the Graph API for more information on usage and current limitations."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.4.3 Individual node update - Instantiated graph node parame......cudaGraphExecExternalSemaphore...",
    "content": "Instantiated graph node parameters can be updated directly. This eliminates the overhead of instantiation as well as the overhead of creating a new cudaGraph_t. If the number of nodes requiring update is small relative to the total number of nodes in the graph, it is better to update the nodes individually. The following methods are available for updating cudaGraphExec_t nodes:\n\n- cudaGraphExecKernelNodeSetParams()  \n- cudaGraphExecMemcopyNodeSetParams()  \n- cudaGraphExecMemsetNodeSetParams()  \n- cudaGraphExecHostNodeSetParams()  \n- cudaGraphExecChildGraphNodeSetParams()  \n- cudaGraphExecEventRecordNodeSetEvent()  \n- cudaGraphExecEventWaitNodeSetEvent()  \n- cudaGraphExecExternalSemaphoresSignalNodeSetParams()  \n- cudaGraphExecExternalSemaphoresWaitNodeSetParams()"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.4.3 Individual node update - Please see the Graph API for m...",
    "content": "Please see the Graph API for more information on usage and current limitations."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.4.4 Individual node enable - Kernel memset and memcpy nodes......The following methods are avai...",
    "content": "Kernel, memset and memcpy nodes in an instantiated graph can be enabled or disabled using the cudaGraphNodeSetEnabled() API. This allows the creation of a graph which contains a superset of the desired functionality which can be customized for each launch. The enable state of a node can be queried using the cudaGraphNodeGetEnabled() API.\n\nA disabled node is functionally equivalent to empty node until it is reenabled. Node parameters are not affected by enabling/disabling a node. Enable state is unaffected by individual node update or whole graph update with cudaGraphExecUpdate(). Parameter updates while the node is disabled will take effect when the node is reenabled.\n\nThe following methods are available for enabling/disabling cudaGraphExec_t nodes, as well as querying their status :"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.4.4 Individual node enable - Please see the Graph API for m...",
    "content": "- cudaGraphNodeSetEnabled()  \n- cudaGraphNodeGetEnabled()\n\nPlease see the Graph API for more information on usage and current limitations."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "See Graph API. - cudaGrapht objects are not thr......Graph execution is done in str...",
    "content": "# 6.2.8.7.5 Using Graph APIs\ncudaGraph_t objects are not thread- safe. It is the responsibility of the user to ensure that multiple threads do not concurrently access the same cudaGraph_t.\n\nA cudaGraphExec_t cannot run concurrently with itself. A launch of a cudaGraphExec_t will be ordered after previous launches of the same executable graph.\n\nGraph execution is done in streams for ordering with other asynchronous work. However, the stream is for ordering only; it does not constrain the internal parallelism of the graph, nor does it affect where graph nodes execute.\n\n# See Graph API.\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6 Device Graph Launch - There are many workflows which......Device graph launch provides a...",
    "content": "There are many workflows which need to make data- dependent decisions during runtime and execute different operations depending on those decisions. Rather than offloading this decision- making process to the host, which may require a round- trip from the device, users may prefer to perform it on the device. To that end, CUDA provides a mechanism to launch graphs from the device.\n\nDevice graph launch provides a convenient way to perform dynamic control flow from the device, be it something as simple as a loop or as complex as a device- side work scheduler. This functionality is only available on systems which support unified addressing."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6 Device Graph Launch - Graphs which can be launched f......Device graphs can be launched ...",
    "content": "Graphs which can be launched from the device will henceforth be referred to as device graphs, and graphs which cannot be launched from the device will be referred to as host graphs.\n\nDevice graphs can be launched from both the host and device, whereas host graphs can only be launched from the host. Unlike host launches, launching a device graph from the device while a previous launch of the graph is running will result in an error, returning cudaErrorInvalidValue; therefore, a device graph cannot be launched twice from the device at the same time. Launching a device graph from the host and device simultaneously will result in undefined behavior."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6.1 Device Graph Creation - 628761 Device Graph CreationIn...",
    "content": "# 6.2.8.7.6.1 Device Graph Creation\n6.2.8.7.6.1 Device Graph CreationIn order for a graph to be launched from the device, it must be instantiated explicitly for device launch. This is achieved by passing the cudaGraphInstantiateFlagDeviceLaunch flag to the cudaGraphInstantiate() call. As is the case for host graphs, device graph structure is fixed at time of instantiation and cannot be updated without re- instantiation, and instantiation can only be performed on the host. In order for a graph to be able to be instantiated for device launch, it must adhere to various requirements."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6.2 Device Graph Requirements - General requirements...Only copies involving device m...",
    "content": "# 6.2.8.7.6.2 Device Graph Requirements\nGeneral requirements:\n\nThe graph's nodes must all reside on a single device. The graph can only contain kernel nodes, memcpy nodes, memset nodes, and child graph nodes.\n\nKernel nodes:\n\nUse of CUDA Dynamic Parallelism by kernels in the graph is not permitted. Cooperative launches are permitted so long as MPS is not in use.\n\nMempcy nodes:\n\nOnly copies involving device memory and/or pinned device- mapped host memory are permitted. Copies involving CUDA arrays are not permitted. Both operands must be accessible from the current device at time of instantiation. Note that the copy operation will be performed from the device on which the graph resides, even if it is targeting memory on another device."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6.3 Device Graph Upload - In order to launch a graph on ......Examples of all three methods ...",
    "content": "In order to launch a graph on the device, it must first be uploaded to the device to populate the necessary device resources. This can be achieved in one of two ways.\n\nFirstly, the graph can be uploaded explicitly, either via cudaGraphUpload() or by requesting an upload as part of instantiation via cudaGraphInstantiateWithParams().\n\nAlternatively, the graph can first be launched from the host, which will perform this upload step im. plicitly as part of the launch.\n\nExamples of all three methods can be seen below:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6.3 Device Graph Upload - Explicit upload after instanti...",
    "content": "// Explicit upload after instantiation cudaGraphInstantiate(&deviceGraphExec1, deviceGraph1,  $\\hookrightarrow$  cudaGraphInstantiateFlagDeviceLaunch); cudaGraphUpload(deviceGraphExec1, stream); // Explicit upload as part of instantiation cudaGraphInstantiateParams instantiateParams  $=$  {0}; instantiateParams.flags  $=$  cudaGraphInstantiateFlagDeviceLaunch |  $\\hookrightarrow$  cudaGraphInstantiateFlagUpload; instantiateParams.uploadStream  $=$  stream; cudaGraphInstantiateWithParams(&deviceGraphExec2, deviceGraph2, &instantiateParams); // Implicit upload via host launch cudaGraphInstantiate(&deviceGraphExec3, deviceGraph3,  $\\hookrightarrow$  cudaGraphInstantiateFlagDeviceLaunch); cudaGraphLaunch(deviceGraphExec3, stream);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6.4 Device Graph Update - 628764 Device Graph UpdateDevi...",
    "content": "6.2.8.7.6.4 Device Graph UpdateDevice graphs can only be updated from the host, and must be re- uploaded to the device upon executable graph update in order for the changes to take effect. This can be achieved using the same methods outlined in the previous section. Unlike host graphs, launching a device graph from the device while an update is being applied will result in undefined behavior."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6.5 Device Launch - Device graphs can be launched ......Device side graph launch is pe...",
    "content": "# 6.2.8.7.6.5 Device Launch\nDevice graphs can be launched from both the host and the device via cudaGraphLaunch(), which has the same signature on the device as on the host. Device graphs are launched via the same handle on the host and the device. Device graphs must be launched from another graph when launched from the device.\n\nDevice- side graph launch is per- thread and multiple launches may occur from different threads at the same time, so the user will need to select a single thread from which to launch a given graph."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6.6 Device Launch Modes - Unlike host launch device grap......tabletrtdStreamtdtdLaunch Mode...",
    "content": "Unlike host launch, device graphs cannot be launched into regular CUDA streams, and can only be launched into distinct named streams, which each denote a specific launch mode:\n\nTable 2: Table 2. Device-only Graph Launch Streams  \n\n<table><tr><td>Stream</td><td>Launch Mode</td></tr><tr><td>cudaStreamGraphFireAndForget</td><td>Fire and forget launch</td></tr><tr><td>cudaStreamGraphTailLaunch</td><td>Tail launch</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6.7 Fire and Forget Launch - As the name suggests a fire an......The above diagram can be gener...",
    "content": "As the name suggests, a fire and forget launch is submitted to the GPU immediately, and it runs independently of the launching graph. In a fire- and- forget scenario, the launching graph is the parent, and the launched graph is the child.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/87db4655b8145860c92c7e8ac1eddbaf3d7394a2d1a4037cdfa68710912678d7.jpg)  \nFig. 8: Fire and forget launch\n\nThe above diagram can be generated by the sample code below:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6.7 Fire and Forget Launch - cppglobal void launchFireAndFo......Create and instantiate the lau...",
    "content": "```cpp__global__ void launchFireAndForgetGraph(cudaGraphExec_t graph) {    cudaGraphLaunch(graph, cudaStreamGraphFireAndForget);}void graphSetup() {    cudaGraphExec_t gExec1, gExec2;    cudaGraph_t g1, g2;    // Create, instantiate, and upload the device graph.    create_graph(&g2);    cudaGraphInstantiate(&gExec2, g2, cudaGraphInstantiateFlagDeviceLaunch);    (continues on next page)}```\n\n(continued from previous page)\n\ncudaGraphUpload(gExec2, stream);\n\n// Create and instantiate the launching graph. cudaStreamBeginCapture(stream, cudaStreamCaptureModeGlobal); launchFireAndForgetGraph  $\\epsilon < \\epsilon < 1$  1,0,stream  $\\geq \\geq$  gExec2); cudaStreamEndCapture(stream, &g1); cudaGraphInstantiate(&gExec1, g1);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6.7 Fire and Forget Launch - Launch the host graph which wi......A graph can have up to 120 tot...",
    "content": "// Launch the host graph, which will in turn launch the device graph. cudaGraphLaunch(gExec1, stream);\n\nA graph can have up to 120 total fire- and- forget graphs during the course of its execution. This total resets between launches of the same parent graph."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6.8 Graph Execution Environments - In order to fully understand t......The below diagram shows the en...",
    "content": "In order to fully understand the device- side synchronization model, it is first necessary to understand the concept of an execution environment.\n\nWhen a graph is launched from the device, it is launched into its own execution environment. The execution environment of a given graph encapsulates all work in the graph as well as all generated fire and forget work. The graph can be considered complete when it has completed execution and when all generated child work is complete.\n\nThe below diagram shows the environment encapsulation that would be generated by the fire- andforget sample code in the previous section."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6.8 Graph Execution Environments - When launched from the host a ......These environments are also hi...",
    "content": "When launched from the host, a device graph has an additional top level environment called the stream environment, which encapsulates all work generated as part of the overall launch. The stream launch is complete (i.e. downstream dependent work may now run) when the overall stream environment is marked as complete.\n\nThese environments are also hierarchical, so a graph environment can include multiple levels of subenvironments from fire and forget launches."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6.9 Tail Launch - Unlike on the host it is not p......The above execution flow can b...",
    "content": "Unlike on the host, it is not possible to synchronize with device graphs from the GPU via traditional methods such as cudaDeviceSynchronize() or cudaStreamSynchronize(). Rather, in order to enable serial work dependencies, a different launch mode - tail launch - is offered, to provide similar functionality.\n\nA tail launch executes when a graph's environment is considered complete - ie, when the graph and all its children are complete. When a graph completes, the environment of the next graph in the tail launch list will replace the completed environment as a child environment of the parent graph. Like fire- and- forget launches, a graph can have multiple graphs enqueued for tail launch.\n\nThe above execution flow can be generated by the code below:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6.9 Tail Launch - continues on next page...Fig 11 Nested fire and forget ...",
    "content": "- _global__ void launchTailGraph(cudaGraphExec_t graph) { cudaGraphLaunch(graph, cudaStreamGraphTailLaunch); }\n\n(continues on next page)\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/4dcbaa8b10aacaf94e6b5cce9bb446f783f35555dfd6521b13d259a1e89c70d6.jpg)  \nFig. 9: Fire and forget launch, with execution environments\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/bc0c2453d13b6b8bb5d6ca5c85da5eeaba6883c10d374c67c81a008722864666.jpg)  \nFig. 10: The stream environment, visualized\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/3f8520d133af00e61f9071fd05f5fc932792b947a68895e538b8380fabdc9724.jpg)  \nFig. 11: Nested fire and forget environments"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6.9 Tail Launch - httpscdnmineruopenxlaborgcnres......void graphSetup cudaGraphExect...",
    "content": "![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/844d8056812807a4830552f9b1de4e833479fd4063f6feeb360a916f3fa2eb8a.jpg)  \nFig. 12: A simple tail launch\n\nvoid graphSetup(){ cudaGraphExec_t gExec1, gExec2; cudaGraph_t g1, g2; // Create, instantiate, and upload the device graph. create_graph(gg2); cudaGraphInstantiate(&gExec2, g2, cudaGraphInstantiateFlagDeviceLaunch); cudaGraphUpload(gExec2, stream); // Create and instantiate the launching graph. cudaStreamBeginCapture(stream, cudaStreamCaptureModeGlobal); launchTailGraph  $< < < 1$  1,0,stream  $\\geq \\geq$  gExec2; cudaStreamEndCapture(stream, &g1); cudaGraphInstantiate(&gExec1, g1); // Launch the host graph, which will in turn launch the device graph. cudaGraphLaunch(gExec1, stream); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6.9 Tail Launch - Tail launches enqueued by a gi......Tail launches enqueued by a ta...",
    "content": "Tail launches enqueued by a given graph will execute one at a time, in order of when they were enqueued. So the first enqueued graph will run first, and then the second, and so on.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/4ec6143c34be794ab6e73062feca76c939a1cc4990f2b232682981f191dda0e4.jpg)  \nFig. 13: Tail launch ordering\n\nTail launches enqueued by a tail graph will execute before tail launches enqueued by previous graphs in the tail launch list. These new tail launches will execute in the order they are enqueued."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6.9 Tail Launch - httpscdnmineruopenxlaborgcnres......A graph can have up to 255 pen...",
    "content": "![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/74152a292f352495895d64ffcac7aee252a1e89ed4f661b1df1bf45310709acf.jpg)  \nFig. 14: Tail launch ordering when enqueued from multiple graphs\n\nA graph can have up to 255 pending tail launches."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6.10 Tail Self-launch - It is possible for a device gr......Below is sample code showing u...",
    "content": "It is possible for a device graph to enqueue itself for a tail launch, although a given graph can only have one self- launch enqueued at a time. In order to query the currently running device graph so that it can be relaunched, a new device- side function is added:\n\ncudaGraphExec_t cudaGetCurrentGraphExec();\n\nThis function returns the handle of the currently running graph if it is a device graph. If the currently executing kernel is not a node within a device graph, this function will return NULL.\n\nBelow is sample code showing usage of this function for a relaunch loop:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.7.6.10 Tail Self-launch - device int relaunchCount   0  ...",
    "content": "device__ int relaunchCount  $= 0$  . global__ void relaunchSelf() { int relaunchMax  $=$  100; if (threadIdx.  $\\times = = 0$  ){ if (relaunchCount  $\\ast$  relaunchMax){ cudaGraphLaunch(cudaGetCurrentGraphExec(), cudaStreamGraphTailLaunch); } relaunchCount++; } }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.8.1 Creation and Destruction - The runtime also provides a wa......cudaEventDestroystart cudaEven...",
    "content": "# 6.2.8.8 Events\nThe runtime also provides a way to closely monitor the device's progress, as well as perform accurate timing, by letting the application asynchronously record events at any point in the program, and query when these events are completed. An event has completed when all tasks - or optionally, all commands in a given stream - preceding the event have completed. Events in stream zero are completed after all preceding tasks and commands in all streams are completed.\n\n# 6.2.8.8.1 Creation and Destruction\nThe following code sample creates two events:\n\ncudaEvent_t start, stop; cudaEventCreate(&start); cudaEventCreate(&stop);\n\nThey are destroyed this way:\n\ncudaEventDestroy(start); cudaEventDestroy(stop);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.8.8.2 Elapsed Time - The events created in Creation......cudaEventRecordstart 0 for int...",
    "content": "# 6.2.8.8.2 Elapsed Time\nThe events created in Creation and Destruction can be used to time the code sample of Creation and Destruction the following way:\n\ncudaEventRecord(start, 0); for (int  $\\texttt{i} = \\texttt{0}$  ;i<2;  $^{+ + }\\dot{\\mathbf{1}}$  ){ cudaMempcyAsync(inputDev  $^+$  i \\* size, inputHost  $^+$  i \\* size, size, cudaMempcyHostToDevice, stream[i]); MyKernel  $\\mathbf{1}< < < 1\\Theta \\Theta$  512,0, stream[i]  $\\geq \\geq$  outputDev  $^+$  i \\* size, inputDev  $^+$  i \\* size, size); cudaMempcyAsync(outputHost  $^+$  i \\* size, outputDev  $^+$  i \\* size, size, cudaMempcyDeviceToHost, stream[i]); } cudaEventRecord(stop, 0); cudaEventSynchronize(stop); float elapsedTime; cudaEventElapsedTime(&elapsedTime, start, stop);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.9.1 Device Enumeration - When a synchronous function is......A host system can have multipl...",
    "content": "When a synchronous function is called, control is not returned to the host thread before the device has completed the requested task. Whether the host thread will then yield, block, or spin can be specified by calling cudaSetDeviceFlags() with some specific flags (see reference manual for details) before any other CUDA call is performed by the host thread.\n\n# 6.2.9. Multi-Device System\n\n# 6.2.9.1 Device Enumeration\nA host system can have multiple devices. The following code sample shows how to enumerate these devices, query their properties, and determine the number of CUDA- enabled devices."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.9.1 Device Enumeration - int deviceCount cudaGetDeviceC...",
    "content": "int deviceCount; cudaGetDeviceCount(&deviceCount); int device; for (device  $= 0$  ; device  $<$  deviceCount;  $^{+ + }$  device){ cudaDeviceProp deviceProp; cudaGetDeviceProperties(&deviceProp, device); printf(\"Device %d has compute capability %d.%d.\\n\", device, deviceProp.major, deviceProp.minor); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.9.2 Device Selection - A host thread can set the devi......The following code sample illu...",
    "content": "A host thread can set the device it operates on at any time by calling cudaSetDevice(). Device memory allocations and kernel launches are made on the currently set device; streams and events are created in association with the currently set device. If no call to cudaSetDevice() is made, the current device is device 0.\n\nThe following code sample illustrates how setting the current device affects memory allocation and kernel execution."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.9.2 Device Selection - sizet size    1024  sizeoffloa...",
    "content": "size_t size  $=$  1024 \\* sizeof(float); cudaSetDevice(6); // Set device 0 as current float\\* p0; cudaMalloc(&p0, size); // Allocate memory on device 0 MyKerne  $1< < 1000$  128>>>p0) // Launch kernel on device 0 cudaSetDevice(1); // Set device 1 as current float\\* p1; cudaMalloc(&p1, size); // Allocate memory on device 1 MyKerne  $1< < 1000$  128>>>p1) // Launch kernel on device 1"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.9.3 Stream and Event Behavior - A kernel launch will fail if i......cudaSetDevice6  Set device 0 a...",
    "content": "A kernel launch will fail if it is issued to a stream that is not associated to the current device as illustrated in the following code sample.\n\ncudaSetDevice(6); // Set device 0 as current cudaStream_t s0; cudaStreamCreate(&s0); // Create stream s0 on device 0 MyKerne  $1< < 100$  64,0s0>>>; // Launch kernel on device 0 in s0 cudaSetDevice(1); // Set device 1 as current cudaStream_t s1; cudaStreamCreate(&s1); // Create stream s1 on device 1 MyKerne  $1< < 100$  64,0s1>>>; // Launch kernel on device 1 in s1 // This kernel launch will fail: MyKerne  $1< < 100$  64,0s0>>>; // Launch kernel on device 1 in s0"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.9.3 Stream and Event Behavior - A memory copy will succeed eve...",
    "content": "A memory copy will succeed even if it is issued to a stream that is not associated to the current device. cudaEventReco rd() will fail if the input event and input stream are associated to different devices. cudaEventElapseTime() will fail if the two input events are associated to different devices. cudaEventSynchronize() and cudaEventQuery() will succeed even if the input event is associated to a device that is different from the current device. cudaStreamWaitEvent() will succeed even if the input stream and input event are associated to different devices. cudaStreamWaitEvent() can therefore be used to synchronize multiple devices with each other."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.9.3 Stream and Event Behavior - Each device has its own defaul...",
    "content": "Each device has its own default stream (see Default Stream), so commands issued to the default stream of a device may execute out of order or concurrently with respect to commands issued to the default stream of any other device."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.9.4 Peer-to-Peer Memory Access - Depending on the system proper......Peer to peer memory access is ...",
    "content": "Depending on the system properties, specifically the PCIe and/or NVLINK topology, devices are able to address each other's memory (i.e., a kernel executing on one device can dereference a pointer to the memory of the other device). This peer- to- peer memory access feature is supported between two devices if cudaDeviceCanAccessPeer () returns true for these two devices.\n\nPeer- to- peer memory access is only supported in 64- bit applications and must be enabled between two devices by calling cudaDeviceEnablePeerAccess () as illustrated in the following code sample. On non- NVSwitch enabled systems, each device can support a system- wide maximum of eight peer connections."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.9.4 Peer-to-Peer Memory Access - A unified address space is use......cudaSetDevice0  Set device 0 a...",
    "content": "A unified address space is used for both devices (see Unified Virtual Address Space), so the same pointer can be used to address memory from both devices as shown in the code sample below.\n\ncudaSetDevice(0); // Set device 0 as current float\\* p0; size_t size  $=$  1024 \\* sizeof(float); cudaMalloc(&p0, size); // Allocate memory on device 0 MyKernel  $\\epsilon < < 1000$  128>>>p0); // Launch kernel on device 0 cudaSetDevice(1); // Set device 1 as current cudaDeviceEnablePeerAccess(0, 0); // Enable peer- to- peer access // with device 0 // Launch kernel on device 1 // This kernel launch can access memory on device 0 at address p0 MyKernel  $\\epsilon < < 1000$  128>>>p0);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.9.4.1 IOMMU on Linux - On Linux only CUDA and the dis......See also Allocating DMA Buffer...",
    "content": "# 6.2.9.4.1 IOMMU on Linux\nOn Linux only, CUDA and the display driver does not support IOMMU- enabled bare- metal PCIe peer to peer memory copy. However, CUDA and the display driver does support IOMMU via VM pass through. As a consequence, users on Linux, when running on a native bare metal system, should disable the IOMMU. The IOMMU should be enabled and the VfIO driver be used as a PCIe pass through for virtual machines.\n\nOn Windows the above limitation does not exist.\n\nSee also Allocating DMA Buffers on 64- bit Platforms."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.9.5 Peer-to-Peer Memory Copy - Memory copies can be performed......continued from previous page",
    "content": "Memory copies can be performed between the memories of two different devices.\n\nWhen a unified address space is used for both devices (see Unified Virtual Address Space), this is done using the regular memory copy functions mentioned in Device Memory.\n\nOtherwise, this is done using cudaMempcyPeer(), cudaMempcyPeerAsync(), cudaMem. cpy3DPeer (), or cudaMempcy3DPeerAsync () as illustrated in the following code sample.\n\ncudaSetDevice(0); // Set device 0 as current float\\* p0; size_t size  $=$  1024 \\* sizeof(float); cudaMalloc(&p0, size); // Allocate memory on device 0 cudaSetDevice(1); // Set device 1 as current\n\n(continues on next page)\n\n(continued from previous page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.9.5 Peer-to-Peer Memory Copy - float p1 cudaMallocp1 size  Al......triangleright  does not start ...",
    "content": "float\\* p1; cudaMalloc(&p1, size); // Allocate memory on device 1 cudaSetDevice(0); // Set device 0 as current MyKerne1  $\\epsilon < < 1\\theta \\theta \\theta$  128  $\\geq \\geq$  p0); // Launch kernel on device 0 cudaSetDevice(1); // Set device 1 as current cudaMemcpyPeer(p1, 1, p0, 0, size); // Copy p0 to p1 MyKerne1  $\\epsilon < < 1\\theta \\theta \\theta$  128  $\\geq \\geq$  p1); // Launch kernel on device 1\n\nA copy (in the implicit NULL stream) between the memories of two different devices:\n\n$\\triangleright$  does not start until all commands previously issued to either device have completed and  $\\triangleright$  runs to completion before any commands (see Asynchronous Concurrent Execution) issued after the copy to either device can start."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.9.5 Peer-to-Peer Memory Copy - Consistent with the normal beh......Note that if peer to peer acce...",
    "content": "Consistent with the normal behavior of streams, an asynchronous copy between the memories of two devices may overlap with copies or kernels in another stream.\n\nNote that if peer- to- peer access is enabled between two devices via cudaDeviceEnablePeerAccess() as described in Peer- to- Peer Memory Access, peer- to- peer memory copy between these two devices no longer needs to be staged through the host and is therefore faster."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.10. Unified Virtual Address Space - When the application is run as...",
    "content": "When the application is run as a 64- bit process, a single address space is used for the host and all the devices of compute capability 2.0 and higher. All host memory allocations made via CUDA API calls and all device memory allocations on supported devices are within this virtual address range. As a consequence:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.10. Unified Virtual Address Space - The location of any memory on ...",
    "content": "The location of any memory on the host allocated through CUDA, or on any of the devices which use the unified address space, can be determined from the value of the pointer using cudaPointerGetAttributes(). When copying to or from the memory of any device which uses the unified address space, the cudaMemcpyKind parameter of cudaMemcpy\\*() can be set to cudaMemcpyDefault to determine locations from the pointers. This also works for host pointers not allocated through CUDA, as long as the current device uses unified addressing. Allocations via cudaHostAlloc() are automatically portable (see Portable Memory) across all the devices for which the unified address space is used, and pointers returned by cudaHostAlloc() can be used directly from within kernels running on these devices (i.e."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.10. Unified Virtual Address Space - there is no need to obtain a d...",
    "content": ", there is no need to obtain a device pointer via cudaHostGetDevicePointer() as described in Mapped Memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.10. Unified Virtual Address Space - Applications may query if the ...",
    "content": "Applications may query if the unified address space is used for a particular device by checking that the unifiedAddressing device property (see Device Enumeration) is equal to 1."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.11. Interprocess Communication - Any device memory pointer or e......To share device memory pointer...",
    "content": "Any device memory pointer or event handle created by a host thread can be directly referenced by any other thread within the same process. It is not valid outside this process however, and therefore cannot be directly referenced by threads belonging to a different process.\n\nTo share device memory pointers and events across processes, an application must use the Inter Process Communication API, which is described in detail in the reference manual. The IPC API is only supported for 64- bit processes on Linux and for devices of compute capability 2.0 and higher. Note that the IPC API is not supported for cudaMallocManaged allocations."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.11. Interprocess Communication - Using this API an application ...",
    "content": "Using this API, an application can get the IPC handle for a given device memory pointer using cudaIpcGetMemHandle(), pass it to another process using standard IPC mechanisms (for example, interprocess shared memory or files), and use cudaIpcOpenMemHandle() to retrieve a device pointer from the IPC handle that is a valid pointer within this other process. Event handles can be shared using similar entry points."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.11. Interprocess Communication - An example of using the IPC AP......Applications using CUDA IPC to...",
    "content": "Note that allocations made by cudaMalloc() may be sub- allocated from a larger block of memory for performance reasons. In such case, CUDA IPC APIs will share the entire underlying memory block which may cause other sub- allocations to be shared, which can potentially lead to information disclosure between processes. To prevent this behavior, it is recommended to only share allocations with a 2MiB aligned size.\n\nAn example of using the IPC API is where a single primary process generates a batch of input data, making the data available to multiple secondary processes without requiring regeneration or copying.\n\nApplications using CUDA IPC to communicate with each other should be compiled, linked, and run with the same CUDA driver and runtime."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.11. Interprocess Communication - Note Since CUDA 115 only event...",
    "content": "Note: Since CUDA 11.5, only events- sharing IPC APIs are supported on L4T and embedded Linux Tegra devices with compute capability 7. x and higher. The memory- sharing IPC APIs are still not supported on Tegra platforms."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.12. Error Checking - All runtime functions return a...",
    "content": "All runtime functions return an error code, but for an asynchronous function (see Asynchronous Concurrent Execution), this error code cannot possibly report any of the asynchronous errors that could occur on the device since the function returns before the device has completed the task; the error code only reports errors that occur on the host prior to executing the task, typically related to parameter validation; if an asynchronous error occurs, it will be reported by some subsequent unrelated runtime function call."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.12. Error Checking - The only way to check for asyn......The runtime maintains an error...",
    "content": "The only way to check for asynchronous errors just after some asynchronous function call is therefore to synchronize just after the call by calling cudaDeviceSynchronize() (or by using any other synchronization mechanisms described in Asynchronous Concurrent Execution) and checking the error code returned by cudaDeviceSynchronize().\n\nThe runtime maintains an error variable for each host thread that is initialized to cudaSuccess and is overwritten by the error code every time an error occurs (be it a parameter validation error or an asynchronous error). cudaPeekAtLastError() returns this variable. cudaGetLastError() returns this variable and resets it to cudaSuccess."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.12. Error Checking - Kernel launches do not return ...",
    "content": "Kernel launches do not return any error code, so cudaPeekAtLastErrorError() or cudaGetLastError() must be called just after the kernel launch to retrieve any pre- launch errors. To ensure that any error returned by cudaPeekAtLastErrorError() or cudaGetLastErrorError() does not originate from calls prior to the kernel launch, one has to make sure that the runtime error variable is set to cudaSuccess just before the kernel launch, for example, by calling cudaGetLastErrorError() just before the kernel launch. Kernel launches are asynchronous, so to check for asynchronous errors, the application must synchronize in- between the kernel launch and the call to cudaPeekAtLastErrorError() or cudaGetLastErrorError()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.12. Error Checking - Note that cudaErrorNotReady th...",
    "content": "Note that cudaErrorNotReady that may be returned by cudaStreamQuery() and cudaEventQuery() is not considered an error and is therefore not reported by cudaPeekAtLastErrorError() or cudaGetLastErrorError()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.13. Call Stack - On devices of compute capabili......When the call stack overflows ...",
    "content": "# 6.2.13. Call Stack\nOn devices of compute capability 2. x and higher, the size of the call stack can be queried using cudaDeviceGetLimit() and set using cudaDeviceSetLimit().\n\nWhen the call stack overflows, the kernel call fails with a stack overflow error if the application is run via a CUDA debugger (CUDA- GDB, Nsight) or an unspecified launch error, otherwise. When the compiler cannot determine the stack size, it issues a warning saying Stack size cannot be statically determined. This is usually the case with recursive functions. Once this warning is issued, user will need to set stack size manually if default stack size is not sufficient."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14. Texture and Surface Memory - CUDA supports a subset of the ...",
    "content": "CUDA supports a subset of the texturing hardware that the GPU uses for graphics to access texture and surface memory. Reading data from texture or surface memory instead of global memory can have several performance benefits as described in Device Memory Accesses."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1 Texture Memory - Texture memory is read from ke......The texture object specifies",
    "content": "Texture memory is read from kernels using the device functions described in Texture Functions. The process of reading a texture calling one of these functions is called a texture fetch. Each texture fetch specifies a parameter called a texture object for the texture object API.\n\nThe texture object specifies:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1 Texture Memory - The texture which is the piece...",
    "content": "- The texture, which is the piece of texture memory that is fetched. Texture objects are created at runtime and the texture is specified when creating the texture object as described in Texture Object API.- Its dimensionality that specifies whether the texture is addressed as a one dimensional array using one texture coordinate, a two-dimensional array using two texture coordinates, or a three-dimensional array using three texture coordinates. Elements of the array are called texels, short for texture elements. The texture width, height, and depth refer to the size of the array in each dimension. Table 15 lists the maximum texture width, height, and depth depending on the compute capability of the device."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1 Texture Memory - The type of a texel which is r...",
    "content": "- The type of a texel, which is restricted to the basic integer and single-precision floating-point types and any of the 1-, 2-, and 4-component vector types defined in Built-in Vector Types that are derived from the basic integer and single-precision floating-point types."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1 Texture Memory - The read mode which is equal t...",
    "content": "The read mode, which is equal to cudaReadModeNormalizedFloat or cudaReadModeElement- Type. If it is cudaReadModeNormalizedFloat and the type of the texel is a 16- bit or 8- bit integer type, the value returned by the texture fetch is actually returned as floating- point type and the full range of the integer type is mapped to [0.0, 1.0] for unsigned integer type and [- 1.0, 1.0] for signed integer type; for example, an unsigned 8- bit texture element with the value 0xff reads as 1. If it is cudaReadModeElementType, no conversion is performed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1 Texture Memory - Whether texture coordinates ar...",
    "content": "Whether texture coordinates are normalized or not. By default, textures are referenced (by the functions of Texture Functions) using floating- point coordinates in the range [0, N- 1] where N is the size of the texture in the dimension corresponding to the coordinate. For example, a texture that is  $64 \\times 32$  in size will be referenced with coordinates in the range [0, 63] and [0, 31] for the x and y dimensions, respectively. Normalized texture coordinates cause the coordinates to be specified in the range [0.0, 1.0- 1/N] instead of [0, N- 1], so the same  $64 \\times 32$  texture would be addressed by normalized coordinates in the range [0, 1- 1/N] in both the x and y dimensions."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1 Texture Memory - Normalized texture coordinates...",
    "content": " Normalized texture coordinates are a natural fit to some applications' requirements, if it is preferable for the texture coordinates to be independent of the texture size."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1 Texture Memory - The addressing mode It is vali...",
    "content": "The addressing mode. It is valid to call the device functions of Section B.8 with coordinates that are out of range. The addressing mode defines what happens in that case. The default addressing mode is to clamp the coordinates to the valid range: [0, N) for non- normalized coordinates and [0.0, 1.0) for normalized coordinates. If the border mode is specified instead, texture fetches with out- of- range texture coordinates return zero. For normalized coordinates, the wrap mode and the mirror mode are also available. When using the wrap mode, each coordinate x is converted to frac  $(x) = x$  - floor  $(x)$  where floor  $(x)$  is the largest integer not greater than x."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1 Texture Memory - When using the mirror mode eac...",
    "content": " When using the mirror mode, each coordinate  $x$  is converted to frac  $(x)$  if floor  $(x)$  is even and 1- frac  $(x)$  if floor  $(x)$  is odd. The addressing mode is specified as an array of size three whose first, second, and third elements specify the addressing mode for the first, second, and third texture coordinates, respectively; the addressing mode are cudaAddressModeBorder, cudaAddressModeClamp, cudaAddressModeWrap, and cudaAddressModeMirror; cudaAddressModeWrap and cudaAddressModeMirror are only supported for normalized texture coordinates"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1 Texture Memory - The filtering mode which speci...",
    "content": "The filtering mode which specifies how the value returned when fetching the texture is computed based on the input texture coordinates. Linear texture filtering may be done only for textures that are configured to return floating- point data. It performs low- precision interpolation between neighboring texels. When enabled, the texels surrounding a texture fetch location are read and the return value of the texture fetch is interpolated based on where the texture coordinates fell between the texels. Simple linear interpolation is performed for one- dimensional textures, bilinear interpolation for two- dimensional textures, and trilinear interpolation for three- dimensional textures. Texture Fetching gives more details on texture fetching."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1 Texture Memory - The filtering mode is equal to...",
    "content": " The filtering mode is equal to cudaFilterModePoint or cudaFilterModeLinear. If it is cudaFilterModePoint, the returned value is the texel whose texture coordinates are the closest to the input texture coordinates. If it is cudaFilterModeLinear, the returned value is the linear interpolation of the two (for a one- dimensional texture), four (for a two dimensional texture), or eight (for a three dimensional texture) texels whose texture coordinates are the closest to the input texture coordinates. cudaFilterModeLinear is only valid for returned values of floating- point type."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1 Texture Memory - Texture Object API introduces ......Texture Gather describes a spe...",
    "content": "Texture Object API introduces the texture object API.\n\n16- Bit Floating- Point Textures explains how to deal with 16- bit floating- point textures.\n\nTextures can also be layered as described in Layered Textures.\n\nCubemap Textures and Cubemap Layered Textures describe a special type of texture, the cubemap texture.\n\nTexture Gather describes a special texture fetch, texture gather."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1.1 Texture Object API - A texture object is created us...",
    "content": "A texture object is created using cudaCreateTextureObject() from a resource description of type struct cudaResourceDesc, which specifies the texture, and from a texture description defined as such:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "struct cudaTextureDesc - enum cudaTextureAddressMode ad......The following code sample appl...",
    "content": "{\n\nenum cudaTextureAddressMode addressMode[3]; enum cudaTextureFilterMode filterMode; enum cudaTextureReadMode readMode; int sRGB; int normalizedCoords; unsigned int maxAnisotropy; enum cudaTextureFilterMode mipmapFilterMode; float mipmapLevelBias; float minMipmapLevelClamp; float maxMipmapLevelClamp; };\n\naddressMode specifies the addressing mode; filterMode specifies the filter mode; readMode specifies the read mode; normalizedCoords specifies whether texture coordinates are normalized or not; See reference manual for sRGB, maxAnisotropy, mipmapFilterMode, mipmapLevelBias, minMipmapLevelClamp, and maxMipmapLevelClamp.\n\nThe following code sample applies some simple transformation kernel to a texture."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "struct cudaTextureDesc - Simple transformation kernel g...",
    "content": "// Simple transformation kernel global__ void transformKernel(float\\* output, cudaTextureObject_t texObj, int width, int height, float theta) { // Calculate normalized texture coordinates unsigned int  $\\texttt{x} =$  blockIdx.x \\* blockDim.x  $^+$  threadIdx.x; unsigned int  $\\texttt{y} =$  blockIdx.y \\* blockDim.y  $^+$  threadIdx.y; float  $\\texttt{u} = \\texttt{x}$  / (float)width; float  $\\texttt{v} = \\texttt{y}$  / (float)height; // Transform coordinates  $\\texttt{u} = = \\texttt{0.5f}$  .  $\\texttt{v} = = \\texttt{0.5f}$  . float tu  $=$  u \\* cosf(theta) - v \\* sinf(theta)  $^+$  0.5f; float tv  $=$  v \\* cosf(theta)  $^+$  u \\* sinf(theta)  $^+$  0.5f; // Read from texture and write to global memory output[y \\* width  $^+$  x]  $=$  tex2D<float>(texObj, tu, tv); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "struct cudaTextureDesc - Host code int main...Allocate CUDA array in device ...",
    "content": "// Host code int main() {\n\nconst int height = 1024; const int width = 1024; float angle = 0.5;\n\n// Allocate and set some host data float \\*h_data  $=$  (float \\*)std::malloc(sizeof(float) \\* width \\* height); for (int  $\\texttt{i} = \\texttt{0}$  ;i < height \\* width;  $^{+ + }\\dot{\\mathbf{1}}$  h_data[i]  $\\qquad = \\dot{\\mathbf{1}}$  .\n\n// Allocate CUDA array in device memory cudaChannelFormatDesc channelDesc  $=$  cudaCreateChannelDesc(32, 0, 0, 0, cudaChannelFormatKindFloat); cudaArray_t cuArray; cudaMalloc(&cuArray, &channelDesc, width, height);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "struct cudaTextureDesc - Set pitch of the source the wi......Specify texture struct cudaRes...",
    "content": "// Set pitch of the source (the width in memory in bytes of the 2D array pointed // to by src, including padding), we dont have any padding const size_t spitch  $=$  width \\* sizeof(float); // Copy data located at address h_data in host memory to device memory cudaMempcy2DToArray(cuArray, 0, 0, h_data, spitch, width \\* sizeof(float), height, cudaMempcyHostToDevice);\n\n// Specify texture struct cudaResourceDesc resDesc; memset(&resDesc, 0, sizeof(resDesc)); resDesc.resType  $=$  cudaResourceTypeArray; resDesc.res.array.array  $=$  cuArray;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "struct cudaTextureDesc - Specify texture object paramet......Allocate result of transformat...",
    "content": "// Specify texture object parameters struct cudaTextureDesc texDesc; memset(&texDesc, 0, sizeof(texDesc)); texDesc addressMode[0]  $=$  cudaAddressModeWrap; texDesc.addressMode[1]  $=$  cudaAddressModeWrap; texDesc.filterMode  $=$  cudaFilterModeLinear; texDesc.readMode  $=$  cudaReadModeElementType; texDescnormalizedCoords  $= 1$  .\n\n// Create texture object cudaTextureObject_t texObj  $= 0$  cudaCreateTextureObject(&texObj, &resDesc, &texDesc, NULL);\n\n// Allocate result of transformation in device memory float \\*output; cudaMalloc(&output, width \\* height \\* sizeof(float));"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "struct cudaTextureDesc - Invoke kernel dim3 threadsperr......cudaDestroyTextureObjecttexObj...",
    "content": "// Invoke kernel dim3 threadsperrBlock(16, 16); dim3 numBlocks((width  $^+$  threadsperrBlock.x - 1) / threadsperrBlock.x, (height  $^+$  threadsperrBlock.y - 1) / threadsperrBlock.y); transformKernel  $\\epsilon_{< <}$  numBlocks, threadsperrBlock  $\\geq \\geq$  (output, texObj, width, height, angle);\n\n// Copy data from device back to host cudaMempcy(h_data, output, width \\* height \\* sizeof(float), cudaMempcyDeviceToHost);\n\n// Destroy texture object\n\n(continued from previous page)\n\ncudaDestroyTextureObject(texObj); // Free device memory cudaFreeArray(cuArray); cudaFree(output); // Free host memory free(h_data); return 0;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1.2 16-Bit Floating-Point Textures - The 16 bit floating point or h......A channel description for the ...",
    "content": "# 6.2.14.1.2 16-Bit Floating-Point Textures\nThe 16- bit floating- point or half format supported by CUDA arrays is the same as the IEEE 754- 2008 binary2 format.\n\nCUDA  $\\mathtt{C + + }$  does not support a matching data type, but provides intrinsic functions to convert to and from the 32- bit floating- point format via the unsigned short type: __float2hal1f_rn(float) and __half2float(unsigned short). These functions are only supported in device code. Equivalent functions for the host code can be found in the OpenEXR library, for example.\n\n16- bit floating- point components are promoted to 32 bit float during texture fetching before any filtering is performed.\n\nA channel description for the 16- bit floating- point format can be created by calling one of the cudacCreateChannelDescHal1F\\*(') functions."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1.3 Layered Textures - A one dimensional or two dimen......A one dimensional layered text...",
    "content": "A one- dimensional or two- dimensional layered texture (also known as texture array in Direct3D and array texture in OpenGL) is a texture made up of a sequence of layers, all of which are regular textures of same dimensionality, size, and data type.\n\nA one- dimensional layered texture is addressed using an integer index and a floating- point texture coordinate; the index denotes a layer within the sequence and the coordinate addresses a texel within that layer. A two- dimensional layered texture is addressed using an integer index and two floatingpoint texture coordinates; the index denotes a layer within the sequence and the coordinates address a texel within that layer."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1.3 Layered Textures - A layered texture can only be ......Layered textures are only supp...",
    "content": "A layered texture can only be a CUDA array by calling cudaMalloc3DArray() with the cudaArrayLayered flag (and a height of zero for one- dimensional layered texture).\n\nLayered textures are fetched using the device functions described in tex1DLayered() and tex2DLayered(). Texture filtering (see Texture Fetching) is done only within a layer, not across layers.\n\nLayered textures are only supported on devices of compute capability 2.0 and higher."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1.4 Cubemap Textures - A cubemap texture is a special......Table 3Table 2Cubemap Fetch",
    "content": "A cubemap texture is a special type of two- dimensional layered texture that has six layers representing the faces of a cube:\n\nThe width of a layer is equal to its height. The cubemap is addressed using three texture coordinates  $x,y,$  and  $z$  that are interpreted as a direction vector emanating from the center of the cube and pointing to one face of the cube and a texel within the layer corresponding to that face. More specifically, the face is selected by the coordinate with largest magnitude m and the corresponding layer is addressed using coordinates  $(s / m + 1) / 2$  and  $(t / m + 1) / 2$  where s and t are defined in Table 2.\n\nTable 3:Table 2.Cubemap Fetch"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1.4 Cubemap Textures - tabletrtd colspan3tdtdfacetdtd...",
    "content": "<table><tr><td colspan=\"3\"></td><td>face</td><td>m</td><td>s</td><td>t</td></tr><tr><td rowspan=\"2\" colspan=\"2\">|x| &amp;gt; |y| and |x| &amp;gt; |z|</td><td>x &amp;gt; 0</td><td>0</td><td>x</td><td>-z</td><td>-y</td></tr><tr><td>x &amp;lt; 0</td><td>1</td><td>-x</td><td>z</td><td>-y</td></tr><tr><td rowspan=\"2\" colspan=\"2\">|y| &amp;gt; |x| and |y| &amp;gt; |z|</td><td>y &amp;gt; 0</td><td>2</td><td>y</td><td>x</td><td>z</td></tr><tr><td>y &amp;lt; 0</td><td>3</td><td>-y</td><td>x</td><td>-z</td></tr><tr><td rowspan=\"2\" colspan=\"2\">|z| &amp;gt; |x| and |z| &amp;gt; |y|</td><td>z &amp;gt; 0</td><td>4</td><td>z</td><td>x</td><td>-y</td></tr><tr><td>z &amp;lt; 0</td><td>5</td><td>-z</td><td>-x</td><td>-y</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1.4 Cubemap Textures - A cubemap texture can only be ......Cubemap textures are only supp...",
    "content": "A cubemap texture can only be a CUDA array by calling cudaMalloc3DArray() with the cudaArrayCubemap flag.\n\nCubemap textures are fetched using the device function described in texCubemap().\n\nCubemap textures are only supported on devices of compute capability 2.0 and higher."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1.5 Cubemap Layered Textures - A cubemap layered texture is a......Cubemap layered textures are o...",
    "content": "# 6.2.14.1.5 Cubemap Layered Textures\nA cubemap layered texture is a layered texture whose layers are cubemaps of same dimension.\n\nA cubemap layered texture is addressed using an integer index and three floating- point texture coordinates; the index denotes a cubemap within the sequence and the coordinates address a texel within that cubemap.\n\nA cubemap layered texture can only be a CUDA array by calling cudaMalloc3DArray() with the cudaArrayLayered and cudaArrayCubemap flags.\n\nCubemap layered textures are fetched using the device function described in texCubemapLayered(). Texture filtering (see Texture Fetching) is done only within a layer, not across layers.\n\nCubemap layered textures are only supported on devices of compute capability 2.0 and higher."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1.6 Texture Gather - Texture gather is a special te...",
    "content": "Texture gather is a special texture fetch that is available for two- dimensional textures only. It is performed by the tex2Dgather () function, which has the same parameters as tex2D(), plus an additional comp parameter equal to 0, 1, 2, or 3 (see tex2Dgather(). It returns four 32- bit numbers that correspond to the value of the component comp of each of the four texels that would have been used for bilinear filtering during a regular texture fetch. For example, if these texels are of values (253, 20, 31, 255), (250, 25, 29, 254), (249, 16, 37, 253), (251, 22, 30, 250), and comp is 2, tex2Dgather () returns (31, 29, 37, 30)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1.6 Texture Gather - Note that texture coordinates ...",
    "content": "Note that texture coordinates are computed with only 8 bits of fractional precision. tex2Dgather () may therefore return unexpected results for cases where tex2D () would use 1.0 for one of its weights ( or , see Linear Filtering). For example, with an x texture coordinate of 2.49805:  $xB = x - 0.5 = 1.99805$  however the fractional part of  $xB$  is stored in an 8- bit fixed- point format. Since 0.99805 is closer to 256. f/256. f than it is to 255. f/256. f,  $xB$  has the value 2. A tex2Dgather () in this case would therefore return indices 2 and 3 in  $X_{i}$  instead of indices 1 and 2."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.1.6 Texture Gather - Texture gather is only support...",
    "content": "Texture gather is only supported for CUDA arrays created with the cudaArrayTextureGather flag and of width and height less than the maximum specified in Table 15 for texture gather, which is smaller than for regular texture fetch.\n\nTexture gather is only supported on devices of compute capability 2.0 and higher."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.2 Surface Memory - For devices of compute capabil......Table 15 lists the maximum sur...",
    "content": "For devices of compute capability 2.0 and higher, a CUDA array (described in Cubemap Surfaces), created with the cudaArraySurfaceLoadStore flag, can be read and written via a surface object using the functions described in Surface Functions.\n\nTable 15 lists the maximum surface width, height, and depth depending on the compute capability of the device."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.2.1 Surface Object API - A surface object is created us...",
    "content": "A surface object is created using cudaCreateSurfaceObject () from a resource description of type struct  cudaResourceDesc. Unlike texture memory, surface memory uses byte addressing. This means that the x- coordinate used to access a texture element via texture functions needs to be multiplied by the byte size of the element to access the same element via a surface function. For example, the element at texture coordinate x of a one- dimensional floating- point CUDA array bound to a texture object texObj and a surface object surf0bj is read using tex1d(tex0bj, x) via tex0bj, but surf1Dread(surf0bj, 4\\*x) via surf0bj."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.2.1 Surface Object API - Similarly the element at textu...",
    "content": " Similarly, the element at texture coordinate x and y of a two- dimensional floating- point CUDA array bound to a texture object tex0bj and a surface object surf0bj is accessed using tex2d(tex0bj, x, y) via tex0bj, but surf2Dread(surf0bj, 4\\*x, y) via surf0bj (the byte offset of the y- coordinate is internally calculated from the underlying line pitch of the CUDA array)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.2.1 Surface Object API - The following code sample appl......continued from previous page",
    "content": "The following code sample applies some simple transformation kernel to a surface.\n\n// Simple copy kernel - global__ void copyKernel(cudaSurfaceObject_t inputSurfObj, cudaSurfaceObject_t outputSurfObj, int width, int height) { // Calculate surface coordinates (continues on next page)\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/af232278562e4ac19bf8d59e12c48fcae5a344c60b361c95e7f5b41d06b1cdf8.jpg)\n\n(continued from previous page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.2.1 Surface Object API - dim3 numBlockswidth    threads...",
    "content": "dim3 numBlocks((width  $^+$  threadsperrBlock.x - 1) / threadsperrBlock.x, (height  $^+$  threadsperrBlock.y - 1) / threadsperrBlock.y); copyKernel  $\\epsilon < <$  numBlocks, threadsperrBlock  $\\geq \\geq$  (inputSurfObj, outputSurfObj, width, height); // Copy data from device back to host cudaMecopy2DFromArray(h_data, spitch, cuOutputArray, 0, 0, 4 \\* width \\* sizeof(unsigned char), height, cudaMecopyDeviceToHost); // Destroy surface objects cudaDestroySurfaceObject(inputSurfObj); cudaDestroySurfaceObject(outputSurfObj); // Free device memory cudaFreeArray(cuInputArray); cudaFreeArray(cuOutputArray); // Free host memory free(h_data); return 0; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.2.2 Cubemap Surfaces - 621422 Cubemap SurfacesCubemap...",
    "content": "6.2.14.2.2 Cubemap SurfacesCubemap surfaces are accessed using surfCubemapread() and surfCubemapwrite() (surfCubemapread and surfCubemapwrite) as a two- dimensional layered surface, i.e., using an integer index denoting a face and two floating- point texture coordinates addressing a texel within the layer corresponding to this face. Faces are ordered as indicated in Table 2."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.2.3 Cubemap Layered Surfaces - 621423 Cubemap Layered Surface...",
    "content": "# 6.2.14.2.3 Cubemap Layered Surfaces\n6.2.14.2.3 Cubemap Layered SurfacesCubemap layered surfaces are accessed using surfCubemapLayeredread() and surfCubemapLayeredwrite() (surfCubemapLayeredread() and surfCubemapLayeredwrite()) as a two- dimensional layered surface, i.e., using an integer index denoting a face of one of the cubemaps and two floating- point texture coordinates addressing a texel within the layer corresponding to this face. Faces are ordered as indicated in Tables 2, so index ((2 * 6) + 3), for example, accesses the fourth face of the third cubemap."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.3 CUDA Arrays - 62143 CUDA ArraysCUDA arrays a...",
    "content": "6.2.14.3 CUDA ArraysCUDA arrays are opaque memory layouts optimized for texture fetching. They are one dimensional, two dimensional, or three- dimensional and composed of elements, each of which has 1, 2 or 4 components that may be signed or unsigned 8- , 16- , or 32- bit integers, 16- bit floats, or 32- bit floats. CUDA arrays are only accessible by kernels through texture fetching as described in Texture Memory or surface reading and writing as described in Surface Memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.14.4 Read/Write Coherency - 62144 ReadWrite CoherencyThe t...",
    "content": "# 6.2.14.4 Read/Write Coherency\n6.2.14.4 Read/Write CoherencyThe texture and surface memory is cached (see Device Memory Accesses) and within the same kernel call, the cache is not kept coherent with respect to global memory writes and surface memory writes, so any texture fetch or surface read to an address that has been written to via a global write or a surface write in the same kernel call returns undefined data. In other words, a thread can safely read some texture or surface memory location only if this memory location has been updated by a previous kernel call or memory copy, but not if it has been previously updated by the same thread or another thread from the same kernel call."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15. Graphics Interoperability - Some resources from OpenGL and......A resource must be registered ...",
    "content": "Some resources from OpenGL and Direct3D may be mapped into the address space of CUDA, either to enable CUDA to read data written by OpenGL or Direct3D, or to enable CUDA to write data for consumption by OpenGL or Direct3D.\n\nA resource must be registered to CUDA before it can be mapped using the functions mentioned in OpenGL Interoperability and Direct3D Interoperability. These functions return a pointer to a CUDA graphics resource of type struct cudaGraphicsResource. Registering a resource is potentially high- overhead and therefore typically called only once per resource. A CUDA graphics resource is unregistered using cudaGraphicsUnregisterResource(). Each CUDA context which intends to use the resource is required to register it separately."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15. Graphics Interoperability - Once a resource is registered ......A mapped resource can be read ...",
    "content": "Once a resource is registered to CUDA, it can be mapped and unmapped as many times as necessary using cudaGraphicsMapResources() and cudaGraphicsUnmapResources(). cudaGraphicsRe. sourceSetMapFlags() can be called to specify usage hints (write- only, read- only) that the CUDA driver can use to optimize resource management.\n\nA mapped resource can be read from or written to by kernels using the device mem. ory address returned by cudaGraphicsResourceGetMappedPointer() for buffers andcudaGraphicsSubResourceGetMappedArray() for CUDA arrays."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15. Graphics Interoperability - Accessing a resource through O...",
    "content": "Accessing a resource through OpenGL, Direct3D, or another CUDA context while it is mapped produces undefined results. OpenGL Interoperability and Direct3D Interoperability give specifics for each graphics API and some code samples. SLI Interoperability gives specifics for when the system is in SLI mode."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.1 OpenGL Interoperability - The OpenGL resources that may ......A buffer object is registered ...",
    "content": "The OpenGL resources that may be mapped into the address space of CUDA are OpenGL buffer, texture, and renderbuffer objects.\n\nA buffer object is registered using cudaGraphicsGLRegisterBuffer(). In CUDA, it appears as a device pointer and can therefore be read and written by kernels or via cudaMemcpy() calls."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.1 OpenGL Interoperability - A texture or renderbuffer obje...",
    "content": "A texture or renderbuffer object is registered using cudaGraphicsGLRegisterImage(). In CUDA, it appears as a CUDA array. Kernels can read from the array by binding it to a texture or surface reference. They can also write to it via the surface write functions if the resource has been registered with the cudaGraphicsRegisterFlagsSurfaceLoadStore flag. The array can also be read and written via cudaMemcpy2D() calls. cudaGraphicsGLRegisterImage() supports all texture formats with 1, 2, or 4 components and an internal type of float (for example, GL_RGBA_FLOAT32), normalized integer (for example, GL_RGBA8, GL_INTENSITY16), and unnormalized integer (for example, GL_RGBA8UI) (please note that since unnormalized integer formats require OpenGL 3."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.1 OpenGL Interoperability - 0 they can only be written by ...",
    "content": "0, they can only be written by shaders, not the fixed function pipeline)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.1 OpenGL Interoperability - The OpenGL context whose resou......The following code sample uses...",
    "content": "The OpenGL context whose resources are being shared has to be current to the host thread making any OpenGL interoperability API calls.\n\nPlease note: When an OpenGL texture is made bindless (say for example by requesting an image or texture handle using the glGetTextureHandle\\*/glGetImageHandle\\* APIs) it cannot be registered with CUDA. The application needs to register the texture for interop before requesting an image or texture handle.\n\nThe following code sample uses a kernel to dynamically modify a 2D width x height grid of vertices stored in a vertex buffer object:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.1 OpenGL Interoperability - GLuint positionsVBO struct cud...",
    "content": "GLuint positionsVBO; struct cudaGraphicsResource\\* positionsVBO_CUDA; int main() { // Initialize OpenGL and GLUT for device 0 // and make the OpenGL context current glutDisplayFunc(display); // Explicitly set device 0 cudaSetDevice(0); // Create buffer object and register it with CUDA glGenBuffers(1, &positionsVBO); glBindBuffer(GL_ARRAY_BUFFER, positionsVBO); unsigned int size  $=$  width \\* height \\* 4 \\* sizeof(float); glBufferData(GL_ARRAY_BUFFER, size, 0, GL_DYNAMIC_DRAW); glBindBuffer(GL_ARRAY_BUFFER, 0); cudaGraphicsGLRegisterBuffer(&positionsVBO_CUDA, positionsVBO, cudaGraphicsMapFlagsWriteDiscard); // Launch rendering loop glutMainLoop(); } void display() { // Map buffer object for writing from CUDA float4\\* positions; cudaGraphicsMapResources(1, &positionsVBO_CUDA, 0); size_t num"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.1 OpenGL Interoperability - bytes cudaGraphicsResourceGetM...",
    "content": "_bytes; cudaGraphicsResourceGetMappedPointer((void\\*)&positions, &num_bytes, positionsVBO_CUDA)); // Execute kernel dim3 dimBlock(16, 16, 1); dim3 dimGrid(width / dimBlock."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.1 OpenGL Interoperability - x height  dimBlocky 1 createVe...",
    "content": "x, height / dimBlock.y, 1); createVertices<<dimGrid, dimBlock>>>positions, time, width, height); // Unmap buffer object cudaGraphicsUnmapResources(1, &positionsVBO_CUDA, 0);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.1 OpenGL Interoperability - Render from buffer objectglCle...",
    "content": "// Render from buffer objectglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);glBindBuffer(GL_ARRAY_BUFFER, positionsVBO);glVertexPointer(4, GL_FLOAT, 0, 0);glEnableClientState(GL_VERTEX_ARRAY);glDrawArrays(GL_POINTS, 0, width * height);glDisableClientState(GL_VERTEX_ARRAY);// Swap buffersglutSwapBuffers();glutPostRedisplay();}void deleteVBO(){    cudaGraphicsUnregisterResource(positionsVBO_CUDA);    glDeleteBuffers(1, &positionsVBO);}__global__ void createVertices(float4* positions, float time, unsigned int width, unsigned int height){    unsigned int x = blockIdx.x * blockDim.x + threadIdx.x;    unsigned int y = blockIdx.y * blockDim.y + threadIdx.y;    // Calculate uv coordinates    float u = x / (float)width;    float v = y / (float)height;    u = u * 2.0f - 1.0f;    v = v * 2.0f - 1."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.1 OpenGL Interoperability - 0f     calculate simple sine w...",
    "content": "0f;    // calculate simple sine wave pattern    float freq = 4.0f;    float w = sinf(u * freq + time) * cosf(v * freq + time) * 0.5f;    // Write positions    positions[y * width + x] = make_float4(u, w, v, 1.0f);}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.1 OpenGL Interoperability - On Windows and for Quadro GPUs...",
    "content": "On Windows and for Quadro GPUs, cudaWGLGetDevice() can be used to retrieve the CUDA device associated to the handle returned by wglEnumGpusNV(). Quadro GPUs offer higher performance OpenGL interoperability than GeForce and Tesla GPUs in a multi- GPU configuration where OpenGL rendering is performed on the Quadro GPU and CUDA computations are performed on other GPUs in the system."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.2 Direct3D Interoperability - Direct3D interoperability is s......The Direct3D resources that ma...",
    "content": "Direct3D interoperability is supported for Direct3D 9Ex, Direct3D 10, and Direct3D 11.\n\nA CUDA context may interoperate only with Direct3D devices that fulfill the following criteria: Direct3D 9Ex devices must be created with DeviceType set to D3DDEVTYPE_HAL and BehaviorFlags with the D3DCREATE_HARDWARE_VERTEXPROCESSING flag; Direct3D 10 and Direct3D 11 devices must be created with DriverType set to D3D_DRIVER_TYPE_HARDWARE.\n\nThe Direct3D resources that may be mapped into the address space of CUDA are Direct3D buffers, textures, and surfaces. These resources are registered using cudaGraphicsD3D9RegisterResource(), cudaGraphicsD3DIRegisterResource(), and cudaGraphicsD3DI1RegisterResource()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.2 Direct3D Interoperability - The following code sample uses...",
    "content": "The following code sample uses a kernel to dynamically modify a 2D width x height grid of vertices stored in a vertex buffer object."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.2.1 Direct3D 9 Version - IDirect3D9 D3D IDirect3DDevice...",
    "content": "IDirect3D9\\* D3D; IDirect3DDevice9\\* device; struct CUSTOMVERTEX { FLOAT x,y,z; DWORD color; }; IDirect3DVertexBuffer9\\* positionsVB; struct cudaGraphicsResource\\* positionsVB_CUDA; int main() { int dev; // Initialize Direct3D D3D  $\\equiv$  Direct3DCreate9Ex(D3D_SDK_VERSION); // Get a CuDA- enabled adapter unsigned int adapter  $= \\theta$  . for (; adapter  $<$  g_pD3D- >GetAdapterCount(); adapter++) { D3DADAPTER_IDENTIFIER9 adapterId; g_pD3D- >GetAdapterIdentifier(adapter, 0, &adapterId); if (cudaD3D9GetDevice(&dev, adapterId."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.2.1 Direct3D 9 Version - DeviceName     cudaSuccess bre...",
    "content": "DeviceName)  $= =$  cudaSuccess) break; } // Create device D3D- >CreateDeviceEx(adapter, D3DDEVTYPE_HAL, hWnd D3DCREATE_HARDWARE_VERTEXPROCESSING, &params, NULL, &device); // Use the same device cudaSetDevice(dev); // Create vertex buffer and register it with CUDA unsigned int size  $\\equiv$  width \\* height \\* sizeof(CUSTOMVERTEX); device- >CreateVertexBuffer(size, 0, D3DFVF_CUSTOMVERTEX, D3DP00L_DEFAULT, &positionsVB, 0);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.2.1 Direct3D 9 Version - continues on next page...cuadaGraphicsD3D9RegisterResou...",
    "content": "(continues on next page)\n\n(cuadaGraphicsD3D9RegisterResource(&positionsVB_CUDA, positionsVB, cudaGraphicsRegisterFlagsNone); cudaGraphicsResourceSetMapFlags(positionsVB_CUDA, cudaGraphicsMapFlagsWriteDiscard); // Launch rendering loop while (...) { ... Render(); ... } ... }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "void Render() - Map vertex buffer for writing ...",
    "content": "{ // Map vertex buffer for writing from CUDA float4\\* positions; cudaGraphicsMapResources(1, &positionsVB_CUDA, 0); size_t num_bytes; cudaGraphicsResourceGetMappedPointer((void\\*\\*)&positions, &num_bytes, positionsVB_CUDA)); // Execute kernel dim3 dimBlock(16, 16, 1); dim3 dimGrid(width / dimBlock.x, height / dimBlock.y, 1); createVertices<<dimGrid, dimBlock  $\\geq \\geq$  (positions, time, width, height); // Unmap vertex buffer cudaGraphicsUnmapResources(1, &positionsVB_CUDA, 0); // Draw and present } void releaseVB() { cudaGraphicsUnregisterResource(positionsVB_CUDA); positionsVB- >Release(); } - - global- - void createVertices(float4\\* positions, float time, unsigned int width, unsigned int height) { unsigned int  $\\texttt{x} =$  blockIdx.x \\* blockDim.x  $^+$  threadIdx."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "void Render() - x unsigned int  texttty   bloc...",
    "content": "x; unsigned int  $\\texttt{y} =$  blockIdx.y \\* blockDim.y  $^+$  threadIdx.y; // Calculate uv coordinates float  $\\texttt{u} = \\texttt{x}$  / (float)width; float  $\\texttt{v} = \\texttt{y}$  / (float)height;  $\\texttt{u} = \\texttt{u}$  \\*2. Of- 1. Of;  $\\texttt{v} = \\texttt{v}$  \\*2. Of- 1. Of;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "void Render() - Calculate simple sine wave pat...",
    "content": "// Calculate simple sine wave pattern float freq  $=$  4.0f; float w  $=$  sinf(u \\* freq  $^+$  time) \\* cosf(v \\* freq  $^+$  time) \\* 0.5f; // Write positions positions[y \\* width  $+\\times ] =$  make_float4(u, w, v, _int_as_float(0xff00ff00)); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.2.2 Direct3D 10 Version - ID3D10Device device struct CUS...",
    "content": "ID3D10Device\\* device; struct CUSTOMVERTEX { FLOAT x, y, z; DWORD color; }; ID3D10Buffer\\* positionsVB; struct cudaGraphicsResource\\* positionsVB_CUDA; int main() { int dev; // Get a CUDA- enabled adapter IDXGIFactory\\* factory; CreateDXGIFactory(__uidof(IDXGIFactory), (void\\*\\*)factory); IDXGIGAdapter\\* adapter  $=$  0; for (unsigned int  $\\texttt{i} = \\texttt{0}$  ; !"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.2.2 Direct3D 10 Version - adapter    dotmathbf1   if FAI...",
    "content": "adapter;  $^{+ + }\\dot{\\mathbf{1}}$  ){ if (FAILED(factory- >EnumAdapters(i, &adapter)) break; if (cudaD3D10GetDevice(&dev, adapter)  $= =$  cudaSuccess) break; adapter- >Release(); } factory- >Release(); // Create swap chain and device D3D10CreateDeviceAndSwapChain(adapter, D3D10_DRIVER_TYPE_HARDWARE, 0, D3D10_CREATE_DEVICE_DEBUG, D3D10SDK_VERSION, &swapChainDesc, &swapChain, &device); adapter- >Release(); // Use the same device cudaSetDevice(dev); // Create vertex buffer and register it with CUDA unsigned int size  $=$  width \\* height \\* sizeof(CUSTOMVERTEX); D3D10_BUFFER_DESC bufferDesc; bufferDesc.Usage  $=$  D3D10_USAGE_DEFAULT; bufferDesc.ByteWidth  $=$  size;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.2.2 Direct3D 10 Version - httpscdnmineruopenxlaborgcnres......float u  x  floatwidth float v...",
    "content": "![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/141afc8ecfa1d695c3aa4cbeec1265e6f109b54c02bf288e2bc187d698441e4c.jpg)\n\nfloat u = x / (float)width; float v = y / (float)height; u = u * 2.0f - 1.0f; v = v * 2.0f - 1.0f; // Calculate simple sine wave pattern float freq = 4.0f; float w = sinf(u * freq + time) * cosf(v * freq + time) * 0.5f; // Write positions positions[y * width + x] = make_float4(u, w, v, __int_as_float(0xffff00ff00));"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.2.3 Direct3D 11 Version - ID3D11Device device struct CUS...",
    "content": "ID3D11Device* device; struct CUSTOMVERTEX {    FLOAT x, y, z;    DWORD color;};ID3D11Buffer* positionsVB;struct cudaGraphicsResource* positionsVB CUDA;int main() {    int dev;    // Get a CUDA- enabled adapter    IDXGIFactory* factory;    CreateDXGIFactory(__uuidof IDXGIFactory(), (void**) &factory);    IDXGIAAdapter* adapter = 0;    for (unsigned int i = 0; !"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.2.3 Direct3D 11 Version - adapter i         if FAILEDfac...",
    "content": "adapter; ++i) {        if (FAILED(factory- >EnumAdapters(i, &adapter))            break;        if (cudaD3D11GetDevice(&dev, adapter) == cudaSuccess)            break;        adapter- >Release();    }    factory- >Release();    // Create swap chain and device    sFnPtr_D3D11CreateDeviceAndSwapChain(adapter, D3D11_DRIVER_TYPE_HARDWARE, 0, D3D11_CREATE_DEVICE_DEBUG, featureLevels, 3, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &deviceContext);    adapter- >Release();}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.2.3 Direct3D 11 Version - httpscdnmineruopenxlaborgcnres......global void createVerticesfloa...",
    "content": "![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/6248ad4e49cb8c9a112162b8135512930bb4872438d1564e536bc71b28164211.jpg)\n\n- global__ void createVertices(float4* positions, float time, unsigned int width, unsigned int height) {    unsigned int x = blockIdx.x * blockDim.x + threadIdx.x;    unsigned int y = blockIdx.y * blockDim.y + threadIdx.y;    // Calculate uv coordinates    float u = x / (float)width;    float v = y / (float)height;    u = u * 2.0f - 1.0f;    v = v * 2.0f - 1.0f;    // Calculate simple sine wave pattern    float freq = 4.0f;    float w = sinf(u * freq + time) * cosf(v * freq + time) * 0.5f;    // Write positions    positions[y * width + x] = make_float4(u, w, v, __int_as_float(0xffff00ff00));}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.3 SLI Interoperability - In a system with multiple GPUs......First an allocation in one CUD...",
    "content": "In a system with multiple GPUs, all CUDA- enabled GPUs are accessible via the CUDA driver and runtime as separate devices. There are however special considerations as described below when the system is in SLI mode.\n\nFirst, an allocation in one CUDA device on one GPU will consume memory on other GPUs that are part of the SLI configuration of the DirectX or OpenGL device. Because of this, allocations may fail earlier than otherwise expected."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.3 SLI Interoperability - Second applications should cre...",
    "content": "Second, applications should create multiple CUDA contexts, one for each GPU in the SLI configuration. While this is not a strict requirement, it avoids unnecessary data transfers between devices. The application can use the cuda3D[9|10|11]GetDevices() for DirectX and CUDAGetDevices() for OpenGL set of calls to identify the CUDA device handle(s) for the device(s) that are performing the rendering in the current and next frame. Given this information the application will typically choose the appropriate device and map DirectX or OpenGL resources to the CUDA device returned by cuda3D[9|10|11]GetDevices() or cudaGLGetDevices() when the deviceList parameter is set to cuda3D[9|10|11]DeviceListCurrentFrame or cudaGLDeviceListCurrentFrame."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.15.3 SLI Interoperability - Please note that resource retu......See DirectX Interoperability a...",
    "content": "Please note that resource returned from cudaGraphicsD9D[9|10|11]RegisterResource and cudaGraphicsGLRegister(Buffer|Image] must be only used on device the registration happened. Therefore on SLI configurations when data for different frames is computed on different CUDA devices it is necessary to register the resources for each separately.\n\nSee DirectX Interoperability and OpenGL Interoperability for details on how the CUDA runtime inter-operate with DirectX and OpenGL, respectively."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16. External Resource Interoperability - External resource interoperabi...",
    "content": "External resource interoperability allows CUDA to import certain resources that are explicitly exported by other APIs. These objects are typically exported by other APIs using handles native to the Operating System, like file descriptors on Linux or NT handles on Windows. They could also be exported using other unified interfaces such as the NVIDIA Software Communication Interface. There are two types of resources that can be imported: memory objects and synchronization objects."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16. External Resource Interoperability - Memory objects can be imported...",
    "content": "Memory objects can be imported into CUDA using cudaImportExternalMemory(). An imported memory object can be accessed from within kernels using device pointers mapped onto the memory object via cudaExternalMemoryGetMappedBuffer() or CUDA mipmapd arrays mapped via cudaExternalMemoryGetMappedMipmapdArray(). Depending on the type of memory object, it may be possible for more than one mapping to be setup on a single memory object. The mappings must match the mappings setup in the exporting API. Any mismatched mappings result in undefined behavior. Imported memory objects must be freed using cudaDestroyExternalMemory(). Freeing a memory object does not free any mappings to that object."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16. External Resource Interoperability - Therefore any device pointers ...",
    "content": " Therefore, any device pointers mapped onto that object must be explicitly freed using cudaFree() and any CUDA mipmapd arrays mapped onto that object must be explicitly freed using cudaFreeMipmapdArray(). It is illegal to access mappings to an object after it has been destroyed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16. External Resource Interoperability - Synchronization objects can be...",
    "content": "Synchronization objects can be imported into CUDA using cudaImportExternalSemaphore(). An imported synchronization object can then be signaled using cudaSignalExternalSemaphore- sAsync() and waited on using cudaWaitExternalSemaphoresAsync(). It is illegal to issue a wait before the corresponding signal has been issued. Also, depending on the type of the imported synchronization object, there may be additional constraints imposed on how they can be signaled and waited on, as described in subsequent sections. Imported semaphore objects must be freed using cudaDestroyExternalSemaphore(). All outstanding signals and waits must have completed before the semaphore object is destroyed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1 Vulkan Interoperability",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.1 Matching device UUIDs - When importing memory and sync...",
    "content": "When importing memory and synchronization objects exported by Vulkan, they must be imported and mapped on the same device as they were created on. The CUDA device that corresponds to the Vulkan physical device on which the objects were created can be determined by comparing the UUID of a CUDA device with that of the Vulkan physical device, as shown in the following code sample. Note that the Vulkan physical device should not be part of a device group that contains more than one Vulkan physical device. The device group as returned by vkEnumeratePhysicalDeviceGroups that contains the given Vulkan physical device must have a physical device count of 1."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.1 Matching device UUIDs - int getCudaDeviceForVulkanPhys...",
    "content": "int getCudaDeviceForVulkanPhysicalDevice(VkPhysicalDevice vkPhysicalDevice) { VkPhysicalDeviceIDProperties vkPhysicalDeviceIDProperties = {}; vkPhysicalDeviceIDProperties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID. PROPERTIES; vkPhysicalDeviceIDProperties.pNext = NULL; VkPhysicalDeviceProperties2 vkPhysicalDeviceProperties2 = {}; vkPhysicalDeviceProperties2. sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_  $\\rightarrow 2$  . vkPhysicalDeviceProperties2. pNext  $=$  &vkPhysicalDeviceIDProperties; vkGetPhysicalDeviceProperties2(vkPhysicalDevice, &vkPhysicalDeviceProperties2); (continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.1 Matching device UUIDs - int cudaDeviceCount cudaGetDev...",
    "content": "int cudaDeviceCount; cudaGetDeviceCount(&cudaDeviceCount); for (int cudaDevice  $= \\theta$  ; cudaDevice  $<$  cudaDeviceCount; cudaDevice++) { cudaDeviceProp deviceProp; cudaGetDeviceProperties(&deviceProp, cudaDevice); if (!memcmp(&deviceProp.uuid, vkPhysicalDeviceIDProperties.deviceUUID, VK_  $\\rightarrow$  UUID_SIZE)) { return cudaDevice; } } return cudaInvalidDeviceId; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.2 Importing Memory Objects - On Linux and Windows 10 both d......A Vulkan memory object exporte...",
    "content": "On Linux and Windows 10, both dedicated and non- dedicated memory objects exported by Vulkan can be imported into CUDA. On Windows 7, only dedicated memory objects can be imported. When importing a Vulkan dedicated memory object, the flag cudaExternalMemoryDedicated must be set.\n\nA Vulkan memory object exported using VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT can be imported into CUDA using the file descriptor associated with that object as shown below. Note that CUDA assumes ownership of the file descriptor once it is imported. Using the file descriptor after a successful import results in undefined behavior."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.2 Importing Memory Objects - cudaExternalMemoryt importVulk...",
    "content": "cudaExternalMemory_t importVulkanMemoryObjectFromFileDescriptor(int fd, unsigned long  $\\leftrightarrow$  long size, bool isDedicated) { cudaExternalMemory_t extMem  $=$  NULL; cudaExternalMemoryHandleDesc desc  $=$  {}; memset(&desc, 0, sizeof(desc)); desc.type  $=$  cudaExternalMemoryHandleTypeOpaqueFd; desc.handle.  $\\mathsf{fd} = \\mathsf{fd}$  . desc.size  $=$  size; if (isDedicated) { desc.flags  $| =$  cudaExternalMemoryDedicated; } cudaImportExternalMemory(&extMem, &desc); // Input parameter 'fd' should not be used beyond this point as CUDA has assumed  $\\leftrightarrow$  ownership of it return extMem; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.2 Importing Memory Objects - A Vulkan memory object exporte...",
    "content": "A Vulkan memory object exported using VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT can be imported into CUDA using the NT handle associated with that object as shown below. Note that CUDA does not assume ownership of the NT handle and it is the application's responsibility to close the handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying memory can be freed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.2 Importing Memory Objects - cudaExternalMemoryt importVulk......A Vulkan memory object exporte...",
    "content": "cudaExternalMemory_t importVulkanMemoryObjectFromNHandle(HANDLE handle, unsigned  $\\rightarrow$  long long size, bool isDedicated) { cudaExternalMemory_t extMem  $=$  NULL; cudaExternalMemoryHandleDesc desc  $=$  {}; memset(&desc, 0, sizeof(desc)); desc.type  $=$  cudaExternalMemoryHandleTypeOpaqueWin32; desc.handle.win32. handle  $=$  handle; desc.size  $=$  size; if (isDedicated) { desc.flags  $=$  cudaExternalMemoryDedicated; } cudaImportExternalMemory(&extMem, &desc); // Input parameter 'handle' should be closed if it's not needed anymore CloseHandle(handle); return extMem; }\n\nA Vulkan memory object exported using VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT can also be imported using a named handle if one exists as shown below."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.2 Importing Memory Objects - cudaExternalMemoryt importVulk...",
    "content": "cudaExternalMemory_t importVulkanMemoryObjectFromNamedNHandle(LPCWSTR name, unsigned  $\\rightarrow$  long long size, bool isDedicated) { cudaExternalMemory_t extMem  $=$  NULL; cudaExternalMemoryHandleDesc desc  $=$  {}; memset(&desc, 0, sizeof(desc)); desc.type  $=$  cudaExternalMemoryHandleTypeOpaqueWin32; desc.handle.win32. name  $=$  (void \\*)name; desc.size  $=$  size; if (isDedicated) { desc.flags  $=$  cudaExternalMemoryDedicated; } cudaImportExternalMemory(&extMem, &desc); return extMem; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.2 Importing Memory Objects - A Vulkan memory object exporte......continues on next page",
    "content": "A Vulkan memory object exported using VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT can be imported into CUDA using the globally shared D3DKMT handle associated with that object as shown below. Since a globally shared D3DKMT handle does not hold a reference to the underlying memory it is automatically destroyed when all other references to the resource are destroyed.\n\ncudaExternalMemory_t importVulkanMemoryObjectFromKMTHandle(HANDLE handle, unsigned  $\\rightarrow$  long long size, bool isDedicated) { cudaExternalMemory_t extMem  $=$  NULL; cudaExternalMemoryHandleDesc desc  $=$  {}; memset(&desc, 0, sizeof(desc)); desc.type  $=$  cudaExternalMemoryHandleTypeOpaqueWin32Kmt;\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.2 Importing Memory Objects - deschandlewin32 handle  void h...",
    "content": "desc.handle.win32. handle = (void *)handle;  desc.size = size;  if (isDedicated) {      desc.flags |= cudaExternalMemoryDedicated;  }  cudaImportExternalMemory(&extMem, &desc);  return extMem;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.3 Mapping Buffers onto Imported Memory Objects - A device pointer can be mapped......void  mapBufferOntoExternalMem...",
    "content": "# 6.2.16.1.3 Mapping Buffers onto Imported Memory Objects\nA device pointer can be mapped onto an imported memory object as shown below. The offset and size of the mapping must match that specified when creating the mapping using the corresponding Vulkan API. All mapped device pointers must be freed using cudaFree().\n\nvoid \\* mapBufferOntoExternalMemory(cudaExternalMemory_t extMem, unsigned long long  $\\hookrightarrow$  offset, unsigned long long size) { void \\*ptr  $=$  NULL; cudaExternalMemoryBufferDesc desc  $=$  {}; memset(&desc, 0, sizeof(desc)); desc.offset  $=$  offset; desc.size  $=$  size; cudaExternalMemoryGetMappedBuffer(&ptr, extMem, &desc); // Note: 'ptr' must eventually be freed using cudaFree() return ptr; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.4 Mapping Mipmapped Arrays onto Imported Memory Objects - A CUDA mipmaped array can be m......cudaMipmappedArrayt mIpMipmapp...",
    "content": "A CUDA mipmaped array can be mapped onto an imported memory object as shown below. The offset, dimensions, format and number of mip levels must match that specified when creating the mapping using the corresponding Vulkan API. Additionally, if the mipmaped array is bound as a color target in Vulkan, the flagcudaArrayColorAttachment must be set. All mapped mipmaped arrays must be freed using cudaFreeMipmapedArray(). The following code sample shows how to convert Vulkan parameters into the corresponding CUDA parameters when mapping mipmaped arrays onto imported memory objects.\n\ncudaMipmappedArray_t mIpMipmappedArrayontoExternalMemory(cudaExternalMemory_t extMem, unsigned long offset, cudaChannelFormatDesc \\*formatDesc, cudaExtent \\*extent, unsigned int flags, unsigned int numLevels) {"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.4 Mapping Mipmapped Arrays onto Imported Memory Objects - cudaMipmappedArrayt mipmap  NU......cudaChannelFormatDesc d memset...",
    "content": "cudaMipmappedArray_t mipmap = NULL; cudaExternalMemoryMipmappedArrayDesc desc = {};\n\nmemset(&desc, 0, sizeof(desc));\n\ndesc.offset = offset; desc.formatDesc = \\*formatDesc; desc.extension = \\*extent; desc.flags = flags; desc.numLevels = numLevels;\n\n// Note: 'mipmap' must eventually be freed using cudaFreeMipmappedArray() cudaExternalMemoryGetMappedMipmappedArray(&mipmap, extMem, &desc);\n\nreturn mipmap; }\n\ncudaChannelFormatDesc getCudaChannelFormatDescForVulkanFormat(VkFormat format) {\n\ncudaChannelFormatDesc d; memset(&d, 0, sizeof(d));"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.4 Mapping Mipmapped Arrays onto Imported Memory Objects - switch format  case VKFOMATR8U...",
    "content": "switch (format) { case VK_FOMAT_R8_UINT: d.x = 8; d.y = 0; d.z = 0; d.w = 0; d.f = cudaChannelFormatKindUnsigned; break; case VK_FOMAT_R8_SINT: d.x = 8; d.y = 0; d.z = 0; d.w = 0; d.f = cudaChannelFormatKindSigned; break; case VK_FOMAT_R8G8_UINT: d.x = 8; d.y = 8; d.z = 0; d.w = 0; d.f = cudaChannelFormatKindUnsigned; break; case VK_FOMAT_R8G8_SINT: d.x = 8; d.y = 8; d.z = 0; d.w = 0; d.f = cudaChannelFormatKindSigned; break; case VK_FOMAT_R8G8B8A8_UINT: d.x = 8; d.y = 8; d.z = 8; d.w = 8; d.f = cudaChannelFormatKindUnsigned; break; case VK_FOMAT_R8G8B8A8_SINT: d.x = 8; d.y = 8; d.z = 8; d.w = 8; d.f = cudaChannelFormatKindSigned; break; case VK_FOMAT_R16_UINT: d.x = 16; d.y = 0; d.z = 0; d.w = 0; d.f = cudaChannelFormatKindUnsigned; break; case VK_FOMAT_R16_SINT: d.x = 16; d.y = 0; d."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.4 Mapping Mipmapped Arrays onto Imported Memory Objects - z  0 dw  0 df  cudaChannelForm...",
    "content": "z = 0; d.w = 0; d.f = cudaChannelFormatKindSigned; break; case VK_FOMAT_R16G16_UINT: d.x = 16; d.y = 16; d.z = 0; d.w = 0; d.f = cudaChannelFormatKindUnsigned; break; case VK_FOMAT_R16G16_SINT: d.x = 16; d.y = 16; d.z = 0; d.w = 0; d.f = cudaChannelFormatKindSigned; break;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.4 Mapping Mipmapped Arrays onto Imported Memory Objects - continues on next page",
    "content": "(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.4 Mapping Mipmapped Arrays onto Imported Memory Objects - continued from previous page c...",
    "content": "(continued from previous page) case VK_FOMAT_R16G16B16A16_UINT:  $\\texttt{d.x} = 16;\\texttt{d.y} = 16;\\texttt{d.z} = 16;\\texttt{d.w} = 16;\\texttt{d.f} =$  cudaChannelFormatKindUnsigned; break; case VK_FOMAT_R16G16B16A16_SINT:  $\\texttt{d.x} = 16;\\texttt{d.y} = 16;\\texttt{d.z} = 16;\\texttt{d.w} = 16;\\texttt{d.f} =$  cudaChannelFormatKindSigned; break; case VK_FOMAT_R32_UINT:  $\\texttt{d.x} = 32;\\texttt{d.y} = \\theta ;\\texttt{d.z} = \\theta ;\\texttt{d.w} = \\theta ;\\texttt{d.f} =$  cudaChannelFormatKindUnsigned; break; case VK_FOMAT_R32_SINT:  $\\texttt{d.x} = 32;\\texttt{d.y} = \\theta ;\\texttt{d.z} = \\theta ;\\texttt{d.w} = \\theta ;\\texttt{d.f} =$  cudaChannelFormatKindSigned; break; case VK_FOMAT_R32_SFLOAT:  $\\texttt{d.x} = 32;\\texttt{d.y} = \\theta ;\\texttt{d.z} = \\theta ;\\texttt{d."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.4 Mapping Mipmapped Arrays onto Imported Memory Objects - w  theta textttdf   cudaChanne...",
    "content": "w} = \\theta ;\\texttt{d.f} =$  cudaChannelFormatKindFloat; break; case VK_FOMAT_R32G32_UINT:  $\\texttt{d.x} = 32;\\texttt{d.y} = 32;\\texttt{d.z} = \\theta ;\\texttt{d.w} = \\theta ;\\texttt{d.f} =$  cudaChannelFormatKindUnsigned; break; case VK_FOMAT_R32G32_SINT:  $\\texttt{d.x} = 32;\\texttt{d.y} = 32;\\texttt{d.z} = \\theta ;\\texttt{d.w} = \\theta ;\\texttt{d.f} =$  cudaChannelFormatKindSigned; break; case VK_FOMAT_R32G32_SFLOAT:  $\\texttt{d.x} = 32;\\texttt{d.y} = 32;\\texttt{d.z} = \\theta ;\\texttt{d.w} = \\theta ;\\texttt{d.f} =$  cudaChannelFormatKindFloat; break; case VK_FOMAT_R32G32B32A32_UINT:  $\\texttt{d.x} = 32;\\texttt{d.y} = 32;\\texttt{d.z} = 32;\\texttt{d.w} = 32;\\texttt{d.f} =$  cudaChannelFormatKindUnsigned; break; case VK_FOMAT_R32G32B32A32_SINT:  $\\texttt{d.x} = 32;\\texttt{d."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.4 Mapping Mipmapped Arrays onto Imported Memory Objects - y  32textttdz  32textttdw  32t...",
    "content": "y} = 32;\\texttt{d.z} = 32;\\texttt{d.w} = 32;\\texttt{d.f} =$  cudaChannelFormatKindSigned; break; case VK_FOMAT_R32G32B32A32_SFLOAT:  $\\texttt{d.x} = 32;\\texttt{d.y} = 32;\\texttt{d.z} = 32;\\texttt{d.w} = 32;\\texttt{d.f} =$  cudaChannelFormatKindFloat; break; default: assert(0); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.4 Mapping Mipmapped Arrays onto Imported Memory Objects - return d  cudaExtent getCudaEx...",
    "content": "return d; } cudaExtent getCudaExtentForVulkanExtent(VkExtent3D vkExt, uint32_t arrayLayers, VkImageViewType vkImageViewType) { cudaExtent e = {0, 0, 0}; switch (vkImageViewType) { case VK_IMAGE_VIEW_TYPE_1D: e.width = vkExt.width; e.height = 0; e.depth = 0; break; case VK_IMAGE_VIEW_TYPE_2D: e.width = vkExt.width; e.height = vkExt. height; e.depth = 0; break; case VK_IMAGE_VIEW_TYPE_3D: e.width = vkExt.width; e.height = vkExt. height; e.depth = vkExt.depth; break; case VK_IMAGE_VIEW_TYPE_CUBE: e.width = vkExt.width; e.height = vkExt. height; e.depth = arrayLayers; break; case VK_IMAGE_VIEW_TYPE_1D_ARRAY: e.width = vkExt.width; e.height = 0; e.depth = arrayLayers; break; case VK_IMAGE_VIEW_TYPE_2D_ARRAY: e.width = vkExt.width; e.height = vkExt. height; e."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.4 Mapping Mipmapped Arrays onto Imported Memory Objects - depth  arrayLayers break case ...",
    "content": "depth = arrayLayers; break; case VK_IMAGE_VIEW_TYPE_CUBE_ARRAY: e.width = vkExt.width; e.height = vkExt. height; e.depth = arrayLayers; break; default: assert(0); } return e; } unsigned int getCudaMipmappedArrayFlagsForVulkanImage(VkImageViewType vkImageViewType, VkImageUsageFlags vkImageUsageFlags, bool allowSurfaceLoadStore) { unsigned int flags = 0;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.4 Mapping Mipmapped Arrays onto Imported Memory Objects - continues on next page...switch vkImageViewType case VK...",
    "content": "(continues on next page)\n\nswitch (vkImageViewType) {case VK_IMAGE_VIEW_TYPE_CUBE: flags |= cudaArrayCubemap;break;case VK_IMAGE_VIEW_TYPE_CUBE_ARRAY: flags |= cudaArrayCubemap | cudaArrayLayered;break;case VK_IMAGE_VIEW_TYPE_1D_ARRAY: flags |= cudaArrayLayered;break;case VK_IMAGE_VIEW_TYPE_2D_ARRAY: flags |= cudaArrayLayered;break;default: break;}if (vkImageUsageFlags & VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT) {    flags |= cudaArrayColorAttachment;}if (allowSurfaceLoadStore) {    flags |= cudaArraySurfaceLoadStore;}return flags;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.5 Importing Synchronization Objects - A Vulkan semaphore object expo......cudaExternalSemaphoret importV...",
    "content": "A Vulkan semaphore object exported using VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT can be imported into CUDA using the file descriptor associated with that object as shown below. Note that CUDA assumes ownership of the file descriptor once it is imported. Using the file descriptor after a successful import results in undefined behavior.\n\ncudaExternalSemaphore_t importVulkanSemaphoreObjectFromFileDescriptor(int fd) {    cudaExternalSemaphore_t extSem = NULL;    cudaExternalSemaphoreHandleDesc desc = {};    memset(&desc, 0, sizeof(desc));    desc.type = cudaExternalSemaphoreHandleTypeOpaqueFd;    desc.handle.fd = fd;    cudaImportExternalSemaphore(&extSem, &desc);    // Input parameter 'fd' should not be used beyond this point as CUDA has assumed ownership of it    return extSem;}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.5 Importing Synchronization Objects - A Vulkan semaphore object expo...",
    "content": "A Vulkan semaphore object exported using VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT can be imported into CUDA using the NT handle associated with that object as shown below. Note that CUDA does not assume ownership of the NT handle and it is the application's responsibility to close the handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying semaphore can be freed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.5 Importing Synchronization Objects - cudaExternalSemaphoret importV......A Vulkan semaphore object expo...",
    "content": "cudaExternalSemaphore_t importVulkanSemaphoreObjectFromNHandle(HANDLE handle) {    cudaExternalSemaphore_t extSem = NULL;    cudaExternalSemaphoreHandleDesc desc = {};    memset(&desc, 0, sizeof(desc));    desc.type = cudaExternalSemaphoreHandleTypeOpaqueWin32;    desc.handle.win32. handle = handle;    cudaImportExternalSemaphore(&extSem, &desc);    // Input parameter 'handle' should be closed if it's not needed anymore    CloseHandle(handle);    return extSem;}\n\nA Vulkan semaphore object exported using VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT can also be imported using a named handle if one exists as shown below."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.5 Importing Synchronization Objects - cudaExternalSemaphoret importV......A Vulkan semaphore object expo...",
    "content": "cudaExternalSemaphore_t importVulkanSemaphoreObjectFromNamedNHandle(LPWSTR name) {    cudaExternalSemaphore_t extSem = NULL;    cudaExternalSemaphoreHandleDesc desc = {};    memset(&desc, 0, sizeof(desc));    desc.type = cudaExternalSemaphoreHandleTypeOpaqueWin32;    desc.handle.win32. name = (void *)name;    cudaImportExternalSemaphore(&extSem, &desc);    return extSem;}\n\nA Vulkan semaphore object exported using VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT can be imported into CUDA using the globally shared D3DKMT handle associated with that object as shown below. Since a globally shared D3DKMT handle does not hold a reference to the underlying semaphore it is automatically destroyed when all other references to the resource are destroyed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.5 Importing Synchronization Objects - cudaExternalSemaphoret importV...",
    "content": "cudaExternalSemaphore_t importVulkanSemaphoreObjectFromKMTHandle(HANDLE handle) {    cudaExternalSemaphore_t extSem = NULL;    cudaExternalSemaphoreHandleDesc desc = {};    memset(&desc, 0, sizeof(desc));    desc.type = cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt;    desc.handle.win32. handle = (void *)handle;    cudaImportExternalSemaphore(&extSem, &desc);    return extSem;}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.6 Signaling/Waiting on Imported Synchronization Objects - An imported Vulkan semaphore o......void signalExternalSemaphorecu...",
    "content": "An imported Vulkan semaphore object can be signaled as shown below. Signaling such a semaphore object sets it to the signaled state. The corresponding wait that waits on this signal must be issued in Vulkan. Additionally, the wait that waits on this signal must be issued after this signal has been issued.\n\nvoid signalExternalSemaphore(cudaExternalSemaphore_t extSem, cudaStream_t stream) { cudaExternalSemaphoreSignalParams params = {}; memset(&params, 0, sizeof(params)); cudaSignalExternalSemaphoresAsync(&extSem, &params, 1, stream); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.1.6 Signaling/Waiting on Imported Synchronization Objects - An imported Vulkan semaphore o......void waitExternalSemaphorecuda...",
    "content": "An imported Vulkan semaphore object can be waited on as shown below. Waiting on such a semaphore object waits until it reaches the signaled state and then resets it back to the unsignaled state. The corresponding signal that this wait is waiting on must be issued in Vulkan. Additionally, the signal must be issued before this wait can be issued.\n\nvoid waitExternalSemaphore(cudaExternalSemaphore_t extSem, cudaStream_t stream) { cudaExternalSemaphoreWaitParams params = {}; memset(&params, 0, sizeof(params)); cudaWaitExternalSemaphoresAsync(&extSem, &params, 1, stream); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3 Direct3D 12 Interoperability - Traditional OpenGL CUDA intero......GLEXTmemoryobject GLEXTmemoryo...",
    "content": "# 6.2.16.2 OpenGL Interoperability\nTraditional OpenGL- CUDA interop as outlined in OpenGL Interoperability works by CUDA directly consuming handles created in OpenGL. However, since OpenGL can also consume memory and synchronization objects created in Vulkan, there exists an alternative approach to doing OpenGL- CUDA interop. Essentially, memory and synchronization objects exported by Vulkan could be imported into both, OpenGL and CUDA, and then used to coordinate memory accesses between OpenGL and CUDA. Please refer to the following OpenGL extensions for further details on how to import memory and synchronization objects exported by Vulkan:\n\n- GL_EXT_memory_object- GL_EXT_memory_object_fd- GL_EXT_memory_object_win32- GL_EXT_semaphore- GL_EXT_semaphore_fd- GL_EXT_semaphore_win32\n\n# 6.2.16.3 Direct3D 12 Interoperability\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.1 Matching Device LUIDs - When importing memory and sync...",
    "content": "When importing memory and synchronization objects exported by Direct3D 12, they must be imported and mapped on the same device as they were created on. The CUDA device that corresponds to the Direct3D 12 device on which the objects were created can be determined by comparing the LUID of a CUDA device with that of the Direct3D 12 device, as shown in the following code sample. Note that the Direct3D 12 device must not be created on a linked node adapter. I.e. the node count as returned by ID3D12Device::GetNodeCount must be 1."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.1 Matching Device LUIDs - int getCudaDeviceForD3D12Devic...",
    "content": "int getCudaDeviceForD3D12Device(ID3D12Device \\*d3d12Device) { LUID d3d12Luid  $=$  d3d12Device- >GetAdapterLuid(); int cudaDeviceCount; cudaGetDeviceCount(&cudaDeviceCount); for (int cudaDevice  $= \\theta$  cudaDevice  $<$  cudaDeviceCount; cudaDevice++) { cudaDeviceProp deviceProp; cudaGetDeviceProperties(&deviceProp, cudaDevice); char \\*cudaLuid  $=$  deviceProp.luid; if (!mcmp(&d3d12Luid.LowPart, cudaLuid, sizeof(d3d12Luid.LowPart)) && !mcmp(&d3d12Luid.HighPart, cudaLuid  $^+$  sizeof(d3d12Luid.LowPart), - sizeof(d3d12Luid.HighPart))) { return cudaDevice; } } return cudaInvalidDeviceId; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.2 Importing Memory Objects - A shareable Direct3D 12 heap m...",
    "content": "A shareable Direct3D 12 heap memory object, created by setting the flag D3D12_HEAP_FLAG_SHARED in the call to ID3D12Device: :CreateHeap, can be imported into CUDA using the NT handle associated with that object as shown below. Note that it is the application's responsibility to close the NT handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying memory can be freed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.2 Importing Memory Objects - cudaExternalMemoryt importD3D1......A shareable Direct3D 12 heap m...",
    "content": "cudaExternalMemory_t importD3D12HeapFromNHandle(HANDLE handle, unsigned long long  $\\leftrightarrow$  size) { cudaExternalMemory_t extMem  $=$  NULL; cudaExternalMemoryHandleDesc desc  $=$  {}; memset(&desc, 0, sizeof(desc)); desc.type  $=$  cudaExternalMemoryHandleTypeD3D12Heap; desc.handle.win32. handle  $=$  (void \\*)handle; desc.size  $=$  size; cudaImportExternalMemory(&extMem, &desc); // Input parameter 'handle' should be closed if it's not needed anymore CloseHandle(handle);\n\n(continues on next page)\n\nreturn extMem; }\n\nA shareable Direct3D 12 heap memory object can also be imported using a named handle if one exists as shown below."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.2 Importing Memory Objects - cudaExternalMemoryt importD3D1...",
    "content": "cudaExternalMemory_t importD3D12HeapFromNamedNHandle(LPCWSTR name, unsigned long  $\\rightarrow$  long size){ cudaExternalMemory_t extMem  $=$  NULL; cudaExternalMemoryHandleDesc desc  $=$  {}; memset(&desc, 0, sizeof(desc)); desc.type  $=$  cudaExternalMemoryHandleTypeD3D12Heap; desc.handle.win32. name  $=$  (void \\*)name; desc.size  $=$  size; cudaImportExternalMemory(&extMem, &desc); return extMem; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.2 Importing Memory Objects - A shareable Direct3D 12 commit...",
    "content": "A shareable Direct3D 12 committed resource, created by setting the flag D3D12_HEAP_FLAG_SHARED in the call to D3D12Device::CreateCommittedResource, can be imported into CUDA using the NT handle associated with that object as shown below. When importing a Direct3D 12 committed resource, the flag cudaExternalMemoryDedicated must be set. Note that it is the application's responsibility to close the NT handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying memory can be freed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.2 Importing Memory Objects - cudaExternalMemoryt importD3D1......A shareable Direct3D 12 commit...",
    "content": "cudaExternalMemory_t importD3D12CommittedResourceFromNHandle(HANDLE handle, unsigned  $\\rightarrow$  long long size){ cudaExternalMemoryHandleDesc desc  $=$  {}; memset(&desc, 0, sizeof(desc)); desc.type  $=$  cudaExternalMemoryHandleTypeD3D12Resource; desc.handle.win32. handle  $=$  (void \\*)handle; desc.size  $=$  size; desc.flags  $| =$  cudaExternalMemoryDedicated; cudaImportExternalMemory(&extMem, &desc); // Input parameter 'handle' should be closed if it's not needed anymore CloseHandle(handle); return extMem; }\n\nA shareable Direct3D 12 committed resource can also be imported using a named handle if one exists as shown below."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.2 Importing Memory Objects - cudaExternalMemoryt importD3D1......cudaExternalMemoryHandleDesc d...",
    "content": "cudaExternalMemory_t importD3D12CommittedResourceFromNamedNHandle(LPCWSTR name,  $\\rightarrow$  unsigned long long size){ cudaExternalMemory_t extMem  $=$  NULL;\n\n(continues on next page)\n\ncudaExternalMemoryHandleDesc desc = {}; memset(&desc, 0, sizeof(desc)); desc.type = cudaExternalMemoryHandleTypeD3D12Resource; desc.handle.win32. name = (void *)name; desc.size = size; desc.flags |= cudaExternalMemoryDedicated; cudaImportExternalMemory(&extMem, &desc); return extMem;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.3 Mapping Buffers onto Imported Memory Objects - A device pointer can be mapped......void  mapBufferOntoExternalMem...",
    "content": "# 6.2.16.3.3 Mapping Buffers onto Imported Memory Objects\nA device pointer can be mapped onto an imported memory object as shown below. The offset and size of the mapping must match that specified when creating the mapping using the corresponding Direct3D 12 API. All mapped device pointers must be freed using cudaFree().\n\nvoid \\* mapBufferOntoExternalMemory(cudaExternalMemory_t extMem, unsigned long long  $\\hookrightarrow$  offset, unsigned long long size) { void \\*ptr  $=$  NULL; cudaExternalMemoryBufferDesc desc  $=$  {}; memset(&desc, 0, sizeof(desc)); desc.offset  $=$  offset; desc.size  $=$  size; cudaExternalMemoryGetMappedBuffer(&ptr, extMem, &desc); // Note: 'ptr' must eventually be freed using cudaFree() return ptr; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.4 Mapping Mipmaped Arrays onto Imported Memory Objects - A CUDA mipmaped array can be m...",
    "content": "A CUDA mipmaped array can be mapped onto an imported memory object as shown below. The offset, dimensions, format and number of mip levels must match that specified when creating the mapping using the corresponding Direct3D 12 API. Additionally, if the mipmaped array can be bound as a render target in Direct3D 12, the flag cudaArrayColorAttachment must be set. All mapped mipmaped arrays must be freed using cudaFreeMipmapedArray(). The following code sample shows how to convert Vulkan parameters into the corresponding CUDA parameters when mapping mipmaped arrays onto imported memory objects."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.4 Mapping Mipmaped Arrays onto Imported Memory Objects - cudaMipmapedArrayt mapMipmaped......continues on next page",
    "content": "cudaMipmapedArray_t mapMipmapedArrayOntoExternalMemory(cudaExternalMemory_t extMem,  $\\hookrightarrow$  unsigned long long offset, cudaChannelFormatDesc \\*formatDesc, cudaExtent \\*extent,  $\\hookrightarrow$  unsigned int flags, unsigned int numLevels) { cudaMipmapedArray_t mipmap  $=$  NULL; cudaExternalMemoryMipmappedArrayDesc desc  $=$  {};\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.4 Mapping Mipmaped Arrays onto Imported Memory Objects - memsetdesc 0 sizeofdescdescoff...",
    "content": "memset(&desc, 0, sizeof(desc));desc.offset = offset;desc.formatDesc = *formatDesc;desc.extension = *extent;desc.flags = flags;desc.numLevels = numLevels;// Note: 'mipmap' must eventually be freed using cudaFreeMipmapedArray()cudaExternalMemoryGetMappedMipmapedArray(&mipmap, extMem, &desc);return mipmap;}cudaChannelFormatDesc getCudaChannelFormatDescForDxgiFormat(DXGI_FORMAT dxgiFormat){cudaChannelFormatDesc d;memset(&d, 0, sizeof(d));switch (dxgiFormat) {case DXGI_FORMAT_R8_UINT: d.x = 8; d.y = 0; d.z = 0; d.w = 0; d.f- - = cudaChannelFormatKindUnsigned; break;case DXGI_FORMAT_R8_SINT: d.x = 8; d.y = 0; d.z = 0; d.w = 0; d.f- - = cudaChannelFormatKindSigned; break;case DXGI_FORMAT_R8G8_UINT: d.x = 8; d.y = 8; d.z = 0; d.w = 0; d."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.4 Mapping Mipmaped Arrays onto Imported Memory Objects - f   cudaChannelFormatKindUnsig...",
    "content": "f- - = cudaChannelFormatKindUnsigned; break;case DXGI_FORMAT_R8G8_8A8_UINT: d.x = 8; d.y = 8; d.z = 8; d.w = 8; d.f- - = cudaChannelFormatKindUnsigned; break;case DXGI_FORMAT_R8G8B8A8_SINT: d.x = 8; d.y = 8; d.z = 8; d.w = 8; d.f- - = cudaChannelFormatKindSigned; break;case DXGI_FORMAT_R16_UINT: d.x = 16; d.y = 0; d.z = 0; d.w = 0; d.f- - = cudaChannelFormatKindUnsigned; break;case DXGI_FORMAT_R16_SINT: d.x = 16; d.y = 0; d.z = 0; d.w = 0; d.f- - = cudaChannelFormatKindSigned; break;case DXGI_FORMAT_R16G16_UINT: d.x = 16; d.y = 16; d.z = 0; d.w = 0; d.f- - = cudaChannelFormatKindUnsigned; break;case DXGI_FORMAT_R16G16_SINT: d.x = 16; d.y = 16; d.z = 0; d.w = 0; d.f- - = cudaChannelFormatKindSigned; break;case DXGI_FORMAT_R16G16B16A16_UINT: d.x = 16; d.y = 16; d.z = 16; d.w = 16; d."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.4 Mapping Mipmaped Arrays onto Imported Memory Objects - f   cudaChannelFormatKindUnsig...",
    "content": "f- - = cudaChannelFormatKindUnsigned; break;case DXGI_FORMAT_R16G16B16A16_SINT: d.x = 16; d.y = 16; d.z = 16; d.w = 16; d.f- - = cudaChannelFormatKindSigned; break;case DXGI_FORMAT_R32_UINT: d.x = 32; d.y = 0; d.z = 0; d.w = 0; d.f- - = cudaChannelFormatKindUnsigned; break;case DXGI_FORMAT_R32_SINT: d.x = 32; d.y = 0; d.z = 0; d.w = 0; d.f- - = cudaChannelFormatKindSigned; break;case DXGI_FORMAT_R32_FLOAT: d.x = 32; d.y = 0; d.z = 0; d.w = 0; d.f- - = cudaChannelFormatKindFloat; break;case DXGI_FORMAT_R32G32_UINT: d.x = 32; d.y = 32; d.z = 0; d.w = 0; d.f- - = cudaChannelFormatKindUnsigned; break;case DXGI_FORMAT_R32G32_SINT: d.x = 32; d.y = 32; d.z = 0; d.w = 0; d.f- - = cudaChannelFormatKindSigned; break;case DXGI_FORMAT_R32G32_FLOAT: d.x = 32; d.y = 32; d.z = 0; d.w = 0; d."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.4 Mapping Mipmaped Arrays onto Imported Memory Objects - f   cudaChannelFormatKindFloat...",
    "content": "f- - = cudaChannelFormatKindFloat; break;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.4 Mapping Mipmaped Arrays onto Imported Memory Objects - continued from previous page c...",
    "content": "(continued from previous page) case DXGI_FORMAT_R32G32B32A32_UINT: d.x = 32; d.y = 32; d.z = 32; d.w = 32; d.f  $\\leftrightarrow =$  cudaChannelFormatKindUnsigned; break; case DXGI_FORMAT_R32G32B32A32_SINT: d.x = 32; d.y = 32; d.z = 32; d.w = 32; d.f  $\\leftrightarrow =$  cudaChannelFormatKindSigned; break; case DXGI_FORMAT_R32G32B32A32_FLOAT: d.x = 32; d.y = 32; d.z = 32; d.w = 32; d.f  $\\leftrightarrow =$  cudaChannelFormatKindFloat; break; default: assert(0);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.4 Mapping Mipmaped Arrays onto Imported Memory Objects - return d cudaExtent getCudaExt...",
    "content": "return d; cudaExtent getCudaExtentForD3D12Extent(UINT74 width, UINT height, UINT16  $\\leftrightarrow$  depthOrArraySize, D3D12_SRV_DIMENSION d3d12SRVDimension) { cudaExtent e = {0,0,0}; switch (d3d12SRVDimension) { case D3D12_SRV_DIMENSION_TEXTURE1D: e.width = width; e.height = 0; e.  $\\leftrightarrow$  depth = 0; break; case D3D12_SRV_DIMENSION_TEXTURE2D: e.width = width; e.height = height; e.  $\\leftrightarrow$  depth = 0; break; case D3D12_SRV_DIMENSION_TEXTURE3D: e.width = width; e.height = height; e.  $\\leftrightarrow$  depth = depthOrArraySize; break; case D3D12_SRV_DIMENSION_TEXTURECUBE: e.width = width; e.height = height; e.  $\\leftrightarrow$  depth = depthOrArraySize; break; case D3D12_SRV_DIMENSION_TEXTURE1DARRAY: e.width = width; e.height = 0; e."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.4 Mapping Mipmaped Arrays onto Imported Memory Objects - leftrightarrow  depth  depthOr...",
    "content": "  $\\leftrightarrow$  depth = depthOrArraySize; break; case D3D12_SRV_DIMENSION_TEXTURE2DARRAY: e.width = width; e.height = height; e.  $\\leftrightarrow$  depth = depthOrArraySize; break; case D3D12_SRV_DIMENSION_TEXTURECUBEARRAY: e.width = width; e.height = height; e."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.4 Mapping Mipmaped Arrays onto Imported Memory Objects - leftrightarrow  depth  depthOr...",
    "content": "  $\\leftrightarrow$  depth = depthOrArraySize; break; default: assert(0); } return e; } unsigned int getCudaMipmappedArrayFlagsForD3D12Resource(D3D12_SRV_DIMENSION  $\\leftrightarrow$  d3d12SRVDimension, D3D12_RESOURCE_FLAGS d3d12ResourceFlags, bool  $\\leftrightarrow$  allowSurfaceLoadStore) { unsigned int flags = 0; switch (d3d12SRVDimension) { case D3D12_SRV_DIMENSION_TEXTURECUBE: flags |= cudaArrayCubemap; break; case D3D12_SRV_DIMENSION_TEXTURECUBEARRAY: flags |= cudaArrayCubemap  $\\leftrightarrow$  cudaArrayLayered; break; case D3D12_SRV_DIMENSION_TEXTURE1DARRAY: flags |= cudaArrayLayered; break; default: break; } if (d3d12ResourceFlags & D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET) {"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.4 Mapping Mipmaped Arrays onto Imported Memory Objects - flags  cudaArrayColorAttachmen...",
    "content": "flags |= cudaArrayColorAttachment;  }  if (allowSurfaceLoadStore) {      flags |= cudaArraySurfaceLoadStore;  }  return flags;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.5 Importing Synchronization Objects - A shareable Direct3D 12 fence ...",
    "content": "A shareable Direct3D 12 fence object, created by setting the flag D3D12_FENCE_FLAG_SHARED in the call to ID3D12Device::CreateFence, can be imported into CUDA using the NT handle associated with that object as shown below. Note that it is the application's responsibility to close the handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying semaphore can be freed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.5 Importing Synchronization Objects - cudaExternalSemaphoret importD......A shareable Direct3D 12 fence ...",
    "content": "cudaExternalSemaphore_t importD3D12FenceFromNTHandle(HANDLE handle) {      cudaExternalSemaphore_t extSem = NULL;      cudaExternalSemaphoreHandleDesc desc = {};      memset(&desc, 0, sizeof(desc));      desc.type = cudaExternalSemaphoreHandleTypeD3D12Fence;      desc.handle32. handle = handle;      cudaImportExternalSemaphore(&extSem, &desc);      // Input parameter 'handle' should be closed if it's not needed anymore      CloseHandle(handle);      return extSem;  }\n\nA shareable Direct3D 12 fence object can also be imported using a named handle if one exists as shown below."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.5 Importing Synchronization Objects - cudaExternalSemaphoret importD...",
    "content": "cudaExternalSemaphore_t importD3D12FenceFromNamedNTHandle(LPCWSTR name) {      cudaExternalSemaphore_t extSem = NULL;      cudaExternalSemaphoreHandleDesc desc = {};      memset(&desc, 0, sizeof(desc));      desc.type = cudaExternalSemaphoreHandleTypeD3D12Fence;      desc.handle32. name = (void *)name;      cudaImportExternalSemaphore(&extSem, &desc);      return extSem;  }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.6 Signaling/Waiting on Imported Synchronization Objects - An imported Direct3D 12 fence ......void signalExternalSemaphorecu...",
    "content": "An imported Direct3D 12 fence object can be signaled as shown below. Signaling such a fence object sets its value to the one specified. The corresponding wait that waits on this signal must be issued in Direct3D 12. Additionally, the wait that waits on this signal must be issued after this signal has been issued.\n\nvoid signalExternalSemaphore(cudaExternalSemaphore_t extSem, unsigned long long value,  $\\rightarrow$  cudaStream_t stream) { cudaExternalSemaphoreSignalParams params  $=$  {}; memset(&params, 0, sizeof(params)); params.params.fence.value  $=$  value; cudaSignalExternalSemaphoresAsync(&extSem, &params, 1, stream); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.3.6 Signaling/Waiting on Imported Synchronization Objects - An imported Direct3D 12 fence ......void waitExternalSemaphorecuda...",
    "content": "An imported Direct3D 12 fence object can be waited on as shown below. Waiting on such a fence object waits until its value becomes greater than or equal to the specified value. The corresponding signal that this wait is waiting on must be issued in Direct3D 12. Additionally, the signal must be issued before this wait can be issued.\n\nvoid waitExternalSemaphore(cudaExternalSemaphore_t extSem, unsigned long long value,  $\\rightarrow$  cudaStream_t stream) { cudaExternalSemaphoreWaitParams params  $=$  {}; memset(&params, 0, sizeof(params)); params.params.fence.value  $=$  value; cudaWaitExternalSemaphoresAsync(&extSem, &params, 1, stream); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4 Direct3D 11 Interoperability",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.1 Matching Device LUIDs - When importing memory and sync......continues on next page",
    "content": "When importing memory and synchronization objects exported by Direct3D 11, they must be imported and mapped on the same device as they were created on. The CUDA device that corresponds to the Direct3D 11 device on which the objects were created can be determined by comparing the LUID of a CUDA device with that of the Direct3D 11 device, as shown in the following code sample.\n\nint getCudaDeviceForD3D11Device(TD3D11Device \\*d3d11Device) { IDXGIDevice \\*dxgiDevice; d3d11Device- >QueryInterface(__uuidof(IDXGIDevice), (void \\*\\*)&dxgiDevice); IDXGIA adapter \\*dxgiAdapter; dxgiDevice- >GetAdapter(&dxgiAdapter); DXGI_ADAPTER_DESC dxgiAdapterDesc; dxgiAdapter- >GetDesc(&dxgiAdapterDesc); LUID d3d11Luid  $=$  dxgiAdapterDesc. AdapterLuid;\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.1 Matching Device LUIDs - int cudaDeviceCount cudaGetDev...",
    "content": "int cudaDeviceCount; cudaGetDeviceCount(&cudaDeviceCount); for (int cudaDevice  $= \\theta$  ; cudaDevice  $<$  cudaDeviceCount; cudaDevice++) { cudaDeviceProp deviceProp; cudaGetDeviceProperties(&deviceProp, cudaDevice); char \\*cudaLuid  $=$  deviceProp.luid; if (!mecmp(&d3d11Luid.LowPart, cudaLuid, sizeof(d3d11Luid.LowPart)) && !mecmp(&d3d11Luid.HighPart, cudaLuid  $^+$  sizeof(d3d11Luid.LowPart),  $\\rightarrow$  sizeof(d3d11Luid.HighPart))) { return cudaDevice; } } return cudaInvalidDeviceId; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.2 Importing Memory Objects - A shareable Direct3D 11 textur...",
    "content": "A shareable Direct3D 11 texture resource, viz, ID3D11Texture1D, ID3D11Texture2D or ID3D11Texture3D, can be created by setting either the D3D11_RESOURCE_MISC_SHARED or D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX (on Windows 7) or D3D11_RESOURCE_MISC_SHARED_NTHANDLE (on Windows 10) when calling ID3D11Device:CreateTexture1D, ID3D11Device:CreateTexture2D or ID3D11Device:CreateTexture3D respectively. A shareable Direct3D 11 buffer resource, ID3D11Buffer, can be created by specifying either of the above flags when calling ID3D11Device::CreateBuffer. A shareable resource created by specifying the D3D11_RESOURCE_MISC_SHARED_NTHANDLE can be imported into CUDA using the NT handle associated with that object as shown below."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.2 Importing Memory Objects - Note that it is the applicatio...",
    "content": " Note that it is the application's responsibility to close the NT handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying memory can be freed. When importing a Direct3D 11 resource, the flag cudaExternalMemoryDedicated must be set."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.2 Importing Memory Objects - cudaExternalMemoryt importD3D1......A shareable Direct3D 11 resour...",
    "content": "cudaExternalMemory_t importD3D11ResourceFromNTHandle(HANDLE handle, unsigned long  $\\rightarrow$  long size) { cudaExternalMemory_t extMem  $=$  NULL; cudaExternalMemoryHandleDesc desc  $=$  {}; memset(&desc, 0, sizeof(desc)); desc.type  $=$  cudaExternalMemoryHandleTypeD3D11Resource; desc.handle.win32. handle  $=$  (void \\*)handle; desc.size  $=$  size; desc.flags  $| =$  cudaExternalMemoryDedicated; cudaImportExternalMemory(&extMem, &desc); // Input parameter 'handle' should be closed if it's not needed anymore CloseHandle(handle); return extMem; }\n\nA shareable Direct3D 11 resource can also be imported using a named handle if one exists as shown below."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.2 Importing Memory Objects - cudaExternalMemoryt importD3D1...",
    "content": "cudaExternalMemory_t importD3D11ResourceFromNamedNThandle(LPCWSTR name, unsigned long  $\\rightarrow$  long size){ cudaExternalMemory_t extMem  $=$  NULL; cudaExternalMemoryHandleDesc desc  $=$  {}; memset(&desc, 0, sizeof(desc)); desc.type  $=$  cudaExternalMemoryHandleTypeD3D11Resource; desc.handle.win32. name  $=$  (void \\*)handle; desc.size  $=$  size; desc.flags  $| =$  cudaExternalMemoryDedicated; cudaImportExternalMemory(&extMem, &desc); return extMem; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.2 Importing Memory Objects - A shareable Direct3D 11 resour...",
    "content": "A shareable Direct3D 11 resource, created by specifying the D3D11_RESOURCE_MISC_SHARED or D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX, can be imported into CUDA using the globally shared D3DKMT handle associated with that object as shown below. Since a globally shared D3DKMT handle does not hold a reference to the underlying memory it is automatically destroyed when all other references to the resource are destroyed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.2 Importing Memory Objects - cudaExternalMemoryt importD3D1...",
    "content": "cudaExternalMemory_t importD3D11ResourceFromKMTHandle(HANDLE handle, unsigned long  $\\rightarrow$  long size){ cudaExternalMemoryHandleDesc desc  $=$  {}; memset(&desc, 0, sizeof(desc)); desc.type  $=$  cudaExternalMemoryHandleTypeD3D11ResourceKmt; desc.handle.win32. handle  $=$  (void \\*)handle; desc.size  $=$  size; desc.flags  $| =$  cudaExternalMemoryDedicated; cudaImportExternalMemory(&extMem, &desc); return extMem; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.3 Mapping Buffers onto Imported Memory Objects - A device pointer can be mapped......descoffset  offset  descsize  ...",
    "content": "# 6.2.16.4.3 Mapping Buffers onto Imported Memory Objects\nA device pointer can be mapped onto an imported memory object as shown below. The offset and size of the mapping must match that specified when creating the mapping using the corresponding Direct3D 11 API. All mapped device pointers must be freed using cudaFree().\n\nvoid \\* mapBufferOntoExternalMemory(cudaExternalMemory_t extMem, unsigned long long  $\\rightarrow$  offset, unsigned long long size){ void \\*ptr  $=$  NULL; cudaExternalMemoryBufferDesc desc  $=$  {}; memset(&desc, 0, sizeof(desc));\n\n(continues on next page)\n\ndesc.offset = offset;  desc.size = size;  cudaExternalMemoryGetMappedBuffer(&ptr, extMem, &desc);  // Note: 'ptr' must eventually be freed using cudaFree()  return ptr;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.4 Mapping Mipmapped Arrays onto Imported Memory Objects - A CUDA mipmaped array can be m...",
    "content": "A CUDA mipmaped array can be mapped onto an imported memory object as shown below. The offset, dimensions, format and number of mip levels must match that specified when creating the mapping using the corresponding Direct3D 11 API. Additionally, if the mipmaped array can be bound as a render target in Direct3D 12, the flag cudaArrayColorAttachment must be set. All mapped mipmaped arrays must be freed using cudaFreeMipmapedArray(). The following code sample shows how to convert Direct3D 11 parameters into the corresponding CUDA parameters when mapping mipmaped arrays onto imported memory objects."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.4 Mapping Mipmapped Arrays onto Imported Memory Objects - cudaMipmappedArrayt mapMipmapp...",
    "content": "cudaMipmappedArray_t mapMipmappedArrayOntoExternalMemory(cudaExternalMemory_t extMem, unsigned long offset, cudaChannelFormatDesc \\*formatDesc, cudaExtent \\*extent, unsigned int flags, unsigned int numLevels) { cudaMipmappedArray_t mipmap  $=$  NULL; cudaExternalMemoryMipmappedArrayDesc desc  $=$  {}; memset(&desc, 0, sizeof(desc)); desc.offset  $=$  offset; desc.formatDesc  $=$  \\*formatDesc; desc.extension  $=$  \\*extent; desc.flags  $=$  flags; desc."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.4 Mapping Mipmapped Arrays onto Imported Memory Objects - numLevels    numLevels  Note m...",
    "content": "numLevels  $=$  numLevels; // Note: 'mipmap' must eventually be freed using cudaFreeMipmappedArray() cudaExternalMemoryGetMappedMipmappedArray(&mipmap, extMem, &desc); return mipmap; } cudaChannelFormatDesc getCudaChannelFormatDescForDxgiFormat(DxGI_FORMAT dxgiFormat) { cudaChannelFormatDesc d; memset(&d, 0, sizeof(d)); switch (dxgiFormat) { case DXGI_FORMAT_R8_UINT:  $\\texttt{d.x = 8}$  ;  $\\texttt{d.y = 0}$  ;  $\\texttt{d.z = 0}$  ;  $\\texttt{d.w = 0}$  ; d.f  $\\rightharpoondown$  cudaChannelFormatKindUnsigned; break; case DXGI_FORMAT_R8_SINT:  $\\texttt{d.x = 8}$  ;  $\\texttt{d.y = 0}$  ;  $\\texttt{d.z = 0}$  ;  $\\texttt{d.w = 0}$  ; d.f  $\\rightharpoondown$  cudaChannelFormatKindSigned; break; case DXGI_FORMAT_R8G8_UINT:  $\\texttt{d.x = 8}$  ;  $\\texttt{d.y = 8}$  ;  $\\texttt{d."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.4 Mapping Mipmapped Arrays onto Imported Memory Objects - z  0    textttdw  0   df  righ...",
    "content": "z = 0}$  ;  $\\texttt{d.w = 0}$  ; d.f  $\\rightharpoondown$  cudaChannelFormatKindUnsigned; break; case DXGI_FORMAT_R8G8SINT:  $\\texttt{d.x = 8}$  ;  $\\texttt{d.y = 8}$  ;  $\\texttt{d.z = 0}$  ;  $\\texttt{d.w = 0}$  ; d.f  $\\rightharpoondown$  cudaChannelFormatKindSigned; break; case DXGI_FORMAT_R8G8B8A8_UINT:  $\\texttt{d.x = 8}$  ;  $\\texttt{d.y = 8}$  ;  $\\texttt{d.z = 8}$  ;  $\\texttt{d.w = 8}$  ; d.f  $\\rightharpoondown$  cudaChannelFormatKindUnsigned; break; (continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.4 Mapping Mipmapped Arrays onto Imported Memory Objects - continued from previous page",
    "content": "(continued from previous page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.4 Mapping Mipmapped Arrays onto Imported Memory Objects - case DXGIFORMATR6G8B8A8SINT  t...",
    "content": "case DXGI_FORMAT_R6G8B8A8_SINT:  $\\texttt{d.x = 8}$  .  $\\texttt{d.y = 8}$  .  $\\texttt{d.z = 8}$  .  $\\texttt{d.w = 8}$  .  $\\texttt{d.f}$ $\\leftrightarrow =$  cudaChannelFormatKindSigned; break; case DXGI_FORMAT_R16_UINT:  $\\texttt{d.x = 16}$  .  $\\texttt{d.y = 0}$  .  $\\texttt{d.z = 0}$  .  $\\texttt{d.w = 0}$  .  $\\texttt{d.f}$ $\\leftrightarrow =$  cudaChannelFormatKindUnsigned; break; case DXGI_FORMAT_R16_SINT:  $\\texttt{d.x = 16}$  .  $\\texttt{d.y = 0}$  .  $\\texttt{d.z = 0}$  .  $\\texttt{d.w = 0}$  .  $\\texttt{d.f}$ $\\leftrightarrow =$  cudaChannelFormatKindSigned; break; case DXGI_FORMAT_R16G16_UINT:  $\\texttt{d.x = 16}$  .  $\\texttt{d.y = 16}$  .  $\\texttt{d.z = 0}$  .  $\\texttt{d.w = 0}$  .  $\\texttt{d."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.4 Mapping Mipmapped Arrays onto Imported Memory Objects - f leftrightarrow   cudaChannel...",
    "content": "f}$ $\\leftrightarrow =$  cudaChannelFormatKindUnsigned; break; case DXGI_FORMAT_R16G16B16A16_UINT:  $\\texttt{d.x = 16}$  .  $\\texttt{d.y = 16}$  .  $\\texttt{d.z = 16}$  .  $\\texttt{d.w = 16}$  .  $\\texttt{d.f}$ $\\leftrightarrow =$  cudaChannelFormatKindUnsigned; break; case DXGI_FORMAT_R16G16B16A16_SINT:  $\\texttt{d.x = 16}$  .  $\\texttt{d.y = 16}$  .  $\\texttt{d.z = 16}$  .  $\\texttt{d.w = 16}$  .  $\\texttt{d.f}$ $\\leftrightarrow =$  cudaChannelFormatKindSigned; break; case DXGI_FORMAT_R32_UINT:  $\\texttt{d.x = 32}$  .  $\\texttt{d.y = 0}$  .  $\\texttt{d.z = 0}$  .  $\\texttt{d.w = 0}$  .  $\\texttt{d.f}$ $\\leftrightarrow =$  cudaChannelFormatKindUnsigned; break; case DXGI_FORMAT_R32_SINT:  $\\texttt{d.x = 32}$  .  $\\texttt{d.y = 0}$  .  $\\texttt{d.z = 0}$  .  $\\texttt{d.w = 0}$  ."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.4 Mapping Mipmapped Arrays onto Imported Memory Objects - textttdf leftrightarrow   cuda...",
    "content": "  $\\texttt{d.f}$ $\\leftrightarrow =$  cudaChannelFormatKindSigned; break; case DXGI_FORMAT_R32_FLOAT:  $\\texttt{d.x = 32}$  .  $\\texttt{d.y = 0}$  .  $\\texttt{d.z = 0}$  .  $\\texttt{d.w = 0}$  .  $\\texttt{d.f}$ $\\leftrightarrow =$  cudaChannelFormatKindFloat; break; case DXGI_FORMAT_R32G32_UINT:  $\\texttt{d.x = 32}$  .  $\\texttt{d.y = 32}$  .  $\\texttt{d.z = 0}$  .  $\\texttt{d.w = 0}$  .  $\\texttt{d.f}$ $\\leftrightarrow =$  cudaChannelFormatKindUnsigned; break; case DXGI_FORMAT_R32G32_SINT:  $\\texttt{d.x = 32}$  .  $\\texttt{d.y = 32}$  .  $\\texttt{d.z = 0}$  .  $\\texttt{d.w = 0}$  .  $\\texttt{d.f}$ $\\leftrightarrow =$  cudaChannelFormatKindSigned; break; case DXGI_FORMAT_R32G32_FLOAT:  $\\texttt{d.x = 32}$  .  $\\texttt{d.y = 32}$  .  $\\texttt{d.z = 0}$  .  $\\texttt{d.w = 0}$  .  $\\texttt{d."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.4 Mapping Mipmapped Arrays onto Imported Memory Objects - f leftrightarrow   cudaChannel...",
    "content": "f}$ $\\leftrightarrow =$  cudaChannelFormatKindFloat; break; case DXGI_FORMAT_R32G32B32A32_UINT:  $\\texttt{d.x = 32}$  .  $\\texttt{d.y = 32}$  .  $\\texttt{d.z = 32}$  .  $\\texttt{d.w = 32}$  .  $\\texttt{d.f}$ $\\leftrightarrow =$  cudaChannelFormatKindUnsigned; break; case DXGI_FORMAT_R32G32B32A32_SINT:  $\\texttt{d.x = 32}$  .  $\\texttt{d.y = 32}$  .  $\\texttt{d.z = 32}$  .  $\\texttt{d.w = 32}$  .  $\\texttt{d.f}$ $\\leftrightarrow =$  cudaChannelFormatKindSigned; break; case DXGI_FORMAT_R32G32B32A32_FLOAT:  $\\texttt{d.x = 32}$  .  $\\texttt{d.y = 32}$  .  $\\texttt{d.z = 32}$  .  $\\texttt{d.w = 32}$  .  $\\texttt{d.f}$ $\\leftrightarrow =$  cudaChannelFormatKindFloat; break; default: assert(0); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.4 Mapping Mipmapped Arrays onto Imported Memory Objects - return d...cudaExtent getcudaExtentForD3D...",
    "content": "return d; }\n\ncudaExtent getcudaExtentForD3D11Extent(UINT64 width, UINT height, UINT16 depthOrArraySize, D3D12_SRV_DIMENSION d3d11SRVDimension) { cudaExtent e = {0, 0, 0};"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.4 Mapping Mipmapped Arrays onto Imported Memory Objects - switch d3d11SRVDimension  case...",
    "content": "switch (d3d11SRVDimension) { case D3D11_SRV_DIMENSION_TEXTURE1D: e.width = width; e.height = 0; e. depth = 0; break; case D3D11_SRV_DIMENSION_TEXTURE2D: e.width = width; e.height = height; e. depth = 0; break; case D3D11_SRV_DIMENSION_TEXTURE3D: e.width = width; e.height = height; e. depth = depthOrArraySize; break; case D3D11_SRV_DIMENSION_TEXTURECUBE: e.width = width; e.height = height; e. depth = depthOrArraySize; break; case D3D11_SRV_DIMENSION_TEXTURE1DARRAY: e.width = width; e.height = 0; e. depth = depthOrArraySize; break; case D3D11_SRV_DIMENSION_TEXTURE2DARRAY: e.width = width; e.height = height; e. depth = depthOrArraySize; break; case D3D11_SRV_DIMENSION_TEXTURECUBEARRAY: e.width = width; e.height = height; e. depth = depthOrArraySize; break;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.4 Mapping Mipmapped Arrays onto Imported Memory Objects - default assert0  return e  uns...",
    "content": "default: assert(0); } return e; } unsigned int getCudaMipmappedArrayFlagsForD3D12Resource(D3D11_SRV_DIMENSION  $\\rightarrow$  d3d11SRvDimension, D3D11_BIND_FLAG d3d11BindFlags, bool allowSurfaceLoadStore) { unsigned int flags  $= \\theta$  ."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.4 Mapping Mipmapped Arrays onto Imported Memory Objects - switch d3d11SRvDimension  case...",
    "content": " switch (d3d11SRvDimension) { case D3D11_SRV_DIMENSION_TEXTURECUBE: flags  $| =$  cudaArrayCubemap;  $\\rightarrow$  break; case D3D11_SRV_DIMENSION_TEXTURECUBEARRAY: flags  $| =$  cudaArrayCubemap  $\\parallel$ $\\rightarrow$  cudaArrayLayered; break; case D3D11_SRV_DIMENSION_TEXTURE1DARRAY: flags  $| =$  cudaArrayLayered;  $\\rightarrow$  break; case D3D11_SRV_DIMENSION_TEXTURE2DARRAY: flags  $| =$  cudaArrayLayered;  $\\rightarrow$  break; default: break; } if (d3d11BindFlags & D3D11_BIND_RENDER_TARGET) { flags  $| =$  cudaArrayColorAttachment; } if (allowSurfaceLoadStore) { flags  $| =$  cudaArraySurfaceLoadStore; } return flags; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.5 Importing Synchronization Objects - A shareable Direct3D 11 fence ...",
    "content": "A shareable Direct3D 11 fence object, created by setting the flag D3D11_FENCE_FLAG_SHARED in the call to ID3D11Device5::CreateFence, can be imported into CUDA using the NT handle associated with that object as shown below. Note that it is the application's responsibility to close the handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying semaphore can be freed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.5 Importing Synchronization Objects - cudaExternalSemaphoret importD......A shareable Direct3D 11 fence ...",
    "content": "cudaExternalSemaphore_t importD3D11FenceFromNtHandle(HANDLE handle) { cudaExternalSemaphore_t extSem  $=$  NULL; cudaExternalSemaphoreHandleDesc desc  $=$  {}; memset(&desc, 0, sizeof(desc)); desc.type  $=$  cudaExternalSemaphoreHandleTypeD3D11Fence; desc.handle3. win32. handle  $=$  handle; cudaImportExternalSemaphore(&extSem, &desc); // Input parameter 'handle' should be closed if it's not needed anymore CloseHandle(handle);\n\nreturn extSem; }\n\nA shareable Direct3D 11 fence object can also be imported using a named handle if one exists as shown below."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.5 Importing Synchronization Objects - cudaExternalSemaphoret importD...",
    "content": "cudaExternalSemaphore_t importD3D11FenceFromNamedNThandle(LPCWSTR name) {    cudaExternalSemaphore_t extSem = NULL;    cudaExternalSemaphoreHandleDesc desc = {};    memset(&desc, 0, sizeof(desc));    desc.type = cudaExternalSemaphoreHandleTypeD3D11Fence;    desc.handle32. name = (void *)name;    cudaImportExternalSemaphore(&extSem, &desc);    return extSem;}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.5 Importing Synchronization Objects - A shareable Direct3D 11 keyed ...",
    "content": "A shareable Direct3D 11 keyed mutex object associated with a shareable Direct3D 11 resource, viz, IDXGIKeyedMutex, created by setting the flag D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX, can be imported into CUDA using the NT handle associated with that object as shown below. Note that it is the application's responsibility to close the handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying semaphore can be freed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.5 Importing Synchronization Objects - cudaExternalSemaphoret importD......A shareable Direct3D 11 keyed ...",
    "content": "cudaExternalSemaphore_t importD3D11KeyedMutexFromNThandle(HANDLE handle) {    cudaExternalSemaphore_t extSem = NULL;    cudaExternalSemaphoreHandleDesc desc = {};    memset(&desc, 0, sizeof(desc));    desc.type = cudaExternalSemaphoreHandleTypeKeyedMutex;    desc.handle32. handle = handle;    cudaImportExternalSemaphore(&extSem, &desc);    // Input parameter 'handle' should be closed if it's not needed anymore    CloseHandle(handle);    return extSem;}\n\nA shareable Direct3D 11 keyed mutex object can also be imported using a named handle if one exists as shown below."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.5 Importing Synchronization Objects - cudaExternalSemaphoret importD......A shareable Direct3D 11 keyed ...",
    "content": "cudaExternalSemaphore_t importD3D11KeyedMutexFromNamedNThandle(LPCWSTR name) {    cudaExternalSemaphore_t extSem = NULL;    cudaExternalSemaphoreHandleDesc desc = {};    memset(&desc, 0, sizeof(desc));    desc.type = cudaExternalSemaphoreHandleTypeKeyedMutex;    desc.handle32. name = (void *)name;\n\ncudaImportExternalSemaphore(&extSem, &desc);return extSem;\n\nA shareable Direct3D 11 keyed mutex object can be imported into CUDA using the globally shared D3DKMT handle associated with that object as shown below. Since a globally shared D3DKMT handle does not hold a reference to the underlying memory it is automatically destroyed when all other references to the resource are destroyed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.5 Importing Synchronization Objects - cudaExternalSemaphoret importD...",
    "content": "cudaExternalSemaphore_t importD3D11FenceFromKMTHandle(HANDLE handle) {    cudaExternalSemaphore_t extSem = NULL;    cudaExternalSemaphoreHandleDesc desc = {};    memset(&desc, 0, sizeof(desc));    desc.type = cudaExternalSemaphoreHandleTypeKeyedMutex;    desc.handleWin32. handle = handle;    cudaImportExternalSemaphore(&extSem, &desc);    // Input parameter 'handle' should be closed if it's not needed anymore    CloseHandle(handle);    return extSem;}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.6 Signaling/Waiting on Imported Synchronization Objects - An imported Direct3D 11 fence ......void signalExternalSemaphorecu...",
    "content": "An imported Direct3D 11 fence object can be signaled as shown below. Signaling such a fence object sets its value to the one specified. The corresponding wait that waits on this signal must be issued in Direct3D 11. Additionally, the wait that waits on this signal must be issued after this signal has been issued.\n\nvoid signalExternalSemaphore(cudaExternalSemaphore_t extSem, unsigned long long value, cudaStream_t stream) {    cudaExternalSemaphoreSignalParams params = {};    memset(&params, 0, sizeof(params));    params.params.fence.value = value;    cudaSignalExternalSemaphoresAsync(&extSem, &params, 1, stream);}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.6 Signaling/Waiting on Imported Synchronization Objects - An imported Direct3D 11 fence ......memsetparams 0 sizeofparams  p...",
    "content": "An imported Direct3D 11 fence object can be waited on as shown below. Waiting on such a fence object waits until its value becomes greater than or equal to the specified value. The corresponding signal that this wait is waiting on must be issued in Direct3D 11. Additionally, the signal must be issued before this wait can be issued.\n\nvoid waitExternalSemaphore(cudaExternalSemaphore_t extSem, unsigned long long value, cudaStream_t stream) {    cudaExternalSemaphoreWaitParams params = {};\n\n(continued from previous page)\n\nmemset(&params, 0, sizeof(params));  params.params.fence.value = value;  cudaWaitExternalSemaphoreAsync(&extSem, &params, 1, stream);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.6 Signaling/Waiting on Imported Synchronization Objects - An imported Direct3D 11 keyed ......void signalExternalSemaphorecu...",
    "content": "An imported Direct3D 11 keyed mutex object can be signaled as shown below. Signaling such a keyed mutex object by specifying a key value releases the keyed mutex for that value. The corresponding wait that waits on this signal must be issued in Direct3D 11 with the same key value. Additionally, the Direct3D 11 wait must be issued after this signal has been issued.\n\nvoid signalExternalSemaphore(cudaExternalSemaphore_t extSem, unsigned long long key, cudaStream_t stream) {  cudaExternalSemaphoreSignalParams params = {};  memset(&params, 0, sizeof(params));  params.params.keyedmutex.key = key;  cudaSignalExternalSemaphoreAsync(&extSem, &params, 1, stream);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.6 Signaling/Waiting on Imported Synchronization Objects - An imported Direct3D 11 keyed ...",
    "content": "An imported Direct3D 11 keyed mutex object can be waited on as shown below. A timeout value in milliseconds is needed when waiting on such a keyed mutex. The wait operation waits until the keyed mutex value is equal to the specified key value or until the timeout has elapsed. The timeout interval can also be an infinite value. In case an infinite value is specified the timeout never elapses. The windows INFINITE macro must be used to specify an infinite timeout. The corresponding signal that this wait is waiting on must be issued in Direct3D 11. Additionally, the Direct3D 11 signal must be issued before this wait can be issued."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.4.6 Signaling/Waiting on Imported Synchronization Objects - void waitExternalSemaphorecuda...",
    "content": "void waitExternalSemaphore(cudaExternalSemaphore_t extSem, unsigned long long key, unsigned int timeoutMs, cudaStream_t stream) {  cudaExternalSemaphoreWaitParams params = {};  memset(&params, 0, sizeof(params));  params.params.keyedmutex.key = key;  params.params.keyedmutex.timeoutMs = timeoutMs;  cudaWaitExternalSemaphoreAsync(&extSem, &params, 1, stream);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5. NVIDIA Software Communication Interface Interoperability (NVSCI) - NvSciBuf and NvSciSync are int......More details on these interfac...",
    "content": "NvSciBuf and NvSciSync are interfaces developed for serving the following purposes:\n\n- NvSciBuf: Allows applications to allocate and exchange buffers in memory  \n- NvSciSync: Allows applications to manage synchronization objects at operation boundaries\n\nMore details on these interfaces are available at: https://docs.nvidia.com/drive."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.1 Importing Memory Objects - For allocating an NvSciBuf obj...",
    "content": "For allocating an NvSciBuf object compatible with a given CUDA device, the corresponding GPU id must be set with NvSciBufGeneralAttrKey_GpuId in the NvSciBuf attribute list as shown below. Optionally, applications can specify the following attributes -"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.1 Importing Memory Objects - NvSciBufGeneralAttrKeyNeedCpuA...",
    "content": "NvSciBufGeneralAttrKey_NeedCpuAccess: Specifies if CPU access is required for the buffer NvSciBufRawBufferAttrKey_Align: Specifies the alignment requirement of NvSciBufType_RawBuffer NvSciBufGeneralAttrKey_RequiredPerm: Different access permissions can be configured for different UMDs per NvSciBuf memory object instance. For example, to provide the GPU with read- only access permissions to the buffer, create a duplicate NvSciBuf object using NvSciBufObjDupWithReducePerm() with NvSciBufAccessPerm_Readonly as the input parameter. Then import this newly created duplicate object with reduced permission into CUDA as shown NvSciBufGeneralAttrKey_EnableGpuCache: To control GPU L2 cacheability NvSciBufGeneralAttrKey_EnableGpuCompression: To specify GPU compression"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.1 Importing Memory Objects - The following code snippet ill...",
    "content": "Note: For more details on these attributes and their valid input options, refer to NvSciBuf Documentation.\n\nThe following code snippet illustrates their sample usage."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.1 Importing Memory Objects - NvSciBufObj createNvSciBufObje...",
    "content": "NvSciBufObj createNvSciBufObject() { // Raw Buffer Attributes for CUDA NvSciBufType bufType  $=$  NvSciBufType_RawBuffer; uint64_t rawsize  $=$  SIZE; uint64_t align  $= 0$  . bool cpuaccess_flag  $=$  true; NvSciBufAttrValAccessPerm perm  $=$  NvSciBufAccessPerm_ReadWrite; NvSciRmGpuId gpuid[]  $=\\{\\}$  CUuuid uuid; cuDeviceGetUuid(&uuid, dev)); memcpy(&gpuid[0].bytes, &uuid.bytes, sizeof(uuid."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.1 Importing Memory Objects - bytes  Disable cache on dev Nv...",
    "content": "bytes)); // Disable cache on dev NvSciBufAttrValGpuCache gpuCache[]  $=$  {{gpuid[0], false}}; NvSciBufAttrValGpuCompression gpuCompression[]  $=$  {{gpuid[0], NvSciBufCompressionType_GenericCompressible}}; // Fill in values NvSciBufAttrKeyValuePair rawbuffattrs[]  $=$  { { NvSciBufGeneralAttrKey_Types, &bufType, sizeof(bufType) }, { NvSciBufRawBufferAttrKey_Size, &rawsize, sizeof(rawsize) }, { NvSciBufRawBufferAttrKey_Align, &align, sizeof(align) }, { NvSciBufGeneralAttrKey_NeedCpuAccess, &cpuaccess_flag, sizeof(cpuaccess_ flag) } { NvSciBufGeneralAttrKey_RequiredPerm, &perm, sizeof(perm) }, { NvSciBufGeneralAttrKey_GpuId, &gpuid, sizeof(gpuid) }, { NvSciBufGeneralAttrKey_EnableGpuCache &gpuCache, sizeof(gpuCache) }, { NvSciBufGeneralAttrKey_EnableGpuCompression &gpuCompression, sizeof(gp"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.1 Importing Memory Objects - uCompression",
    "content": "uCompression) } };"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.1 Importing Memory Objects - continued from previous page...NvSciBufObj bufferObjRo  Reado...",
    "content": "(continued from previous page)\n\n// Create list by setting attributeserr = NvSciBufAttrListSetAttrs(attrListBuffer, rawbuffattrs, sizeof(rawbuffattrs)/sizeof(NvSciBufAttrKeyValuePair));NvSciBufAttrListCreate(NvSciBufModule, &attrListBuffer);// Reconcile And AllocateNvSciBufAttrListReconcile(&attrListBuffer, 1, &attrListReconciledBuffer, &attrListConflistBuffer);NvSciBufObjAlloc(attrListReconciledBuffer, &bufferObjRaw);return bufferObjRaw;\n\nNvSciBufObj bufferObjRo; // Readonly NvSciBuf memory obj// Create a duplicate handle to the same memory buffer with reduced permissionsNvSciBufObjDupWithReducePerm(bufferObjRaw, NvSciBufAccessPerm_Readonly, &bufferObjRo);return bufferObjRo;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.1 Importing Memory Objects - The allocated NvSciBuf memory ......Note For more details on how t...",
    "content": "The allocated NvSciBuf memory object can be imported in CUDA using the NvSciBufObj handle as shown below. Application should query the allocated NvSciBufObj for attributes required for filling CUDA External Memory Descriptor. Note that the attribute list and NvSciBuf objects should be maintained by the application. If the NvSciBuf object imported into CUDA is also mapped by other drivers, then based on NvSciBufGeneralAttrKey_GpuSwNeedCacheCoherency output attribute value the application must use NvSciSync objects (Refer Importing Synchronization Objects) as appropriate barriers to maintain coherence between CUDA and the other drivers.\n\nNote: For more details on how to allocate and maintain NvSciBuf objects refer to NvSciBuf API Documentation."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.1 Importing Memory Objects - cudaExternalMemoryt importNvSc...",
    "content": "cudaExternalMemory_t importNvSciBufObject (NvSciBufObj bufferObjRaw) {"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.1 Importing Memory Objects - cpp Query NvSciBuf Object NvSc...",
    "content": "```cpp/****************************************** Query NvSciBuf Object ***********/NvSciBufAttrKeyValuePair bufattrs[] = {    { NvSciBufRawBufferAttrKey_Size, NULL, 0 },    { NvSciBufGeneralAttrKey_GpuSwNeedCacheCoherency, NULL, 0 },    { NvSciBufGeneralAttrKey_EnableGpuCompression, NULL, 0 }};NvSciBufAttrListGetAttrs(retList, bufattrs, sizeof(bufattrs)/sizeof(NvSciBufAttrKeyValuePair));ret_size = *(static_cast<const uint64_t*>(bufattrs[0].value));// Note cache and compression are per GPU attributes, so read values for specific *gpu by comparing UUID// Read cacheability granted by NvSciBufint numGpus = bufattrs[1].len / sizeof(NvSciBufAttrValGpuCache);NvSciBufAttrValGpuCache[] cacheVal = (NvSciBufAttrValGpuCache *)bufattrs[1]."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.1 Importing Memory Objects - valuebool retcacheValfor int i...",
    "content": "value;bool ret_cacheVal;for (int i = 0; i < numGpus; i++) {    if (memcmp(gpuid[0].bytes, cacheVal[i].gpuId.bytes, sizeof(CUuuid)) == 0) {        ret_cacheVal = cacheVal[i].cacheability;    }}// Read compression granted by NvSciBuf```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.1 Importing Memory Objects - continues on next page",
    "content": "(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.1 Importing Memory Objects - numGpus    bufattrs2len  sizeo...",
    "content": "numGpus  $=$  bufattrs[2].len / sizeof(NvSciBufAttrValGpuCompression); NvSciBufAttrValGpuCompression[] compVal  $=$  (NvSciBufAttrValGpuCompression  $\\rightarrow^{*}$  )bufattrs[2].value; NvSciBufCompressionType ret_compVal; for (int  $\\texttt{i} = \\texttt{0}$  ; i  $\\epsilon$  numGpus;  $\\dot{1} ++$  ){ if (memcmg(gpuid[0].bytes, compVal[i].gpuId.bytes, sizeof(CUuuid) == 0){ ret_compVal  $=$  compVal[i].compressionType); } } //\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*/ // Fill up CUDA_EXTERNAL_MEMORY_HANDLE_DESC cudaExternalMemoryHandleDesc memHandleDesc; memset(&memHandleDesc, 0, sizeof(memHandleDesc)); memHandleDesc."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.1 Importing Memory Objects - type    cudaExternalMemoryHand...",
    "content": "type  $=$  cudaExternalMemoryHandleTypeNvSciBuf; memHandleDesc.handle.nvSciBufObject  $=$  bufferObjRaw; // Set the NvSciBuf object with required access permissions in this step memHandleDesc.handle.nvSciBufObject  $=$  bufferObjRo; memHandleDesc.size  $=$  ret_size; cudaImportExternalMemory(&extMemBuffer, &memHandleDesc); return extMemBuffer; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.2 Mapping Buffers onto Imported Memory Objects - A device pointer can be mapped......void  mapBufferOntoExternalMem...",
    "content": "# 6.2.16.5.2 Mapping Buffers onto Imported Memory Objects\nA device pointer can be mapped onto an imported memory object as shown below. The offset and size of the mapping can be filled as per the attributes of the allocated NvSciBufObj. All mapped device pointers must be freed using cudaFree().\n\nvoid \\* mapBufferOntoExternalMemory(cudaExternalMemory_t extMem, unsigned long long  $\\hookrightarrow$  offset, unsigned long long size) { void \\*ptr  $=$  NULL; cudaExternalMemoryBufferDesc desc  $=$  {}; memset(&desc, 0, sizeof(desc)); desc.offset  $=$  offset; desc.size  $=$  size; cudaExternalMemoryGetMappedBuffer(&ptr, extMem, &desc); // Note: 'ptr' must eventually be freed using cudaFree() return ptr; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.3 Mapping Mipmapped Arrays onto Imported Memory Objects - 621653 Mapping Mipmapped Array......Note The number of mip levels ...",
    "content": "6.2.16.5.3 Mapping Mipmapped Arrays onto Imported Memory ObjectsA CUDA mipmapbed array can be mapped onto an imported memory object as shown below. The offset, dimensions and format can be filled as per the attributes of the allocated NvSciBufObj. All mapped mipmapbed arrays must be freed using cudaFreeMipmappedArray(). The following code sample shows how to convert NvSciBuf attributes into the corresponding CUDA parameters when mapping mipmapbed arrays onto imported memory objects.\n\nNote: The number of mip levels must be 1."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.3 Mapping Mipmapped Arrays onto Imported Memory Objects - cudaMipmappedArrayt mapMipmapp...",
    "content": "cudaMipmappedArray_t mapMipmappedArrayOntoExternalMemory(cudaExternalMemory_t extMem, unsigned long long offset, cudaChannelFormatDesc \\*formatDesc, cudaExtent \\*extent, unsigned int flags, unsigned int numLevels) { cudaMipmappedArray_t mipmap  $=$  NULL; cudaExternalMemoryMipmappedArrayDesc desc  $=$  {}; memset(&desc, 0, sizeof(desc)); desc.offset  $=$  offset; desc.formatDesc  $=$  \\*formatDesc; desc.extent  $=$  \\*extent; desc.flags  $=$  flags; desc.numLevels  $=$  numLevels; // Note: 'mipmap' must eventually be freed using cudaFreeMipmappedArray() cudaExternalMemoryGetMappedMipmappedArray(&mipmap, extMem, &desc); return mipmap; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.4 Importing Synchronization Objects - NvSciSync attributes that are ...",
    "content": "NvSciSync attributes that are compatible with a given CUDA device can be generated using cudaDe. viceGetNvSciSyncAttributes(). The returned attribute list can be used to create a NvSciSyncObj that is guaranteed compatibility with a given CUDA device."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.4 Importing Synchronization Objects - NvSciSyncObj createNvSciSyncOb......continues on next page",
    "content": "NvSciSyncObj createNvSciSyncObject() { NvSciSyncObj nvSciSyncObj int cudaDev0  $=$  0; int cudaDev1  $=$  1; NvSciSyncAttrList signalerAttrList  $=$  NULL; NvSciSyncAttrList waiterAttrList  $=$  NULL; NvSciSyncAttrList reconciledList  $=$  NULL; NvSciSyncAttrList newConflictList  $=$  NULL; NvSciSyncAttrListCreate(module, &signalerAttrList); NvSciSyncAttrListCreate(module, &waiterAttrList); NvSciSyncAttrList unreconciledList[2]  $=$  {NULL, NULL}; unreconciledList[0]  $=$  signalerAttrList; unreconciledList[1]  $=$  waiterAttrList; cudaDeviceGetNvSciSyncAttributes(signalerAttrList, cudaDev0, CUDA_NVSCISYNC_ATTR_ SIGNAL);\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.4 Importing Synchronization Objects - continued from previous page c......An NvSciSync object created as...",
    "content": "(continued from previous page) cudaDeviceGetNvSciSyncAttributes(waiterAttrList, cudaDev1, CUDA_NVSCISYNC_ATTR_  $\\rightarrow$  WAIT); NvSciSyncAttrListReconcile(unreconciledList, 2, &reconciledList, &  $\\rightarrow$  newConflictList); NvSciSyncObjAlloc(reconciledList, &nvSciSyncObj); return nvSciSyncObj; }\n\nAn NvSciSync object (created as above) can be imported into CUDA using the NvSciSyncObj handle as shown below. Note that ownership of the NvSciSyncObj handle continues to lie with the application even after it is imported."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.4 Importing Synchronization Objects - cudaExternalSemaphoret importN...",
    "content": "cudaExternalSemaphore_t importNvSciSyncObject(void\\* nvSciSyncObj) { cudaExternalSemaphore_t extSem  $=$  NULL; cudaExternalSemaphoreHandleDesc desc  $=$  {}; memset(&desc, 0, sizeof(desc)); desc.type  $=$  cudaExternalSemaphoreHandleTypeNvSciSync; desc.handle.nvSciSyncObj  $=$  nvSciSyncObj; cudaImportExternalSemaphore(&extSem, &desc); // Deleting/Freeing the nvSciSyncObj beyond this point will lead to undefined behavior in CUDA return extSem; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.5 Signaling/Waiting on Imported Synchronization Objects - An imported NvSciSyncObj objec...",
    "content": "An imported NvSciSyncObj object can be signaled as outlined below. Signaling NvSciSync backed semaphore object initializes the fence parameter passed as input. This fence parameter is waited upon by a wait operation that corresponds to the aforementioned signal. Additionally, the wait that waits on this signal must be issued after this signal has been issued. If the flags are set to cudaExternalSemaphoreSignalSkipNvSciBufMemSync then memory synchronization operations (over all the imported NvSciBuf in this process) that are executed as a part of the signal operation by default are skipped. When NvsciBufGeneralAttrKey_GpuSWMeanedCacheCoherency is FALSE, this flag should be set."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.5 Signaling/Waiting on Imported Synchronization Objects - void signalExternalSemaphorecu......continues on next page",
    "content": "void signalExternalSemaphore(cudaExternalSemaphore_t extSem, cudaStream_t stream,  $\\rightarrow$  void \\*fence) { cudaExternalSemaphoreSignalParams signalParams  $=$  {}; memset(&signalParams, 0, sizeof(signalParams)); signalParams.params.nvSciSync.fence  $=$  (void\\*)fence; signalParams.flags  $=$  0; //OR cudaExternalSemaphoreSignalSkipNvSciBufMemSync cudaSignalExternalSemaphoresAsync(&extSem, &signalParams, 1, stream);\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.5 Signaling/Waiting on Imported Synchronization Objects - An imported NvSciSyncObj objec...",
    "content": "An imported NvSciSyncObj object can be waited upon as outlined below. Waiting on NvSciSync backed semaphore object waits until the input fence parameter is signaled by the corresponding signaler. Additionally, the signal must be issued before the wait can be issued. If the flags are set to cudaExternalSemaphoreWaitSkipNvSciBufMemSync then memory synchronization operations (over all the imported NvSciBuf in this process) that are executed as a part of the signal operation by default are skipped. When NvsciBufGeneralAttrKey_GpuSwNeedCacheCoherency is FALSE, this flag should be set."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.16.5.5 Signaling/Waiting on Imported Synchronization Objects - cppvoid waitExternalSemaphorec...",
    "content": "```cppvoid waitExternalSemaphore(cudaExternalSemaphore_t extSem, cudaStream_t stream, void *fence) {    cudaExternalSemaphoreWaitParams waitParams = {};    memset(&waitParams, 0, sizeof(waitParams));    waitParams.params.nvSciSync.fence = (void*)fence;    waitParams.flags = 0; // OR cudaExternalSemaphoreWaitSkipNvSciBufMemSync    cudaWaitExternalSemaphoresAsync(&extSem, &waitParams, 1, stream);}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.17. CUDA User Objects - CUDA User Objects can be used ......cpp Library API with pool allo...",
    "content": "CUDA User Objects can be used to help manage the lifetime of resources used by asynchronous work in CUDA. In particular, this feature is useful for CUDA Graphs and stream capture.\n\nVarious resource management schemes are not compatible with CUDA graphs. Consider for example an event- based pool or a synchronous- create, asynchronous- destroy scheme.\n\n```cpp// Library API with pool allocationvoid libraryWork(cudaStream_t stream) {    auto &resource = pool.claimTemporaryResource();    resource.waitOnReadyEventInStream(stream);    launchWork(stream, resource);    resource.recordReadyEvent(stream);}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.17. CUDA User Objects - cpp Library API with asynchron...",
    "content": "```cpp// Library API with asynchronous resource deletionvoid libraryWork(cudaStream_t stream) {    Resource *resource = new Resource(...);    launchWork(stream, resource);    cudaStreamAddCallback(stream,[](cudaStream_t, cudaError_t, void *resource) {        delete static_cast<Resource %> (resource);    },    resource, 0);    // Error handling considerations not shown}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.17. CUDA User Objects - These schemes are difficult wi...",
    "content": "These schemes are difficult with CUDA graphs because of the non- fixed pointer or handle for the resource which requires indirection or graph update, and the synchronous CPU code needed each time the work is submitted. They also do not work with stream capture if these considerations are hidden from the caller of the library, and because of use of disallowed APIs during capture. Various solutions exist such as exposing the resource to the caller. CUDA user objects present another approach."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.17. CUDA User Objects - A CUDA user object associates ...",
    "content": "A CUDA user object associates a user- specified destructor callback with an internal refcount, similar to  $\\mathtt{C + + }$  shared_ptr. References may be owned by user code on the CPU and by CUDA graphs. Note that for user- owned references, unlike  $\\mathtt{C + + }$  smart pointers, there is no object representing the reference; users must track user- owned references manually. A typical use case would be to immediately move the sole user- owned reference to a CUDA graph after the user object is created."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.17. CUDA User Objects - When a reference is associated......Here is an example use",
    "content": "When a reference is associated to a CUDA graph, CUDA will manage the graph operations automatically. A cloned cudaGraph_t retains a copy of every reference owned by the source cudaGraph_t, with the same multiplicity. An instantiated cudaGraphExec_t retains a copy of every reference in the source cudaGraph_t. When a cudaGraphExec_t is destroyed without being synchronized, the references are retained until the execution is completed.\n\nHere is an example use."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.17. CUDA User Objects - cppcudaGrapht graph  Preexisti...",
    "content": "```cppcudaGraph_t graph; // Preexisting graphObject *object = new Object; // C++ object with possibly nontrivial destructorcudaUserObject_t cuObject;cudaUserObjectCreate(&cuObject, object, // Here we use a CUDA- provided template wrapper for this API, // which supplies a callback to delete the C++ object pointer1, // Initial refcountcudaUserObjectNoDestructorSync // Acknowledge that the callback cannot be // waited on via CUDA);cudaGraphRetainUserObject(graph, cuObject, 1, // Number of referencescudaGraphUserObjectMove // Transfer a reference owned by the caller (do // not modify the total reference count));// No more references owned by this thread; no need to call release APICudaGraphExec_t graphExec;cudaGraphInstantiate(&graphExec, graph, nullptr, nullptr, 0); // Will retain a // new re"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.17. CUDA User Objects - ferencecudaGraphDestroygraph  ...",
    "content": "ferencecudaGraphDestroy(graph); // graphExec still owns a referencecudaGraphLaunch(graphExec, 0); // Async launch has access to the user objectscudaGraphExecDestroy(graphExec); // Launch is not synchronized; the release // will be deferred if neededcudaStreamSynchronize(0); // After the launch is synchronized, the remaining // reference is released and the destructor will // execute."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.17. CUDA User Objects - Note this happens asynchronous...",
    "content": " Note this happens asynchronously.// If the destructor callback had signaled a synchronization object, it would // be safe to wait on it at this point.```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.17. CUDA User Objects - References owned by graphs in ......the launches have finished exe...",
    "content": "References owned by graphs in child graph nodes are associated to the child graphs, not the parents. If a child graph is updated or deleted, the references change accordingly. If an executable graph or child graph is updated with cudaGraphExecUpdate or cudaGraphExecChildGraphNodeSetParams, the references in the new source graph are cloned and replace the references in the target graph. In either case, if previous launches are not synchronized, any references which would be released are held until\n\nthe launches have finished executing."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.2.17. CUDA User Objects - There is not currently a mecha......User objects are created with ...",
    "content": "There is not currently a mechanism to wait on user object destructors via a CUDA API. Users may signal a synchronization object manually from the destructor code. In addition, it is not legal to call CUDA APIs from the destructor, similar to the restriction on cudaLaunchHostFunc. This is to avoid blocking a CUDA internal shared thread and preventing forward progress. It is legal to signal another thread to perform an API call, if the dependency is one way and the thread doing the call cannot block forward progress of CUDA work.\n\nUser objects are created with cudaUserObjectCreate, which is a good starting point to browse related APIs."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.3. Versioning and Compatibility - There are two version numbers ...",
    "content": "There are two version numbers that developers should care about when developing a CUDA application: The compute capability that describes the general specifications and features of the compute device (see Compute Capability) and the version of the CUDA driver API that describes the features supported by the driver API and runtime."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.3. Versioning and Compatibility - The version of the driver API ...",
    "content": "The version of the driver API is defined in the driver header file as CUDA_VERSION. It allows developers to check whether their application requires a newer device driver than the one currently installed. This is important, because the driver API is backward/compatible, meaning that applications, plug- ins, and libraries (including the CUDA runtime) compiled against a particular version of the driver API will continue to work on subsequent device driver releases as illustrated in Figure 12. The driver API is not forward compatible, which means that applications, plug- ins, and libraries (including the CUDA runtime) compiled against a particular version of the driver API will not work on previous versions of the device driver."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.3. Versioning and Compatibility - It is important to note that t...",
    "content": "It is important to note that there are limitations on the mixing and matching of versions that is supported:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.3. Versioning and Compatibility - Since only one version of the ...",
    "content": "- Since only one version of the CUDA Driver can be installed at a time on a system, the installed driver must be of the same or higher version than the maximum Driver API version against which any application, plug-ins, or libraries that must run on that system were built.- All plug-ins and libraries used by an application must use the same version of the CUDA Runtime unless they statically link to the Runtime, in which case multiple versions of the runtime can coexist in the same process space. Note that if nvcc is used to link the application, the static version of the CUDA Runtime library will be used by default, and all CUDA Toolkit libraries are statically linked against the CUDA Runtime."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.3. Versioning and Compatibility - All plugins and libraries used...",
    "content": "- All plug-ins and libraries used by an application must use the same version of any libraries that use the runtime (such as cuFFT, cuBLAS, ...) unless statically linking to those libraries."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.3. Versioning and Compatibility - For Tesla GPU products CUDA 10......Fig 15 The Driver API Is Backw...",
    "content": "For Tesla GPU products, CUDA 10 introduced a new forward- compatible upgrade path for the user- mode components of the CUDA Driver. This feature is described in CUDA Compatibility. The requirements on the CUDA Driver version described here apply to the version of the user- mode components.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/4571e734fdc98dbcbbb66554e36435279fd92b0ca2ea28138a7b141b236cc6d1.jpg)  \nFig. 15: The Driver API Is Backward but Not Forward Compatible"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.4. Compute Modes - On Tesla solutions running Win......Default compute mode Multiple ...",
    "content": "On Tesla solutions running Windows Server 2008 and later or Linux, one can set any device in a system in one of the three following modes using NVIDIA's System Management Interface (nvidia- smi), which is a tool distributed as part of the driver:\n\n- Default compute mode: Multiple host threads can use the device (by calling cudaSetDevice() on this device, when using the runtime API, or by making current a context associated to the device, when using the driver API) at the same time.- Exclusive-process compute mode: Only one CUDA context may be created on the device across all processes in the system. The context may be current to as many threads as desired within the process that created that context.- Prohibited compute mode: No CUDA context can be created on the device."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.4. Compute Modes - This means in particular that ...",
    "content": "This means, in particular, that a host thread using the runtime API without explicitly calling cudaSetDevice() might be associated with a device other than device 0 if device 0 turns out to be in prohibited mode or in exclusive- process mode and used by another process. cudaSetValidDevices() can be used to set a device from a prioritized list of devices."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.4. Compute Modes - Note also that for devices fea...",
    "content": "Note also that, for devices featuring the Pascal architecture onwards (compute capability with major revision number 6 and higher), there exists support for Compute Preemption. This allows compute tasks to be preempted at instruction- level granularity, rather than thread block granularity as in prior Maxwell and Kepler GPU architecture, with the benefit that applications with long- running kernels can be prevented from either monopolizing the system or timing out. However, there will be context switch overheads associated with Compute Preemption, which is automatically enabled on those devices for which support exists."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.4. Compute Modes - The individual attribute query...",
    "content": " The individual attribute query function cudaDeviceGetAttribute() with the attribute cudaDevAttrComputePreemptionSupported can be used to determine if the device in use supports Compute Preemption. Users wishing to avoid context switch overheads associated with different processes can ensure that only one process is active on the GPU by selecting exclusive- process mode."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.4. Compute Modes - Applications may query the com...",
    "content": "Applications may query the compute mode of a device by checking the computeMode device property (see Device Enumeration)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.5. Mode Switches - GPUs that have a display outpu...",
    "content": "GPUs that have a display output dedicate some DRAM memory to the so- called primary surface, which is used to refresh the display device whose output is viewed by the user. When users initiate a mode switch of the display by changing the resolution or bit depth of the display (using NVIDIA control panel or the Display control panel on Windows), the amount of memory needed for the primary surface changes. For example, if the user changes the display resolution from 1280x1024x32- bit to 1600x1200x32- bit, the system must dedicate 7.68 MB to the primary surface rather than 5.24 MB. (Full- screen graphics applications running with anti- aliasing enabled may require much more display memory for the primary surface."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.5. Mode Switches - On Windows other events that m...",
    "content": ") On Windows, other events that may initiate display mode switches include launching a full- screen DirectX application, hitting Alt+Tab to task switch away from a full- screen DirectX application, or hitting Ctrl+Alt+Del to lock the computer."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "6.5. Mode Switches - If a mode switch increases the...",
    "content": "If a mode switch increases the amount of memory needed for the primary surface, the system may have to cannibalize memory allocations dedicated to CUDA applications. Therefore, a mode switch results in any call to the CUDA runtime to fail and return an invalid context error."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "CUDA C++ Programming Guide, Release 12.1 - Using NVIDIAs System Managemen......TCC mode removes support for a...",
    "content": "Using NVIDIA's System Management Interface (nvidia- smi), the Windows device driver can be put in TCC (Tesla Compute Cluster) mode for devices of the Tesla and Quadro Series.\n\nTCC mode removes support for any graphics functionality.\n\n# CUDA C++ Programming Guide, Release 12.1\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 7. Hardware Implementation - The NVIDIA GPU architecture is...",
    "content": "The NVIDIA GPU architecture is built around a scalable array of multithreaded Streaming Multiprocessors (SMs). When a CUDA program on the host CPU invokes a kernel grid, the blocks of the grid are enumerated and distributed to multiprocessors with available execution capacity. The threads of a thread block execute concurrently on one multiprocessor, and multiple thread blocks can execute concurrently on one multiprocessor. As thread blocks terminate, new blocks are launched on the vacated multiprocessors."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 7. Hardware Implementation - A multiprocessor is designed t...",
    "content": "A multiprocessor is designed to execute hundreds of threads concurrently. To manage such a large number of threads, it employs a unique architecture called SiMT (Single- Instruction, Multiple- Thread) that is described in SiMT Architecture. The instructions are pipelined, leveraging instruction- level parallelism within a single thread, as well as extensive thread- level parallelism through simultaneous hardware multithreading as detailed in Hardware Multithreading. Unlike CPU cores, they are issued in order and there is no branch prediction or speculative execution."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 7. Hardware Implementation - SiMT Architecture and Hardware......The NVIDIA GPU architecture us...",
    "content": "SiMT Architecture and Hardware Multithreading describe the architecture features of the streaming multiprocessor that are common to all devices. Compute Capability 5. x, Compute Capability 6. x, and Compute Capability 7. x provide the specifics for devices of compute capabilities 5. x, 6. x, and 7. x respectively.\n\nThe NVIDIA GPU architecture uses a little- endian representation."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "7.1. SIMT Architecture - The multiprocessor creates man...",
    "content": "The multiprocessor creates, manages, schedules, and executes threads in groups of 32 parallel threads called warps. Individual threads composing a warp start together at the same program address, but they have their own instruction address counter and register state and are therefore free to branch and execute independently. The term warp originates from weaving, the first parallel thread technology. A half- warp is either the first or second half of a warp. A quarter- warp is either the first, second, third, or fourth quarter of a warp."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "7.1. SIMT Architecture - When a multiprocessor is given...",
    "content": "When a multiprocessor is given one or more thread blocks to execute, it partitions them into warps and each warp gets scheduled by a warp scheduler for execution. The way a block is partitioned into warps is always the same; each warp contains threads of consecutive, increasing thread IDs with the first warp containing thread 0. Thread Hierarchy describes how thread IDs relate to thread indices in the block."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "7.1. SIMT Architecture - A warp executes one common ins...",
    "content": "A warp executes one common instruction at a time, so full efficiency is realized when all 32 threads of a warp agree on their execution path. If threads of a warp diverge via a data- dependent conditional branch, the warp executes each branch path taken, disabling threads that are not on that path. Branch divergence occurs only within a warp; different warps execute independently regardless of whether they are executing common or disjoint code paths."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "7.1. SIMT Architecture - The SIMT architecture is akin ...",
    "content": "The SIMT architecture is akin to SIMD (Single Instruction, Multiple Data) vector organizations in that a single instruction controls multiple processing elements. A key difference is that SIMD vector organizations expose the SIMD width to the software, whereas SIMT instructions specify the execution and branching behavior of a single thread. In contrast with SIMD vector machines, SIMT enables programmers to write thread- level parallel code for independent, scalar threads, as well as data- parallel code for coordinated threads. For the purposes of correctness, the programmer can essentially ignore the SIMT behavior; however, substantial performance improvements can be realized by taking care that the code seldom requires threads in a warp to diverge."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "7.1. SIMT Architecture - In practice this is analogous ...",
    "content": " In practice, this is analogous to the role of cache lines in traditional code: Cache line size can be safely ignored when designing for correctness but must be considered in the code structure when designing for peak performance. Vector architectures, on the other hand, require the software to coalesce loads into vectors and manage divergence manually."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "7.1. SIMT Architecture - Prior to NVIDIA Volta warps us...",
    "content": "Prior to NVIDIA Volta, warps used a single program counter shared amongst all 32 threads in the warp together with an active mask specifying the active threads of the warp. As a result, threads from the same warp in divergent regions or different states of execution cannot signal each other or exchange data, and algorithms requiring fine- grained sharing of data guarded by locks or mutexes can easily lead to deadlock, depending on which warp the contending threads come from."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "7.1. SIMT Architecture - Starting with the NVIDIA Volta...",
    "content": "Starting with the NVIDIA Volta architecture, Independent Thread Scheduling allows full concurrency between threads, regardless of warp. With Independent Thread Scheduling, the GPU maintains execution state per thread, including a program counter and call stack, and can yield execution at a per- thread granularity, either to make better use of execution resources or to allow one thread to wait for data to be produced by another. A schedule optimizer determines how to group active threads from the same warp together into SIMT units. This retains the high throughput of SIMT execution as in prior NVIDIA GPUs, but with much more flexibility: threads can now diverge and reconverge at sub- warp granularity."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "7.1. SIMT Architecture - Independent Thread Scheduling ...",
    "content": "Independent Thread Scheduling can lead to a rather different set of threads participating in the executed code than intended if the developer made assumptions about warp- synchronicity of previous hardware architectures. In particular, any warp- synchronous code (such as synchronization- free, intra- warp reductions) should be revisited to ensure compatibility with NVIDIA Volta and beyond. See Compute Capability 7. x for further details."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "7.1. SIMT Architecture - Note The threads of a warp tha...",
    "content": "Note: The threads of a warp that are participating in the current instruction are called the active threads, whereas threads not on the current instruction are inactive (disabled). Threads can be inactive for a variety of reasons including having exited earlier than other threads of their warp, having taken a different branch path than the branch path currently executed by the warp, or being the last threads of a block whose number of threads is not a multiple of the warp size."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "7.1. SIMT Architecture - If a non atomic instruction ex......If an atomic instruction execu...",
    "content": "If a non- atomic instruction executed by a warp writes to the same location in global or shared memory for more than one of the threads of the warp, the number of serialized writes that occur to that location varies depending on the compute capability of the device (see Compute Capability 5. x, Compute Capability 6. x, and Compute Capability 7. x), and which thread performs the final write is undefined.\n\nIf an atomic instruction executed by a warp reads, modifies, and writes to the same location in global memory for more than one of the threads of the warp, each read/modify/write to that location occurs and they are all serialized, but the order in which they occur is undefined."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "7.2. Hardware Multithreading - The execution context program ......In particular each multiproces...",
    "content": "The execution context (program counters, registers, and so on) for each warp processed by a multiprocessor is maintained on- chip during the entire lifetime of the warp. Therefore, switching from one execution context to another has no cost, and at every instruction issue time, a warp scheduler selects a warp that has threads ready to execute its next instruction (the active threads of the warp) and issues the instruction to those threads.\n\nIn particular, each multiprocessor has a set of 32- bit registers that are partitioned among the warps, and a parallel data cache or shared memory that is partitioned among the thread blocks."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "7.2. Hardware Multithreading - The number of blocks and warps......The total number of warps in a...",
    "content": "The number of blocks and warps that can reside and be processed together on the multiprocessor for a given kernel depends on the amount of registers and shared memory used by the kernel and the amount of registers and shared memory available on the multiprocessor. There are also a maximum number of resident blocks and a maximum number of resident warps per multiprocessor. These limits as well the amount of registers and shared memory available on the multiprocessor are a function of the compute capability of the device and are given in Compute Capabilities. If there are not enough registers or shared memory available per multiprocessor to process at least one block, the kernel will fail to launch.\n\nThe total number of warps in a block is as follows:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "7.2. Hardware Multithreading - beginarrayrmathsfceilleftfracT......The total number of registers ...",
    "content": "$$\n\\begin{array}{r}\\mathsf{ceil}\\left(\\frac{T}{W_{size}},1\\right) \\end{array}\n$$\n\n$T$  is the number of threads per block, Wsize is the warp size, which is equal to 32, ceil(x, y) is equal to x rounded up to the nearest multiple of y.\n\nThe total number of registers and total amount of shared memory allocated for a block are documented in the CUDA Occupancy Calculator provided in the CUDA Toolkit."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 8. Performance Guidelines",
    "content": "\n\n# Chapter 8. Performance Guidelines\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.1. Overall Performance Optimization Strategies - Performance optimization revol......Maximize parallel execution to...",
    "content": "Performance optimization revolves around four basic strategies:\n\n- Maximize parallel execution to achieve maximum utilization;- Optimize memory usage to achieve maximum memory throughput;- Optimize instruction usage to achieve maximum instruction throughput;- Minimize memory thrashing."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.1. Overall Performance Optimization Strategies - Which strategies will yield th...",
    "content": "Which strategies will yield the best performance gain for a particular portion of an application depends on the performance limiters for that portion; optimizing instruction usage of a kernel that is mostly limited by memory accesses will not yield any significant performance gain, for example. Optimization efforts should therefore be constantly directed by measuring and monitoring the performance limiters, for example using the CUDA profiler. Also, comparing the floating- point operation throughput or memory throughput—whichever makes more sense—of a particular kernel to the corresponding peak theoretical throughput of the device indicates how much room for improvement there is for the kernel."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2. Maximize Utilization - To maximize utilization the ap...",
    "content": "To maximize utilization the application should be structured in a way that it exposes as much parallelism as possible and efficiently maps this parallelism to the various components of the system to keep them busy most of the time."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.1. Application Level - At a high level the applicatio...",
    "content": "At a high level, the application should maximize parallel execution between the host, the devices, and the bus connecting the host to the devices, by using asynchronous functions calls and streams as described in Asynchronous Concurrent Execution. It should assign to each processor the type of work it does best: serial workloads to the host; parallel workloads to the devices."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.1. Application Level - For the parallel workloads at ...",
    "content": "For the parallel workloads, at points in the algorithm where parallelism is broken because some threads need to synchronize in order to share data with each other, there are two cases: Either these threads belong to the same block, in which case they should use __syncthreads() and share data through shared memory within the same kernel invocation, or they belong to different blocks, in which case they must share data through global memory using two separate kernel invocations, one for writing to and one for reading from global memory. The second case is much less optimal since it adds the overhead of extra kernel invocations and global memory traffic."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.1. Application Level - Its occurrence should therefor...",
    "content": " Its occurrence should therefore be minimized by mapping the algorithm to the CUDA programming model in such a way that the computations that require inter- thread communication are performed within a single thread block as much as possible."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.2. Device Level - At a lower level the applicati......Multiple kernels can execute c...",
    "content": "At a lower level, the application should maximize parallel execution between the multiprocessors of a device.\n\nMultiple kernels can execute concurrently on a device, so maximum utilization can also be achieved by using streams to enable enough kernels to execute concurrently as described in Asynchronous Concurrent Execution."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3. Multiprocessor Level - At an even lower level the app...",
    "content": "At an even lower level, the application should maximize parallel execution between the various functional units within a multiprocessor."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3. Multiprocessor Level - As described in Hardware Multi...",
    "content": "As described in Hardware Multithreading, a GPU multiprocessor primarily relies on thread- level parallelism to maximize utilization of its functional units. Utilization is therefore directly linked to the number of resident warps. At every instruction issue time, a warp scheduler selects an instruction that is ready to execute. This instruction can be another independent instruction of the same warp, exploiting instruction- level parallelism, or more commonly an instruction of another warp, exploiting thread- level parallelism. If a ready to execute instruction is selected it is issued to the active threads of the warp."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3. Multiprocessor Level - The number of clock cycles it ...",
    "content": " The number of clock cycles it takes for a warp to be ready to execute its next instruction is called the latency, and full utilization is achieved when all warp schedulers always have some instruction to issue for some warp at every clock cycle during that latency period, or in other words, when latency is completely \"hidden\". The number of instructions required to hide a latency of L clock cycles depends on the respective throughputs of these instructions (see Arithmetic Instructions for the throughputs of various arithmetic instructions). If we assume instructions with maximum throughput, it is equal to:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3. Multiprocessor Level - 4L for devices of compute capa......The most common reason a warp ...",
    "content": "4L for devices of compute capability 5. x, 6.1, 6.2, 7. x and 8. x since for these devices, a multiprocessor issues one instruction per warp over one clock cycle for four warps at a time, as mentioned in Compute Capabilities. 2L for devices of compute capability 6.0 since for these devices, the two instructions issued every cycle are one instruction for two different warps.\n\nThe most common reason a warp is not ready to execute its next instruction is that the instruction's input operands are not available yet."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3. Multiprocessor Level - If all input operands are regi...",
    "content": "If all input operands are registers, latency is caused by register dependencies, i.e., some of the input operands are written by some previous instruction(s) whose execution has not completed yet. In this case, the latency is equal to the execution time of the previous instruction and the warp schedulers must schedule instructions of other warps during that time. Execution time varies depending on the instruction. On devices of compute capability 7. x, for most arithmetic instructions, it is typically 4 clock cycles. This means that 16 active warps per multiprocessor (4 cycles, 4 warp schedulers) are required to hide arithmetic instruction latencies (assuming that warps execute instructions with maximum throughput, otherwise fewer warps are needed)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3. Multiprocessor Level - If the individual warps exhibi...",
    "content": " If the individual warps exhibit instruction- level parallelism, i.e. have multiple independent instructions in their instruction stream, fewer warps are needed because multiple independent instructions from a single warp can be issued back to back."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3. Multiprocessor Level - If some input operand resides ...",
    "content": "If some input operand resides in off- chip memory, the latency is much higher: typically hundreds of clock cycles. The number of warps required to keep the warp schedulers busy during such high latency periods depends on the kernel code and its degree of instruction- level parallelism. In general, more warps are required if the ratio of the number of instructions with no off- chip memory operands (i.e., arithmetic instructions most of the time) to the number of instructions with off- chip memory operands is low (this ratio is commonly called the arithmetic intensity of the program)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3. Multiprocessor Level - Another reason a warp is not r...",
    "content": "Another reason a warp is not ready to execute its next instruction is that it is waiting at some memory fence (Memory Fence Functions) or synchronization point (Synchronization Functions). A synchronization point can force the multiprocessor to idle as more and more warps wait for other warps in the same block to complete execution of instructions prior to the synchronization point. Having multiple resident blocks per multiprocessor can help reduce idling in this case, as warps from different blocks do not need to wait for each other at synchronization points."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3. Multiprocessor Level - The number of blocks and warps......The total amount of shared mem...",
    "content": "The number of blocks and warps residing on each multiprocessor for a given kernel call depends on the execution configuration of the call (Execution Configuration), the memory resources of the multiprocessor, and the resource requirements of the kernel as described in Hardware Multithreading. Register and shared memory usage are reported by the compiler when compiling with the - - ptxas- options  $= - \\vee$  option.\n\nThe total amount of shared memory required for a block is equal to the sum of the amount of statically allocated shared memory and the amount of dynamically allocated shared memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3. Multiprocessor Level - The number of registers used b...",
    "content": "The number of registers used by a kernel can have a significant impact on the number of resident warps. For example, for devices of compute capability 6. x, if a kernel uses 64 registers and each block has 512 threads and requires very little shared memory, then two blocks (i.e., 32 warps) can reside on the multiprocessor since they require  $2 \\times 512 \\times 64$  registers, which exactly matches the number of registers available on the multiprocessor. But as soon as the kernel uses one more register, only one block (i.e., 16 warps) can be resident since two blocks would require  $2 \\times 512 \\times 65$  registers, which are more registers than are available on the multiprocessor."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3. Multiprocessor Level - Therefore the compiler attempt...",
    "content": " Therefore, the compiler attempts to minimize register usage while keeping register spilling (see Device Memory Accesses) and the number of instructions to a minimum. Register usage can be controlled using the maxr regcount compiler option or launch bounds as described in Launch Bounds."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3. Multiprocessor Level - The register file is organized......The number of threads per bloc...",
    "content": "The register file is organized as 32- bit registers. So, each variable stored in a register needs at least one 32- bit register, for example, a double variable uses two 32- bit registers.\n\nThe effect of execution configuration on performance for a given kernel call generally depends on the kernel code. Experimentation is therefore recommended. Applications can also parametrize execution configurations based on register file size and shared memory size, which depends on the compute capability of the device, as well as on the number of multiprocessors and memory bandwidth of the device, all of which can be queried using the runtime (see reference manual).\n\nThe number of threads per block should be chosen as a multiple of the warp size to avoid wasting"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3. Multiprocessor Level - computing resources with under...",
    "content": "computing resources with under- populated warps as much as possible."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3.1 Occupancy Calculator - Several API functions exist to...",
    "content": "Several API functions exist to assist programmers in choosing thread block size and cluster size based on register and shared memory requirements."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3.1 Occupancy Calculator - The occupancy calculator API c...",
    "content": "The occupancy calculator API, cudaOccupancyMaxActiveBlocksPerMultiprocessor, can provide an occupancy prediction based on the block size and shared memory usage of a kernel. This function reports occupancy in terms of the number of concurrent thread blocks per multiprocessor. Note that this value can be converted to other metrics. Multiplying by the number of warps per block yields the number of concurrent warps per multiprocessor; further dividing concurrent warps by max warps per multiprocessor gives the occupancy as a percentage. The occupancy- based launch configurator APIs, cudaOccupancyMaxPotentialBlockSize and cudaOccupancyMaxPotentialBlockSizeVariableSMem, heuristically calculate an execution configuration that achieves the maximum multiprocessor- level occupancy."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3.1 Occupancy Calculator - The occupancy calculator API c...",
    "content": " The occupancy calculator API, cudaOccupancyMaxActiveClusters, can provided occupancy prediction based on the cluster size, block size and shared memory usage of a kernel. This function reports occupancy in terms of number of max active clusters of a given size on the GPU present in the system."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3.1 Occupancy Calculator - The following code sample calc......Device code  global void MyKer...",
    "content": "The following code sample calculates the occupancy of MyKernel. It then reports the occupancy level with the ratio between concurrent warps versus maximum warps per multiprocessor.\n\n// Device code - global__ void MyKernel(int \\*d, int \\*a, int \\*b) { int idx  $=$  threadIdx.x  $^+$  blockIdx.x \\* blockDim.x; d[idx]  $=$  a[idx] \\* b[idx]; } // Host code int main() { int numBlocks; // Occupancy in terms of active blocks int blockSize  $= 32$  // These variables are used to convert occupancy to warps int device; cudaDeviceProp prop; int activeWarps; int maxWarps; cudaGetDevice(&device); cudaGetDeviceProperties(&prop, device); cudaOccupancyMaxActiveBlocksPerMultiprocessor( &numBlocks, MyKernel, blockSize, 0); activeWarps  $=$  numBlocks \\* blockSize / prop.warpSize;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3.1 Occupancy Calculator - continued from previous page...The following code sample conf...",
    "content": "(continued from previous page)\n\nmaxWarps  $=$  prop.maxThreadsPerMultiProcessor / prop.warpSize; std::cout << \"Occupancy: \" << (double)activeWarps / maxWarps \\* 100 << \"%\" << std::endl; return 0; }\n\nThe following code sample configures an occupancy- based kernel launch of MyKernel according to the user input."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3.1 Occupancy Calculator - Device code  global void MyKer...",
    "content": "// Device code - global__ void MyKernel(int \\*array, int arrayCount) { int idx  $=$  threadIdx.x  $^+$  blockIdx.x \\* blockDim."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3.1 Occupancy Calculator - x if idx    arrayCount  arrayi...",
    "content": "x; if (idx  $<$  arrayCount) { array[idx]  $\\ast =$  array[idx]; } } // Host code int launchMyKernel(int \\*array, int arrayCount) { int blockSize; // The launch configurator returned block size int minGridSize; // The minimum grid size needed to achieve the // maximum occupancy for a full device // launch int gridSize; // The actual grid size needed, based on input // size cudaOccupancyMaxPotentialBlockSize( &minGridSize, &blockSize, (void\\*)MyKernel, 0, arrayCount); // Round up according to array size gridSize  $=$  (arrayCount  $^+$  blockSize - 1) / blockSize; MyKernel  $\\epsilon_{< <}$  gridSize, blockSize  $\\geq \\geq \\geq$  (array, arrayCount); cudaDeviceSynchronize(); // If interested, the occupancy can be calculated with // cudaOccupancyMaxActiveBlocksPerMultiprocessor return 0; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3.1 Occupancy Calculator - The following code sample show......ClusterSize API",
    "content": "The following code sample shows how to use the cluster occupancy API to find the max number of active clusters of a given size. Example code below calucaltes occupancy for cluster of size 2 and 128 threads per block.\n\nCluster size of 8 is forward compatible starting compute capability 9.0, except on GPU hardware or MIG configurations which are too small to support 8 multiprocessors in which case the maximum cluster size will be reduced. But it is recommended that the users query the maximum cluster size before launching a cluster kernel. Max cluster size can be queried using cudaOccupancyMaxPotential-\n\nClusterSize API."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3.1 Occupancy Calculator - cudaLaunchConfigt config    0 ...",
    "content": "{ cudaLaunchConfig_t config  $=$  {0}; config.gridDim  $=$  number_of_blocks; config.blockDim  $=$  128; // threads_per_block  $=$  128 config.dynamicSmemBytes  $=$  dynamic_shared_memory_size; cudaLaunchAttribute attribute[1]; attribute[0].id  $=$  cudaLaunchAttributeClusterDimension; attribute[0].val.clusterDim.  $\\texttt{x} = 2$  ; // cluster_size  $= 2$  attribute[0].val.clusterDim.y  $= 1$  attribute[0].val.clusterDim.z  $= 1$  config.attrs  $=$  attribute; config.numAttrs  $= 1$  int max_cluster_size  $= 0$  cudaOccupancyMaxPotentialClusterSize(&max_cluster_size, (void \\*)kernel, &config); int max_active_clusters  $= 0$  cudaOccupancyMaxActiveClusters(&max_active_clusters, (void \\*)kernel, &config); std::cout << \"Max Active Clusters of size 2: \" << max_active_clusters << std::endl; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.2.3.1 Occupancy Calculator - The CUDA Nsight Compute User I...",
    "content": "The CUDA Nsight Compute User Interface also provides a standalone occupancy calculator and launch configurator implementation in <CUDA_Toolkit_Path>/include/cuda_occupancy.h for any use cases that cannot depend on the CUDA software stack. The Nsight Compute version of the occupancy calculator is particularly useful as a learning tool that visualizes the impact of changes to the parameters that affect occupancy (block size, registers per thread, and shared memory per thread)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.3. Maximize Memory Throughput - The first step in maximizing o......That also means minimizing dat...",
    "content": "The first step in maximizing overall memory throughput for the application is to minimize data transfers with low bandwidth.\n\nThat means minimizing data transfers between the host and the device, as detailed in Data Transfer between Host and Device, since these have much lower bandwidth than data transfers between global memory and the device.\n\nThat also means minimizing data transfers between global memory and the device by maximizing use of on- chip memory: shared memory and caches (i.e., L1 cache and L2 cache available on devices of compute capability 2. x and higher, texture cache and constant cache available on all devices)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.3. Maximize Memory Throughput - Shared memory is equivalent to......Write the results back to devi...",
    "content": "Shared memory is equivalent to a user- managed cache: The application explicitly allocates and accesses it. As illustrated in CUDA Runtime, a typical programming pattern is to stage data coming from device memory into shared memory; in other words, to have each thread of a block:\n\n- Load data from device memory to shared memory,- Synchronize with all the other threads of the block so that each thread can safely read shared memory locations that were populated by different threads,- Process the data in shared memory,- Synchronize again if necessary to make sure that shared memory has been updated with the results,\n\nWrite the results back to device memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.3. Maximize Memory Throughput - For some applications for exam...",
    "content": "For some applications (for example, for which global memory access patterns are data- dependent), a traditional hardware- managed cache is more appropriate to exploit data locality. As mentioned in Compute Capability 7. x, Compute Capability 8. x and Compute Capability 9.0, for devices of compute capability 7. x, 8. x and 9.0, the same on- chip memory is used for both L1 and shared memory, and how much of it is dedicated to L1 versus shared memory is configurable for each kernel call."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.3. Maximize Memory Throughput - The throughput of memory acces...",
    "content": "The throughput of memory accesses by a kernel can vary by an order of magnitude depending on access pattern for each type of memory. The next step in maximizing memory throughput is therefore to organize memory accesses as optimally as possible based on the optimal memory access patterns described in Device Memory Accesses. This optimization is especially important for global memory accesses as global memory bandwidth is low compared to available on- chip bandwidths and arithmetic instruction throughput, so non- optimal global memory accesses generally have a high impact on performance."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.3.1. Data Transfer between Host and Device - Applications should strive to ......Also because of the overhead a...",
    "content": "Applications should strive to minimize data transfer between the host and the device. One way to accomplish this is to move more code from the host to the device, even if that means running kernels that do not expose enough parallelism to execute on the device with full efficiency. Intermediate data structures may be created in device memory, operated on by the device, and destroyed without ever being mapped by the host or copied to host memory.\n\nAlso, because of the overhead associated with each transfer, batching many small transfers into a single large transfer always performs better than making each transfer separately."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.3.1. Data Transfer between Host and Device - On systems with a front side b......In addition when using mapped ...",
    "content": "On systems with a front- side bus, higher performance for data transfers between host and device is achieved by using page- locked host memory as described in Page- Locked Host Memory.\n\nIn addition, when using mapped page- locked memory (Mapped Memory), there is no need to allocate any device memory and explicitly copy data between device and host memory. Data transfers are implicitly performed each time the kernel accesses the mapped memory. For maximum performance, these memory accesses must be coalesced as with accesses to global memory (see Device Memory Accesses). Assuming that they are and that the mapped memory is read or written only once, using mapped page- locked memory instead of explicit copies between device and host memory can be a win for performance."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.3.1. Data Transfer between Host and Device - On integrated systems where de...",
    "content": "On integrated systems where device memory and host memory are physically the same, any copy between host and device memory is superfluous and mapped page- locked memory should be used instead. Applications may query a device is integrated by checking that the integrated device property (see Device Enumeration) is equal to 1."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.3.2. Device Memory Accesses - An instruction that accesses a...",
    "content": "# 8.3.2. Device Memory Accesses\nAn instruction that accesses addressable memory (i.e., global, local, shared, constant, or texture memory) might need to be re- issued multiple times depending on the distribution of the memory addresses across the threads within the warp. How the distribution affects the instruction throughput this way is specific to each type of memory and described in the following sections. For example, for global memory, as a general rule, the more scattered the addresses are, the more reduced the throughput is."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Global Memory - Global memory resides in devic...",
    "content": "Global memory resides in device memory and device memory is accessed via 32- , 64- , or 128- byte memory transactions. These memory transactions must be naturally aligned: Only the 32- , 64- , or 128- byte segments of device memory that are aligned to their size (i.e., whose first address is a multiple of their size) can be read or written by memory transactions."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Global Memory - When a warp executes an instru...",
    "content": "When a warp executes an instruction that accesses global memory, it coalesces the memory accesses of the threads within the warp into one or more of these memory transactions depending on the size of the word accessed by each thread and the distribution of the memory addresses across the threads. In general, the more transactions are necessary, the more unused words are transferred in addition to the words accessed by the threads, reducing the instruction throughput accordingly. For example, if a 32- byte memory transaction is generated for each thread's 4- byte access, throughput is divided by 8."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Global Memory - How many transactions are nece......To maximize global memory thro...",
    "content": "How many transactions are necessary and how much throughput is ultimately affected varies with the compute capability of the device. Compute Capability 5. x, Compute Capability 6. x, Compute Capability 7. x, Compute Capability 8. x and Compute Capability 9.0 give more details on how global memory accesses are handled for various compute capabilities.\n\nTo maximize global memory throughput, it is therefore important to maximize coalescing by:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Global Memory - Following the most optimal acc...",
    "content": "- Following the most optimal access patterns based on Compute Capability 5. x, Compute Capability 6. x, Compute Capability 7. x, Compute Capability 8. x and Compute Capability 9.0- Using data types that meet the size and alignment requirement detailed in the section Size and Alignment Requirement below,- Padding data in some cases, for example, when accessing a two-dimensional array as described in the section Two-Dimensional Arrays below."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Size and Alignment Requirement - Global memory instructions sup......The alignment requirement is a...",
    "content": "Global memory instructions support reading or writing words of size equal to 1, 2, 4, 8, or 16 bytes. Any access (via a variable or a pointer) to data residing in global memory compiles to a single global memory instruction if and only if the size of the data type is 1, 2, 4, 8, or 16 bytes and the data is naturally aligned (i.e., its address is a multiple of that size).\n\nIf this size and alignment requirement is not fulfilled, the access compiles to multiple instructions with interleaved access patterns that prevent these instructions from fully coalescing. It is therefore recommended to use types that meet this requirement for data that resides in global memory.\n\nThe alignment requirement is automatically fulfilled for the Built- in Vector Types."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Size and Alignment Requirement - For structures the size and al......Any address of a variable resi...",
    "content": "For structures, the size and alignment requirements can be enforced by the compiler using the alignment specifiers__align__(8) or __align__(16), such as struct _align__(8) { float x; float y; }; or struct _align__(16) { float x; float y; float z; };\n\nAny address of a variable residing in global memory or returned by one of the memory allocation routines from the driver or runtime API is always aligned to at least 256 bytes."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Size and Alignment Requirement - Reading non naturally aligned ...",
    "content": "Reading non- naturally aligned 8- byte or 16- byte words produces incorrect results (off by a few words), so special care must be taken to maintain alignment of the starting address of any value or array of values of these types. A typical case where this might be easily overlooked is when using some custom global memory allocation scheme, whereby the allocations of multiple arrays (with multiple calls to cudaMalloc() or cuMemAlloc()) is replaced by the allocation of a single large block of memory partitioned into multiple arrays, in which case the starting address of each array is offset from the block's starting address."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Two-Dimensional Arrays - A common global memory access ......For these accesses to be fully...",
    "content": "A common global memory access pattern is when each thread of index (tx, ty) uses the following address to access one element of a 2D array of width width, located at address BaseAddress of type type* (where type meets the requirement described in Maximize Utilization):\n\nBaseAddress + width * ty + tx\n\nFor these accesses to be fully coalesced, both the width of the thread block and the width of the array must be a multiple of the warp size."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Two-Dimensional Arrays - In particular this means that ...",
    "content": "In particular, this means that an array whose width is not a multiple of this size will be accessed much more efficiently if it is actually allocated with a width rounded up to the closest multiple of this size and its rows padded accordingly. The cudaMallocPitch() and cuMemAllocPitch() functions and associated memory copy functions described in the reference manual enable programmers to write non- hardware- dependent code to allocate arrays that conform to these constraints."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Local Memory - Local memory accesses only occ......Arrays for which it cannot det...",
    "content": "Local memory accesses only occur for some automatic variables as mentioned in Variable Memory Space Specifiers. Automatic variables that the compiler is likely to place in local memory are:\n\nArrays for which it cannot determine that they are indexed with constant quantities, Large structures or arrays that would consume too much register space, Any variable if the kernel uses more registers than available (this is also known as register spilling)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Local Memory - Inspection of the PTX assembly...",
    "content": "Inspection of the PTX assembly code (obtained by compiling with the - ptx or- keep option) will tell if a variable has been placed in local memory during the first compilation phases as it will be declared using the .local mnemonic and accessed using the ld .local and st .local mnemonics. Even if it has not, subsequent compilation phases might still decide otherwise though if they find it consumes too much register space for the targeted architecture: Inspection of the cubin object using cubbjdump will tell if this is the case. Also, the compiler reports total local memory usage per kernel (1mem) when compiling with the - - ptxas- options  $\\equiv \\cdot$  - v option. Note that some mathematical functions have implementation paths that might access local memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Local Memory - The local memory space resides......On devices of compute capabili...",
    "content": "The local memory space resides in device memory, so local memory accesses have the same high latency and low bandwidth as global memory accesses and are subject to the same requirements for memory coalescing as described in Device Memory Accesses. Local memory is however organized such that consecutive 32- bit words are accessed by consecutive thread IDs. Accesses are therefore fully coalesced as long as all threads in a warp access the same relative address (for example, same index in an array variable, same member in a structure variable).\n\nOn devices of compute capability 5. x onwards, local memory accesses are always cached in L2 in the same way as global memory accesses (see Compute Capability 5. x and Compute Capability 6. x)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Shared Memory - Because it is on chip shared m......To achieve high bandwidth shar...",
    "content": "Because it is on- chip, shared memory has much higher bandwidth and much lower latency than local or global memory.\n\nTo achieve high bandwidth, shared memory is divided into equally- sized memory modules, called banks, which can be accessed simultaneously. Any memory read or write request made of  $n$  addresses that fall in  $n$  distinct memory banks can therefore be serviced simultaneously, yielding an overall bandwidth that is  $n$  times as high as the bandwidth of a single module."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Shared Memory - However if two addresses of a ...",
    "content": "However, if two addresses of a memory request fall in the same memory bank, there is a bank conflict and the access has to be serialized. The hardware splits a memory request with bank conflicts into as many separate conflict- free requests as necessary, decreasing throughput by a factor equal to the number of separate memory requests. If the number of separate memory requests is  $n$ , the initial memory request is said to cause  $n$ - way bank conflicts."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Shared Memory - To get maximum performance it ...",
    "content": "To get maximum performance, it is therefore important to understand how memory addresses map to memory banks in order to schedule the memory requests so as to minimize bank conflicts. This is described in Compute Capability 5. x, Compute Capability 6. x, Compute Capability 7. x, Compute Capability 8. x, and Compute Capability 9.0 for devices of compute capability 5. x, 6. x, 7. x, 8. x, and 9.0 respectively."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Constant Memory - The constant memory space resi......The resulting requests are the...",
    "content": "The constant memory space resides in device memory and is cached in the constant cache.\n\nA request is then split into as many separate requests as there are different memory addresses in the initial request, decreasing throughput by a factor equal to the number of separate requests.\n\nThe resulting requests are then serviced at the throughput of the constant cache in case of a cache hit, or at the throughput of device memory otherwise."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Texture and Surface Memory - The texture and surface memory......Reading device memory through ...",
    "content": "The texture and surface memory spaces reside in device memory and are cached in texture cache, so a texture fetch or surface read costs one memory read from device memory only on a cache miss, otherwise it just costs one read from texture cache. The texture cache is optimized for 2D spatial locality, so threads of the same warp that read texture or surface addresses that are close together in 2D will achieve best performance. Also, it is designed for streaming fetches with a constant latency, a cache hit reduces DRAM bandwidth demand but not fetch latency.\n\nReading device memory through texture or surface fetching present some benefits that can make it an advantageous alternative to reading device memory from global or constant memory:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Texture and Surface Memory - If the memory reads do not fol...",
    "content": "If the memory reads do not follow the access patterns that global or constant memory reads must follow to get good performance, higher bandwidth can be achieved providing that there is locality in the texture fetches or surface reads; Addressing calculations are performed outside the kernel by dedicated units; Packed data may be broadcast to separate variables in a single operation; 8- bit and 16- bit integer input data may be optionally converted to 32 bit floating- point values in the range [0.0, 1.0] or [- 1.0, 1.0] (see Texture Memory)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.4. Maximize Instruction Throughput - To maximize instruction throug......Minimize the use of arithmetic...",
    "content": "To maximize instruction throughput the application should:\n\nMinimize the use of arithmetic instructions with low throughput; this includes trading precision for speed when it does not affect the end result, such as using intrinsic instead of regular functions (intrinsic functions are listed in Intrinsic Functions), single- precision instead of doubleprecision, or flushing denormalized numbers to zero; Minimize divergent warps caused by control flow instructions as detailed in Control Flow Instructions Reduce the number of instructions, for example, by optimizing out synchronization points whenever possible as described in Synchronization Instruction or by using restricted pointers as described in _restrict_."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.4. Maximize Instruction Throughput - In this section throughputs ar......All throughputs are for one mu...",
    "content": "In this section, throughputs are given in number of operations per clock cycle per multiprocessor. For a warp size of 32, one instruction corresponds to 32 operations, so if N is the number of operations per clock cycle, the instruction throughput is N/32 instructions per clock cycle.\n\nAll throughputs are for one multiprocessor. They must be multiplied by the number of multiprocessors in the device to get throughput for the whole device."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.4.1. Arithmetic Instructions - Table 3 gives the throughputs ......Table 1 Table 3 Throughput of ...",
    "content": "Table 3 gives the throughputs of the arithmetic instructions that are natively supported in hardware for devices of various compute capabilities.\n\nTable 1: Table 3. Throughput of Native Arithmetic Instructions. (Number of Results per Clock Cycle per Multiprocessor)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.4.1. Arithmetic Instructions - tabletrtdCompute Capabilitytdt...",
    "content": "<table><tr><td>Compute Capability</td><td>5.0, 5.2</td><td>5.3</td><td>6.0</td><td>6.1</td><td>6.2</td><td>7.x</td><td>8.0</td><td>8.6</td><td>8.9</td><td>9."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.4.1. Arithmetic Instructions - 0tdtrtrtd16bit floatingpoint a...",
    "content": "0</td></tr><tr><td>16-bit floating-point add, multiply, multiply-add</td><td>N/A</td><td>256</td><td>128</td><td>2</td><td>256</td><td>128</td><td>256³</td><td></td><td>128</td><td>256</td></tr><tr><td>32-bit floating-point add, multiply, multiply-add</td><td>128</td><td></td><td>64</td><td>128</td><td></td><td>64</td><td></td><td>128</td><td></td><td></td></tr><tr><td>64-bit floating-point add, multiply, multiply-add</td><td>4</td><td></td><td>32</td><td>4</td><td></td><td>32⁵</td><td>32</td><td>2</td><td></td><td>64</td></tr><tr><td>32-bit floating-point reciprocal, re-ciprocal square root, base-2 logarithm (_log2f), base 2 exponential (exp2f), sine (_sinf), cosine (_cosf)</td><td>32</td><td></td><td>16</td><td>32</td><td></td><td>16</td><td></td><td></td><td></td><td></td></tr><tr><td>3"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.4.1. Arithmetic Instructions - 2bit integer add extendedpreci...",
    "content": "2-bit integer add, extended-precision add, subtract, extended-precision subtract</td><td>128</td><td></td><td>64</td><td>128</td><td></td><td>64</td><td></td><td></td><td></td><td></td></tr><tr><td>32-bit integer multiply, multiply-add, extended-precision multiply-add</td><td colspan=\"5\">Multiple instruct."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.4.1. Arithmetic Instructions - tdtd64tdtdtdtdtdtdtdtdtdtrtrtd...",
    "content": "</td><td>64⁶</td><td></td><td></td><td></td><td></td></tr><tr><td>24-bit integer multiply ( __ [u]mu124)</td><td colspan=\"10\">Multiple instruct.</td></tr><tr><td>32-bit integer shift</td><td>64</td><td></td><td>32</td><td>64</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>compare, minimum, maximum</td><td>64</td><td></td><td>32</td><td>64</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>32-bit integer bit reverse</td><td>64</td><td></td><td>32</td><td>64</td><td></td><td>16</td><td></td><td></td><td></td><td></td></tr><tr><td>Bit field extract/insert</td><td>64</td><td></td><td>32</td><td>64</td><td></td><td>Multiple In-struct."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.4.1. Arithmetic Instructions - tdtdtdtd64tdtdtdtdtdtrtrtd32bi...",
    "content": "</td><td></td><td>64</td><td></td><td></td></tr><tr><td>32-bit bitwise AND, OR, XOR</td><td>128</td><td></td><td>64</td><td>128</td><td></td><td>64</td><td></td><td></td><td></td><td></td></tr><tr><td>count of leading zeros, most signifi-cant non-sign bit</td><td colspan=\"10\">32 | 16 | 32 | 16</td></tr><tr><td>population count</td><td>32</td><td></td><td>16</td><td>32</td><td></td><td>16</td><td></td><td></td><td></td><td></td></tr><tr><td>warp shuffle</td><td colspan=\"5\">32</td><td>32⁸</td><td>32</td><td></td><td></td><td></td></tr><tr><td>warp reduce</td><td colspan=\"6\">Multiple instruct."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.4.1. Arithmetic Instructions - tdtd16tdtdtdtdtdtdtdtrtrtdwarp...",
    "content": "</td><td>16</td><td></td><td></td><td></td></tr><tr><td>warp vote</td><td>64</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>sum of absolute difference</td><td>64</td><td></td><td>32</td><td>64</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>SIMD video instructions vabsdiff2</td><td colspan=\"10\">Multiple instruct.</td></tr><tr><td>SIMD video instructions vabsdiff4</td><td colspan=\"5\">Multiple instruct.</td><td>64</td><td></td><td></td><td></td><td></td></tr><tr><td>All other SIMD video instructions</td><td colspan=\"10\">Multiple instruct."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.4.1. Arithmetic Instructions - tdtrtrtdType conversions from ...",
    "content": "</td></tr><tr><td>Type conversions from 8-bit and 16-bit integer to 32-bit integer types</td><td>32</td><td></td><td>16</td><td>32</td><td></td><td>64</td><td></td><td></td><td></td><td></td></tr><tr><td>Type conversions from and to 64-bit types</td><td>4</td><td></td><td>16</td><td>4</td><td></td><td>16¹⁰</td><td>16</td><td>2</td><td>2</td><td>16</td></tr><tr><td>All other type conversions</td><td>32</td><td></td><td>16</td><td>32</td><td></td><td colspan=\"5\">16</td></tr><tr><td>144</td><td rowspan=\"2\" colspan=\"5\">Multiple instruct.</td><td rowspan=\"2\" colspan=\"5\">Chapter 8. Performance Guidelines</td></tr><tr><td>16-bit DPX</td></tr><tr><td>32-bit DPX</td><td colspan=\"9\">Multiple instruct.</td><td>64</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.4.1. Arithmetic Instructions - Other instructions and functio......The implementation of some fun...",
    "content": "Other instructions and functions are implemented on top of the native instructions. The implementation may be different for devices of different compute capabilities, and the number of native instructions after compilation may fluctuate with every compiler version. For complicated functions, there can be multiple code paths depending on input. cuobjdump can be used to inspect a particular implementation in a cubin object.\n\nThe implementation of some functions are readily available on the CUDA header files (math_functions.h, device_functions.h, ...)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.4.1. Arithmetic Instructions - In general code compiled with ...",
    "content": "In general, code compiled with - ftz=true (denormalized numbers are flushed to zero) tends to have higher performance than code compiled with - ftz=false. Similarly, code compiled with - prec- div=false (less precise division) tends to have higher performance code than code compiled with - prec- div=true, and code compiled with - prec- sqrt=false (less precise square root) tends to have higher performance than code compiled with - prec- sqrt=true. The nvcc user manual describes these compilation flags in more details."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Square Root - fdividefx y see Intrinsic Func......Single precision floating poin...",
    "content": "# Single-Precision Floating-Point Division\n__fdividef(x, y) (see Intrinsic Functions) provides faster single- precision floating- point division than the division operator.\n\n# Single-Precision Floating-Point Reciprocal Square Root\nTo preserve IEEE- 754 semantics the compiler can optimize 1.0/sqrtf() into rsqrtf() only when both reciprocal and square root are approximate, (i.e., with - prec- div=false and - prec- sqrt=false). It is therefore recommended to invoke rsqrtf() directly where desired.\n\n# Single-Precision Floating-Point Square Root\nSingle- precision floating- point square root is implemented as a reciprocal square root followed by a reciprocal instead of a reciprocal square root followed by a multiplication so that it gives correct results for O and infinity."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Sine and Cosine - sin fx   cos fx   tan fx   sin......The fast path is used for argu...",
    "content": "$\\sin f(x)$ ,  $\\cos f(x)$ ,  $\\tan f(x)$ ,  $\\sin \\cos f(x)$ , and corresponding double- precision instructions are much more expensive and even more so if the argument  $x$  is large in magnitude.\n\nMore precisely, the argument reduction code (see Mathematical Functions for implementation) comprises two code paths referred to as the fast path and the slow path, respectively.\n\nThe fast path is used for arguments sufficiently small in magnitude and essentially consists of a few multiply- add operations. The slow path is used for arguments large in magnitude and consists of lengthy computations required to achieve correct results over the entire argument range."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Sine and Cosine - At present the argument reduct......As the slow path requires more...",
    "content": "At present, the argument reduction code for the trigonometric functions selects the fast path for arguments whose magnitude is less than 105615.0f for the single- precision functions, and less than 2147483648.0 for the double- precision functions.\n\nAs the slow path requires more registers than the fast path, an attempt has been made to reduce register pressure in the slow path by storing some intermediate variables in local memory, which may affect performance because of local memory high latency and bandwidth (see Device Memory Accesses). At present, 28 bytes of local memory are used by single- precision functions, and 44 bytes are used by double- precision functions. However, the exact amount is subject to change."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Sine and Cosine - Due to the lengthy computation...",
    "content": "Due to the lengthy computations and use of local memory in the slow path, the throughput of these trigonometric functions is lower by one order of magnitude when the slow path reduction is required as opposed to the fast path reduction."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Integer Arithmetic - Integer division and modulo op......brev and popc map to a single ...",
    "content": "# Integer Arithmetic\nInteger division and modulo operation are costly as they compile to up to 20 instructions. They can be replaced with bitwise operations in some cases: If n is a power of 2, (i/n) is equivalent to  $(i > > \\log 2(n))$  and  $(i\\% n)$  is equivalent to  $(i\\& (n - 1))$ ; the compiler will perform these conversions if n is literal.\n\nbrev and __popc map to a single instruction and __brev11 and __popc11 to a few instructions. __[u]mu124 are legacy intrinsic functions that no longer have any reason to be used."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Half Precision Arithmetic - In order to achieve good perfo......The intrinsic halves2bfloat162...",
    "content": "# Half Precision Arithmetic\nIn order to achieve good performance for 16- bit precision floating- point add, multiply or multiply- add, it is recommended that the half2 datatype is used for half precision and __nv_bfloat162 be used for __nv_bfloat16 precision. Vector intrinsics (for example, __hadd2, __hsub2, __hmul2, __hfma2) can then be used to do two operations in a single instruction. Using half2 or __nv_bfloat162 in place of two calls using half or __nv_bfloat16 may also help performance of other intrinsics, such as warp shuffles.\n\nThe intrinsic __halves2half2 is provided to convert two half precision values to the half2 datatype.\n\nThe intrinsic __halves2bfloat162 is provided to convert two __nv_bfloat precision values to the __nv_bfloat162 datatype."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Type Conversion - Sometimes the compiler must in......This last case can be avoided ...",
    "content": "# Type Conversion\nSometimes, the compiler must insert conversion instructions, introducing additional execution cycles. This is the case for:\n\nFunctions operating on variables of type char or short whose operands generally need to be converted to int, Double- precision floating- point constants (i.e., those constants defined without any type suffix) used as input to single- precision floating- point computations (as mandated by  $C / C + +$  standards).\n\nThis last case can be avoided by using single- precision floating- point constants, defined with an f suffix such as 3.141592653589793f, 1.0f, 0.5f."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.4.2. Control Flow Instructions - Any flow control instruction i...",
    "content": "Any flow control instruction (if, switch, do, for, while) can significantly impact the effective instruction throughput by causing threads of the same warp to diverge (i.e., to follow different execution paths). If this happens, the different executions paths have to be serialized, increasing the total number of instructions executed for this warp."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.4.2. Control Flow Instructions - To obtain best performance in ...",
    "content": "To obtain best performance in cases where the control flow depends on the thread ID, the controlling condition should be written so as to minimize the number of divergent warps. This is possible because the distribution of the warps across the block is deterministic as mentioned in SIMT Architecture. A trivial example is when the controlling condition only depends on (threadIdx / warpSize) where warpSize is the warp size. In this case, no warp diverges since the controlling condition is perfectly aligned with the warps."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.4.2. Control Flow Instructions - Sometimes the compiler may unr...",
    "content": "Sometimes, the compiler may unroll loops or it may optimize out short if or switch blocks by using branch predication instead, as detailed below. In these cases, no warp can ever diverge. The programmer can also control loop unrolling using the #pragma unroll directive (see #pragma unroll)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.4.2. Control Flow Instructions - When using branch predication ...",
    "content": "When using branch predication none of the instructions whose execution depends on the controlling condition gets skipped. Instead, each of them is associated with a per- thread condition code or predicate that is set to true or false based on the controlling condition and although each of these instructions gets scheduled for execution, only the instructions with a true predicate are actually executed. Instructions with a false predicate do not write results, and also do not evaluate addresses or read operands."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.4.3. Synchronization Instruction - Throughput for syncthreads is ......Note that syncthreads can impa...",
    "content": "Throughput for __syncthreads() is 32 operations per clock cycle for devices of compute capability 6.0, 16 operations per clock cycle for devices of compute capability 7. x as well as 8. x and 64 operations per clock cycle for devices of compute capability 5. x, 6.1 and 6.2.\n\nNote that __syncthreads() can impact performance by forcing the multiprocessor to idle as detailed in Device Memory Accesses."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.5. Minimize Memory Thrashing - Applications that constantly a...",
    "content": "Applications that constantly allocate and free memory too often may find that the allocation calls tend to get slower over time up to a limit. This is typically expected due to the nature of releasing memory back to the operating system for its own use. For best performance in this regard, we recommend the following:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.5. Minimize Memory Thrashing - Try to size your allocation to...",
    "content": "Try to size your allocation to the problem at hand. Don't try to allocate all available memory with cudaMalloc / cudaMallocHost / cuMemCreate, as this forces memory to be resident immediately and prevents other applications from being able to use that memory. This can put more pressure on operating system schedulers, or just prevent other applications using the same GPU from running entirely. Try to allocate memory in appropriately sized allocations early in the application and allocations only when the application does not have any use for it. Reduce the number of cudaMalloc + cudaFree calls in the application, especially in performance- critical regions."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "8.5. Minimize Memory Thrashing - If an application cannot alloc...",
    "content": " If an application cannot allocate enough device memory, consider falling back on other memory types such as cudaMallocHost or cudaMallocManaged, which may not be as performant, but will enable the application to make progress. For platforms that support the feature, cudaMallocManaged allows for oversubscription, and with the correct cudaMemAdvise policies enabled, will allow the application to retain most if not all the performance of cudaMalloc. cudaMallocManaged also won't force an allocation to be resident until it is needed or prefetched, reducing the overall pressure on the operating system schedulers and better enabling multi- tenet use cases."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.1. Function Execution Space Specifiers - httpsdevelopernvidiacomcuda gp......Function execution space speci...",
    "content": "# CUDA C++ Programming Guide, Release 12.1\n\n\n# Chapter 9. CUDA-Enabled GPUs\nhttps://developer.nvidia.com/cuda- gpus lists all CUDA- enabled devices with their compute capability.\n\nThe compute capability, number of multiprocessors, clock frequency, total amount of device memory, and other properties can be queried using the runtime (see reference manual).\n\n# CUDA C++ Programming Guide, Release 12.1\n\n\n# Chapter 10. C++ Language Extensions\n\n\n# 10.1. Function Execution Space Specifiers\nFunction execution space specifiers denote whether a function executes on the host or on the device and whether it is callable from the host or from the device."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.1.1. global - The   global   execution space......A call to a   global   functio...",
    "content": "# 10.1.1. global\nThe  $\\_$ global  $\\_$ execution space specifier declares a function as being a kernel. Such a function is:\n\n- Executed on the device,- Callable from the host,- Callable from the device for devices of compute capability 5.0 or higher (see CUDA Dynamic Parallelism for more details).\n\nA  $\\_$ global  $\\_$ function must have void return type, and cannot be a member of a class.\n\nAny call to a  $\\_$ global  $\\_$ function must specify its execution configuration as described in Execution Configuration.\n\nA call to a  $\\_$ global  $\\_$ function is asynchronous, meaning it returns before the device has completed its execution."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.1.2. device - The   device   execution space......The   global   and   device   ...",
    "content": "The  $\\_$ device  $\\_$ execution space specifier declares a function that is:\n\n- Executed on the device,- Callable from the device only.\n\nThe  $\\_$ global  $\\_$ and  $\\_$ device  $\\_$ execution space specifiers cannot be used together."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.1.3. host - The host execution space speci......The device and host execution ...",
    "content": "The __host__ execution space specifier declares a function that is:\n\n- Executed on the host,- Callable from the host only.\n\nIt is equivalent to declare a function with only the __host__ execution space specifier or to declare it without any of the __host__-_device__ or __global__ execution space specifier; in either case the function is compiled for the host only.\n\nThe __global__ and __host__ execution space specifiers cannot be used together.\n\nThe __device__ and __host__ execution space specifiers can be used together however, in which case the function is compiled for both the host and the device. The __CUDA_ARCH__ macro introduced in Application Compatibility can be used to differentiate code paths between host and device:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.1.3. host - pythonhost device func     if ...",
    "content": "```python__host__ __device__ func() {    #if __CUDA_ARCH__ >= 800    // Device code path for compute capability 8. x    #elif __CUDA_ARCH__ >= 700        // Device code path for compute capability 7. x    #elif __CUDA_ARCH__ >= 600        // Device code path for compute capability 6. x    #elif __CUDA_ARCH__ >= 500        // Device code path for compute capability 5. x    #elif !defined(__CUDA_ARCH__)        #endif    #if}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.1.5. __noinline__ and __forceinline__ - A cross execution space call h......The noinline and forceinline f...",
    "content": "# 10.1.4. Undefined behavior\nA 'cross- execution space' call has undefined behavior when:\n\n```python__CUDA_ARCH__ is defined, a call from within a __global__-_device__ or __host__ __device__ function to a __host__ function.__CUDA_ARCH__ is undefined, a call from within a __host__ function to a __device__ function.```\n\n# 10.1.5. __noinline__ and __forceinline__\nThe compiler inlines any __device__ function when deemed appropriate.\n\nThe __noinline__ function qualifier can be used as a hint for the compiler not to inline the function if possible.\n\nThe __forceinline__ function qualifier can be used to force the compiler to inline the function.\n\nThe __noinline__ and __forceinline__ function qualifiers cannot be used together, and neither function qualifier can be applied to an inline function."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.2. Variable Memory Space Specifiers - Variable memory space specifie......An automatic variable declared...",
    "content": "Variable memory space specifiers denote the memory location on the device of a variable.\n\nAn automatic variable declared in device code without any of the __device__, __shared__ and __constant__ memory space specifiers described in this section generally resides in a register. However in some cases the compiler might choose to place it in local memory, which can have adverse performance consequences as detailed in Device Memory Accesses."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.2.1. __device__ - The device memory space specif......Resides in global memory space...",
    "content": "# 10.2.1. __device__\nThe __device__ memory space specifier declares a variable that resides on the device.\n\nAt most one of the other memory space specifiers defined in the next three sections may be used together with __device__ to further denote which memory space the variable belongs to. If none of them is present, the variable:\n\nResides in global memory space, Has the lifetime of the CUDA context in which it is created, Has a distinct object per device, Is accessible from all the threads within the grid and from the host through the runtime library (cudaGetSymbolAddress() / cudaGetSymbolSize() / cudaMempcyToSymbol() / cudaMempcyFromSymbol())."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.2.2. __constant__ - The constant memory space spec......Resides in constant memory spa...",
    "content": "The __constant__ memory space specifier, optionally used together with __device__, declares a variable that:\n\nResides in constant memory space, Has the lifetime of the CUDA context in which it is created, Has a distinct object per device, Is accessible from all the threads within the grid and from the host through the runtime library (cudaGetSymbolAddress() / cudaGetSymbolSize() / cudaMempcyToSymbol() / cudaMempcyFromSymbol())."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.2.3. __shared__ - The shared memory space specif......the size of the array is deter...",
    "content": "The __shared__ memory space specifier, optionally used together with __device__, declares a variable that:\n\nResides in the shared memory space of a thread block, Has the lifetime of the block, Has a distinct object per block,\n\n- Is only accessible from all the threads within the block,- Does not have a constant address.\n\nWhen declaring a variable in shared memory as an external array such as extern __shared__ float shared[];\n\nthe size of the array is determined at launch time (see Execution Configuration). All variables declared in this fashion, start at the same address in memory, so that the layout of the variables in the array must be explicitly managed through offsets. For example, if one wants the equivalent of short array0[128]; float array1[64]; int array2[256];"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.2.3. __shared__ - in dynamically allocated share......Alignment requirements for the...",
    "content": "in dynamically allocated shared memory, one could declare and initialize the arrays the following way:\n\nextern __shared__ float array[]; __device__ void func() // __device__ or __global__ function { short* array0 = (short*)array; float* array1 = (float*)&array0[128]; int* array2 = (int*)&array1[64]; }\n\nNote that pointers need to be aligned to the type they point to, so the following code, for example, does not work since array1 is not aligned to 4 bytes.\n\nextern __shared__ float array[]; __device__ void func() // __device__ or __global__ function { short* array0 = (short*)array; float* array1 = (float*)&array0[127]; }\n\nAlignment requirements for the built- in vector types are listed in Table 5."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.2.4. __grid_constant__ - The gridconstant annotation fo......Kernel parameters annotated wi...",
    "content": "The __grid_constant__ annotation for compute architectures greater or equal to 7.0 annotates a const- qualified __global__ function parameter of non- reference type that:\n\n- Has the lifetime of the grid,- Is private to the grid, i.e., the object is not accessible to host threads and threads from other grids, including sub-grids,- Has a distinct object per grid, i.e., all threads in the grid see the same address,- Is read-only, i.e., modifying a __grid_constant__ object or any of its sub-objects is undefined behavior, including mutable members.\n\nRequirements:\n\n- Kernel parameters annotated with __grid_constant__ must have const-qualified non-reference types.- All function declarations must match with respect to any __grid_constant__ parameters."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.2.4. __grid_constant__ - A function template specializa...",
    "content": "- A function template specialization must match the primary template declaration with respect to any __grid_constant__ parameters.- A function template instantiation directive must match the primary template declaration with respect to any __grid_constant__ parameters."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.2.4. __grid_constant__ - If the address of a global fun...",
    "content": "If the address of a __global__ function parameter is taken, the compiler will ordinarily make a copy of the kernel parameter in thread local memory and use the address of the copy, to partially support  $\\mathtt{C + + }$  semantics, which allow each thread to modify its own local copy of function parameters. Annotating a __global__ function parameter with __grid_constant__ ensures that the compiler will not create a copy of the kernel parameter in thread local memory, but will instead use the generic address of the parameter itself. Avoiding the local copy may result in improved performance."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.2.4. __grid_constant__ - cppdevice void unknownfunction...",
    "content": "```cpp__device__ void unknown_function(S const&);__global__ void kernel(const __grid_constant__ S s) {    s.x += threadIdx.x; // Undefined Behavior: tried to modify read- only memory    // Compiler will _not_ create a per- thread thread local copy of \"s\":    unknown_function(s);}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.2.5. __managed__ - The managed memory space speci......See managed Memory Space Speci...",
    "content": "The __managed__ memory space specifier, optionally used together with __device__, declares a variable that:\n\n- Can be referenced from both device and host code, for example, its address can be taken or it can be read or written directly from a device or host function.- Has the lifetime of an application.\n\nSee __managed__ Memory Space Specifier for more details."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.2.6. __restrict__ - nvcc supports restricted point......continues on next page",
    "content": "nvcc supports restricted pointers via the __restrict__ keyword.\n\nRestricted pointers were introduced in C99 to alleviate the aliasing problem that exists in C- type languages, and which inhibits all kind of optimization from code re- ordering to common sub- expression elimination.\n\nHere is an example subject to the aliasing issue, where use of restricted pointer can help the compiler to reduce the number of instructions:\n\n```cppvoid foo(const float* a, const float* b, float* c) {    c[0] = a[0] * b[0];    c[1] = a[0] * b[0];    c[2] = a[0] * b[0] * a[1];    c[3] = a[0] * a[1];    c[4] = a[0] * b[0];    c[5] = b[0];}```\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.2.6. __restrict__ - In C type languages the pointe...",
    "content": "In C- type languages, the pointers a, b, and c may be aliased, so any write through c could modify elements of a or b. This means that to guarantee functional correctness, the compiler cannot load a[0] and b[0] into registers, multiply them, and store the result to both c[0] and c[1], because the results would differ from the abstract execution model if, say, a[0] is really the same location as c[0]. So the compiler cannot take advantage of the common sub- expression. Likewise, the compiler cannot just reorder the computation of c[4] into the proximity of the computation of c[0] and c[1] because the preceding write to c[3] could change the inputs to the computation of c[4]."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.2.6. __restrict__ - By making a b and c restricted......Note that all pointer argument...",
    "content": "By making a, b, and c restricted pointers, the programmer asserts to the compiler that the pointers are in fact not aliased, which in this case means writes through c would never overwrite elements of a or b. This changes the function prototype as follows:\n\n```cvoid foo(const float* __restrict__ a, const float* __restrict__ b, float* __restrict__ c);```\n\nNote that all pointer arguments need to be made restricted for the compiler optimizer to derive any benefit. With the __restrict__ keywords added, the compiler can now reorder and do common sub- expression elimination at will, while retaining functionality identical with the abstract execution model:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.2.6. __restrict__ - void fooconst float restrict a...",
    "content": "void foo(const float\\* _restrict__ a, const float\\* _restrict__ b, float\\* _restrict__ c) { float  $\\mathrm{\\bf t}\\theta = \\mathrm{\\bf a}[\\theta ]$  float  $\\mathrm{\\bf t1} = \\mathrm{\\bf b}[\\theta ]$  float  $\\mathrm{\\bf t2} = \\mathrm{\\bf t}\\theta \\mathrm{\\bf\\Omega}^{\\ast}\\mathrm{\\bf t1}$  float  $\\mathrm{\\bf t3} = \\mathrm{\\bf a}[\\mathrm{\\bf 1}]$  .  $\\begin{array}{rl}{\\mathsf{c}[\\Theta ]} & {= \\mathsf{t}2;}\\\\ {\\mathsf{c}[\\mathsf{1}]} & {= \\mathsf{t}2;}\\\\ {\\mathsf{c}[\\mathsf{4}]} & {= \\mathsf{t}2;}\\\\ {\\mathsf{c}[\\mathsf{2}]} & {= \\mathsf{t}2\\mathrm{\\Omega}^{\\ast}\\mathsf{t}3;}\\\\ {\\mathsf{c}[\\mathsf{3}]} & {= \\mathsf{t}\\Theta \\mathrm{\\Omega}^{\\ast}\\mathsf{t}3;}\\\\ {\\mathsf{c}[\\mathsf{5}]} & {= \\mathsf{t}1;} \\end{array}$"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.2.6. __restrict__ - The effects here are a reduced......Since register pressure is a c...",
    "content": "The effects here are a reduced number of memory accesses and reduced number of computations. This is balanced by an increase in register pressure due to \"cached\" loads and common sub- expressions.\n\nSince register pressure is a critical issue in many CUDA codes, use of restricted pointers can have negative performance impact on CUDA code, due to reduced occupancy."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.3. Built-in Vector Types",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.3.1. char, short, int, long, longlong, float, double - These are vector types derived......Table 1Table 5Alignment Requir...",
    "content": "These are vector types derived from the basic integer and floating- point types. They are structures and the 1st, 2nd, 3rd, and 4th components are accessible through the fields x, y, z, and w, respectively. They all come with a constructor function of the form make_<type name>; for example,\n\nint2 make_int2(int x, int y);\n\nwhich creates a vector of type int2 with value  $(x, y)$ .\n\nThe alignment requirements of the vector types are detailed in Table 5.\n\nTable 1:Table 5.Alignment Requirements"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.3.1. char, short, int, long, longlong, float, double - tabletrtdTypetdtdAlignmenttdtr...",
    "content": "<table><tr><td>Type</td><td>Alignment</td></tr><tr><td>char1, uchar1</td><td>1</td></tr><tr><td>char2, uchar2</td><td>2</td></tr><tr><td>char3, uchar3</td><td>1</td></tr><tr><td>char4, uchar4</td><td>4</td></tr><tr><td>short1, ushort1</td><td>2</td></tr><tr><td>short2, ushort2</td><td>4</td></tr><tr><td>short3, ushort3</td><td>2</td></tr><tr><td>short4, ushort4</td><td>8</td></tr><tr><td>int1, uint1</td><td>4</td></tr><tr><td>int2, uint2</td><td>8</td></tr><tr><td>int3, uint3</td><td>4</td></tr><tr><td>int4, uint4</td><td>16</td></tr><tr><td>long1, ulong1</td><td>4 if sizeof(long) is equal to sizeof(int) 8, otherwise</td></tr><tr><td>long2, ulong2</td><td>8 if sizeof(long) is equal to sizeof(int), 16, otherwise</td></tr><tr><td>long3, ulong3</td><td>4 if sizeof(long) is equal to sizeof(int"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.3.1. char, short, int, long, longlong, float, double - 8 otherwisetdtrtrtdlong4 ulong...",
    "content": "), 8, otherwise</td></tr><tr><td>long4, ulong4</td><td>16</td></tr><tr><td>longlong1, ulonglong1</td><td>8</td></tr><tr><td>longlong2, ulonglong2</td><td>16</td></tr><tr><td>longlong3, ulonglong3</td><td>8</td></tr><tr><td>longlong4, ulonglong4</td><td>16</td></tr><tr><td>float1</td><td>4</td></tr><tr><td>float2</td><td>8</td></tr><tr><td>float3</td><td>4</td></tr><tr><td>float4</td><td>16</td></tr><tr><td>double1</td><td>8</td></tr><tr><td>double2</td><td>16</td></tr><tr><td>double3</td><td>8</td></tr><tr><td>double4</td><td>16</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.4.2. blockIdx - 1032 dim3This type is an integ......1042 blockIdxThis variable is ...",
    "content": "# 10.3.2. dim3\n10.3.2. dim3This type is an integer vector type based on uint3 that is used to specify dimensions. When defining a variable of type dim3, any component left unspecified is initialized to 1.\n\n# 10.4. Built-in Variables\n10.4. Built- in VariablesBuilt- in variables specify the grid and block dimensions and the block and thread indices. They are only valid within functions that are executed on the device.\n\n# 10.4.1. gridDim\n10.4.1. gridDimThis variable is of type dim3 (see dim3) and contains the dimensions of the grid.\n\n# 10.4.2. blockIdx\n10.4.2. blockIdxThis variable is of type uint3 (see char, short, int, long, longlong, float, double) and contains the block index within the grid."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.4.5. warpSize - 1043 blockDimThis variable is ......1045 warpSizeThis variable is ...",
    "content": "10.4.3. blockDimThis variable is of type dim3 (see dim3) and contains the dimensions of the block.\n\n# 10.4.4. threadIdx\n10.4.4. threadIdxThis variable is of type uint3 (see char, short, int, long, longlong, float, double) and contains the thread index within the block.\n\n# 10.4.5. warpSize\n10.4.5. warpSizeThis variable is of type int and contains the warp size in threads (see SIMT Architecture for the definition of a warp)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.5. Memory Fence Functions - The CUDA programming model ass......device int  X  1 textttY  2   ...",
    "content": "The CUDA programming model assumes a device with a weakly- ordered memory model, that is the order in which a CUDA thread writes data to shared memory, global memory, page- locked host memory, or the memory of a peer device is not necessarily the order in which the data is observed being written by another CUDA or host thread. It is undefined behavior for two threads to read from or write to the same memory location without synchronization.\n\nIn the following example, thread 1 executes writeXY (), while thread 2 executes readXY ().\n\ndevice int  $X = 1$ $\\texttt{Y} = 2$  . device void writeXY()  $\\begin{array}{rl} & \\texttt{X} = \\texttt{10};\\\\ & \\texttt{Y} = \\texttt{20}; \\end{array}$  } device void readXY() { int  $\\texttt{B} = \\texttt{Y}$  int  $A = X$  }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.5. Memory Fence Functions - The two threads read and write......is equivalent to cudaatomicthr...",
    "content": "The two threads read and write from the same memory locations X and Y simultaneously. Any datarace is undefined behavior, and has no defined semantics. The resulting values for A and B can be anything.\n\nMemory fence functions can be used to enforce a sequentially- consistent ordering on memory accesses. The memory fence functions differ in the scope in which the orderings are enforced but they are independent of the accessed memory space (shared memory, global memory, page- locked host memory, and the memory of a peer device).\n\nvoid __threadfence_block();\n\nis equivalent to cuda::atomic_thread_fence(cuda::memory_order_seq_cst, cuda::thread_scope_block) and ensures that:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.5. Memory Fence Functions - All writes to all memory made ......void threadfence",
    "content": "All writes to all memory made by the calling thread before the call to __threadfence_block() are observed by all threads in the block of the calling thread as occurring before all writes to all memory made by the calling thread after the call to __threadfence_block(); All reads from all memory made by the calling thread before the call to __threadfence_block() are ordered before all reads from all memory made by the calling thread after the call to __threadfence_block().\n\nvoid __threadfence();"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.5. Memory Fence Functions - is equivalent to cudaatomicthr......before the call to threadfence...",
    "content": "is equivalent to cuda::atomic_thread_fence(cuda::memory_order_seq_cst, cuda::thread_scope_device) and ensures that no writes to all memory made by the calling thread after the call to __threadfence() are observed by any thread in the device as occurring before any write to all memory made by the calling thread before the call to __threadfence().\n\nvoid __threadfence_system();\n\nis equivalent to cuda::atomic_thread_fence(cuda::memory_order_seq_cst, cuda::thread_scope_system) and ensures that all writes to all memory made by the calling thread\n\nbefore the call to __threadfence_system() are observed by all threads in the device, host threads, and all threads in peer devices as occurring before all writes to all memory made by the calling thread after the call to __threadfence_system()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.5. Memory Fence Functions - threadfencesystem is only supp......A equal to 1 and B equal to 2 ...",
    "content": "__threadfence_system() is only supported by devices of compute capability 2. x and higher. In the previous code sample, we can insert fences in the codes as follows:\n\ndevice__ int  $x = 1$ $\\texttt{Y} = 2$  . device__ void writexY()  $\\[ \\begin{align*} & \\text{X} = 10;\\\\ & \\text{Y} = 20;\\\\ & \\text{Y} = 20;\\\\ & \\text{Y} = 20;\\\\ & \\text{Y} = 20;\\\\ & \\text{Y} = 20;\\\\ & \\text{Y} = 20;\\\\ & \\text{Y} = 20;\\\\ & \\text{Y} = 20;\\\\ & \\text{Y} = 20;\\\\ \\end{align*} \\]$  device__ void readxY() int  $B = Y$  . _threadfence(); int  $A = X$  .\n\nFor this code, the following outcomes can be observed:\n\n- A equal to 1 and B equal to 2,- A equal to 10 and B equal to 2,- A equal to 10 and B equal to 20."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.5. Memory Fence Functions - The fourth outcome is not poss...",
    "content": "The fourth outcome is not possible, because the first write must be visible before the second write. If thread 1 and 2 belong to the same block, it is enough to use __threadfence_block(). If thread 1 and 2 do not belong to the same block, __threadfence() must be used if they are CUDA threads from the same device and __threadfence_system() must be used if they are CUDA threads from two different devices."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.5. Memory Fence Functions - A common use case is when thre...",
    "content": "A common use case is when threads consume some data produced by other threads as illustrated by the following code sample of a kernel that computes the sum of an array of N numbers in one call. Each block first sums a subset of the array and stores the result in global memory. When all blocks are done, the last block done reads each of these partial sums from global memory and sums them to obtain the final result. In order to determine which block is finished last, each block atomically increments a counter to signal that it is done with computing and storing its partial sum (see Atomic Functions about atomic functions). The last block is the one that receives the counter value equal to gridDim. x- 1."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.5. Memory Fence Functions - If no fence is placed between ...",
    "content": " If no fence is placed between storing the partial sum and incrementing the counter, the counter might increment before the partial sum is stored and therefore, might reach gridDim. x- 1 and let the last block start reading partial sums before they have been actually updated in memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.5. Memory Fence Functions - Memory fence functions only af......continues on next page",
    "content": "Memory fence functions only affect the ordering of memory operations by a thread; they do not, by themselves, ensure that these memory operations are visible to other threads (like __syncthreads() does for threads within a block (see Synchronization Functions)). In the code sample below, the visibility of memory operations on the result variable is ensured by declaring it as volatile (see Volatile Qualifier).\n\n__device__ unsigned int count = 0;__shared__ bool isLastBlockDone;__global__ void sum(const float* array, unsigned int N, volatile float* result)\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.5. Memory Fence Functions - Each block sums a subset of th...",
    "content": "{    // Each block sums a subset of the input array.    float partialSum = calculatePartialSum(array, N);    if (threadIdx.x == 0) {        // Thread 0 of each block stores the partial sum        // to global memory. The compiler will use        // a store operation that bypasses the L1 cache        // since the \"result\" variable is declared as        // volatile. This ensures that the threads of        // the last block will read the correct partial        // sums computed by all other blocks.        result[blockIdx.x] = partialSum;        // Thread 0 makes sure that the incrementation        // of the \"count\" variable is only performed after        // the partial sum has been written to global memory.        _threadfence();        // Thread 0 signals that it is done."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.5. Memory Fence Functions - unsigned int value  atomicIncc...",
    "content": "        unsigned int value = atomicInc(&count, gridDim.x);        // Thread 0 determines if its block is the last        // block to be done.        isLastBlockDone = (value == (gridDim.x - 1));    }    // Synchronize to make sure that each thread reads    // the correct value of isLastBlockDone.    _syncthreads();    if (isLastBlockDone) {        // The last block sums the partial sums        // stored in result[0 .. gridDim.x- 1]        float totalSum = calculateTotalSum(result);        if (threadIdx.x == 0) {            // Thread 0 of last block stores the total sum            // to global memory and resets the count            // variable, so that the next kernel call            // works properly.            result[0] = totalSum;            count = 0;        }    }}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.6. Synchronization Functions - void syncthreads...syncthreads is used to coordin...",
    "content": "void __syncthreads();\n\nwaits until all threads in the thread block have reached this point and all global and shared memory accesses made by these threads prior to __syncthreads() are visible to all threads in the block.\n\n__syncthreads() is used to coordinate communication between the threads of the same block. When some threads within a block access the same addresses in shared or global memory, there are potential read- after- write, write- after- read, or write- after- write hazards for some of these memory accesses. These data hazards can be avoided by synchronizing threads in- between these accesses."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.6. Synchronization Functions - syncthreads is allowed in cond......is identical to syncthreads wi...",
    "content": "__syncthreads() is allowed in conditional code but only if the conditional evaluates identically across the entire thread block, otherwise the code execution is likely to hang or produce unintended side effects.\n\nDevices of compute capability 2. x and higher support three variations of __syncthreads() described below.\n\nint __syncthreads_count(int predicate);\n\nis identical to __syncthreads() with the additional feature that it evaluates predicate for all threads of the block and returns the number of threads for which predicate evaluates to non- zero.\n\nint __syncthreads_and(int predicate);\n\nis identical to __syncthreads() with the additional feature that it evaluates predicate for all threads of the block and returns non- zero if and only if predicate evaluates to non- zero for all of them."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.6. Synchronization Functions - int syncthreadsorint predicate...will cause the executing threa...",
    "content": "int __syncthreads_or(int predicate);\n\nis identical to __syncthreads() with the additional feature that it evaluates predicate for all threads of the block and returns non- zero if and only if predicate evaluates to non- zero for any of them.\n\nvoid __syncwarp(unsigned mask=0xffffffff);\n\nwill cause the executing thread to wait until all warp lanes named in mask have executed a __syncwarp() (with the same mask) before resuming execution. Each calling thread must have its own bit set in the mask and all non- exited threads named in mask must execute a corresponding __syncwarp() with the same mask, or the result is undefined."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.6. Synchronization Functions - Executing syncwarp guarantees ......Note For target sm6x or below ...",
    "content": "Executing __syncwarp() guarantees memory ordering among threads participating in the barrier. Thus, threads within a warp that wish to communicate via memory can store to memory, execute __syncwarp(), and then safely read values stored by other threads in the warp.\n\nNote: For .target sm_6x or below, all threads in mask must execute the same __syncwarp() in convergence, and the union of all values in mask must be equal to the active mask. Otherwise, the behavior is undefined."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.8.1. Texture Object API - The reference manual lists all......Texture objects are described ...",
    "content": "The reference manual lists all  $\\mathtt{C / C + + }$  standard library mathematical functions that are supported in device code and all intrinsic functions that are only supported in device code.\n\nMathematical Functions provides accuracy information for some of these functions when relevant.\n\n# 10.8. Texture Functions\nTexture objects are described in Texture Object APITexture fetching is described in Texture Fetching.\n\n# 10.8.1. Texture Object API\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.8.1.2 tex1D0 - templateclass T T tex1Dfetchcu......fetches from the CUDA array sp...",
    "content": "# 10.8.1.1 tex1Dfetch0\ntemplate<class T> T tex1Dfetch(cudaTextureObject_t texObj, int x);\n\nfetches from the region of linear memory specified by the one- dimensional texture object texObj using integer texture coordinate x. tex1Dfetch() only works with non- normalized coordinates, so only the border and clamp addressing modes are supported. It does not perform any texture filtering. For integer types, it may optionally promote the integer to single- precision floating point.\n\n# 10.8.1.2 tex1D0\ntemplate<class T> T tex1D(cudaTextureObject_t texObj, float x);\n\nfetches from the CUDA array specified by the one- dimensional texture object texObj using texture coordinate x."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.8.1.5 tex2D() - template class T T tex1DcudaTe......fetches from the CUDA array or...",
    "content": "# 10.8.1.3 tex1Dlod0\ntemplate- class T> T tex1D(cudaTextureObject_t texObj, float x);\n\nfetches from the CUDA array specified by the one- dimensional texture object texObj using texture coordinate x at the level- of- detail level.\n\n# 10.8.1.4 tex1DGrad()\ntemplate<class T> T tex1DGrad(cudaTextureObject_t texObj, float x, float dx, float dy);\n\nfetches from the CUDA array specified by the one- dimensional texture object texObj using texture coordinate x. The level- of- detail is derived from the X- gradient dx and Y- gradient dy.\n\n# 10.8.1.5 tex2D()\ntemplate<class T> T tex2D(cudaTextureObject_t texObj, float x, float y);\n\nfetches from the CUDA array or the region of linear memory specified by the two- dimensional texture object texObj using texture coordinate (x, y)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.8.1.7 tex2Dgather() - templateclass T T tex2DcudaTex......fetches from the CUDA array sp...",
    "content": "# 10.8.1.6 tex2D() for sparse CUDA arrays\ntemplate<class T> T tex2D(cudaTextureObject_t texObj, float x, float y, bool\\* isResident);\n\nfetches from the CUDA array specified by the two- dimensional texture object texObj using texture coordinate (x, y). Also returns whether the texel is resident in memory via isResident pointer. If not, the values fetched will be zeros.\n\n# 10.8.1.7 tex2Dgather()\ntemplate<class T> T tex2Dgather(cudaTextureObject_t texObj, float x, float y, int comp = 0);\n\nfetches from the CUDA array specified by the 2D texture object texObj using texture coordinates x and y and the comp parameter as described in Texture Gather."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.8.1.9 tex2DGrad() - templateclass T T tex2Dgatherc......fetches from the CUDA array sp...",
    "content": "# 10.8.1.8 tex2Dgather() for sparse CUDA arrays\ntemplate<class T> T tex2Dgather(cudaTextureObject_t texObj, float x, float y, bool\\* isResident, int comp = 0);\n\nfetches from the CUDA array specified by the 2D texture object texObj using texture coordinates x and y and the comp parameter as described in Texture Gather. Also returns whether the texel is resident in memory via isResident pointer. If not, the values fetched will be zeros.\n\n# 10.8.1.9 tex2DGrad()\ntemplate<class T> T tex2DGrad(cudaTextureObject_t texObj, float x, float y, float2 dx, float2 dy);\n\nfetches from the CUDA array specified by the two- dimensional texture object texObj using texture coordinate (x, y). The level- of- detail is derived from the dx and dy gradients."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.8.1.11 tex2DLod() - templateclass T T tex2DGradcud......fetches from the CUDA array or...",
    "content": "# 10.8.1.10 tex2DGrad() for sparse CUDA arrays\ntemplate<class T> T tex2DGrad(cudaTextureObject_t texObj, float x, float y, float2 dx, float2 dy, bool\\* isResident);\n\nfetches from the CUDA array specified by the two- dimensional texture object texObj using texture coordinate (x, y). The level- of- detail is derived from the dx and dy gradients. Also returns whether the texel is resident in memory via isResident pointer. If not, the values fetched will be zeros.\n\n# 10.8.1.11 tex2DLod()\ntemplate<class T> tex2DLod(cudaTextureObject_t texObj, float x, float y, float level);\n\nfetches from the CUDA array or the region of linear memory specified by the two- dimensional texture object texObj using texture coordinate (x, y) at level- of- detail level."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.8.1.13 tex3D() - templateclass T tex2DLodcudaTe......fetches from the CUDA array sp...",
    "content": "# 10.8.1.12 tex2DLod() for sparse CUDA arrays\ntemplate<class T> tex2DLod(cudaTextureObject_t texObj, float x, float y, float level, bool\\* isResident);\n\nfetches from the CUDA array specified by the two- dimensional texture object texObj using texture coordinate (x, y) at level- of- detail level. Also returns whether the texel is resident in memory via isResident pointer. If not, the values fetched will be zeros.\n\n# 10.8.1.13 tex3D()\ntemplate<class T> T tex3D(cudaTextureObject_t texObj, float x, float y, float z);\n\nfetches from the CUDA array specified by the three- dimensional texture object texObj using texture coordinate (x, y, z)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.8.1.15 tex3DLod() - templateclass T T tex3DcudaTex......fetches from the CUDA array or...",
    "content": "# 10.8.1.14 tex3D() for sparse CUDA arrays\ntemplate<class T> T tex3D(cudaTextureobject_t texObj, float x, float y, float z, bool\\* isResident);\n\nfetches from the CUDA array specified by the three- dimensional texture object texObj using texture coordinate  $(x,y,z)$  . Also returns whether the texel is resident in memory via isResident pointer. If not, the values fetched will be zeros.\n\n# 10.8.1.15 tex3DLod()\ntemplate<class T> T tex3DLod(cudaTextureobject_t texObj, float x, float y, float z, float level);\n\nfetches from the CUDA array or the region of linear memory specified by the three- dimensional texture object texObj using texture coordinate  $(x,y,z)$  at level- of- detail level."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.8.1.17 tex3DGrad() - templateclass T T tex3DLodcuda......fetches from the CUDA array sp...",
    "content": "# 10.8.1.16 tex3DLod() for sparse CUDA arrays\ntemplate<class T> T tex3DLod(cudaTextureobject_t texObj, float x, float y, float z, float level, bool\\* isResident);\n\nfetches from the CUDA array or the region of linear memory specified by the three- dimensional texture object texObj using texture coordinate  $(x,y,z)$  at level- of- detail level. Also returns whether the texel is resident in memory via isResident pointer. If not, the values fetched will be zeros.\n\n# 10.8.1.17 tex3DGrad()\ntemplate<class T> T tex3DGrad(cudaTextureobject_t texObj, float x, float y, float z, float4 dx, float4 dy);\n\nfetches from the CUDA array specified by the three- dimensional texture object texObj using texture coordinate  $(x,y,z)$  at a level- of- detail derived from the X and Y gradients dx and dy."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.8.1.19 tex1DLayered() - templateclass T T tex3DGradcud......fetches from the CUDA array sp...",
    "content": "# 10.8.1.18 tex3DGrad() for sparse CUDA arrays\ntemplate<class T> T tex3DGrad(cudaTextureobject_t texObj, float x, float y, float z, float4 dx, float4 dy, bool\\* isResident);\n\nfetches from the CUDA array specified by the three- dimensional texture object texObj using texture coordinate  $(x,y,z)$  at a level- of- detail derived from the X and Y gradients dx and dy. Also returns whether the texel is resident in memory via isResident pointer. If not, the values fetched will be zeros.\n\n# 10.8.1.19 tex1DLayered()\ntemplate<class T> T tex1DLayered(cudaTextureObject_t texObj, float x, int layer);\n\nfetches from the CUDA array specified by the one- dimensional texture object texObj using texture coordinate x and index layer, as described in Layered Textures"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.8.1.21 tex1DLayeredGrad() - templateclass T T tex1DLayered......fetches from the CUDA array sp...",
    "content": "# 10.8.1.20 tex1DLayeredLod()\ntemplate<class T> T tex1DLayeredlod(cudaTextureObject_t texObj, float x, int layer, float level);\n\nfetches from the CUDA array specified by the one- dimensional layered texture at layer layer using texture coordinate x and level- of- detail level.\n\n# 10.8.1.21 tex1DLayeredGrad()\ntemplate<class T> T tex1DLayeredGrad(cudaTextureObject_t texObj, float x, int layer, float dx, float dy);\n\nfetches from the CUDA array specified by the one- dimensional layered texture at layer layer using texture coordinate x and a level- of- detail derived from the dx and dy gradients."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.8.1.23 tex2DLayered() for sparse CUDA arrays - templateclass T T tex2DLayered......fetches from the CUDA array sp...",
    "content": "# 10.8.1.22 tex2DLayered()\ntemplate<class T> T tex2DLayered(cudaTextureObject_t texObj, float x, float y, int layer);\n\nfetches from the CUDA array specified by the two- dimensional texture object texObj using texture coordinate (x,y) and index layer, as described in Layered Textures.\n\n# 10.8.1.23 tex2DLayered() for sparse CUDA arrays\ntemplate<class T> T tex2DLayered(cudaTextureObject_t texObj, float x, float y, int layer, bool\\* isResident);\n\nfetches from the CUDA array specified by the two- dimensional texture object texObj using texture coordinate (x,y) and index layer, as described in Layered Textures. Also returns whether the texel is resident in memory via isResident pointer. If not, the values fetched will be zeros."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.8.1.25 tex2DLayeredLod() for sparse CUDA arrays - templateclass T T tex2DLayered......fetches from the CUDA array sp...",
    "content": "# 10.8.1.24 tex2DLayeredLod()\ntemplate<class T> T tex2DLayeredLod(cudaTextureObject_t texObj, float x, float y, int layer, float level);\n\nfetches from the CUDA array specified by the two- dimensional layered texture at layer layer using texture coordinate  $(x,y)$\n\n# 10.8.1.25 tex2DLayeredLod() for sparse CUDA arrays\ntemplate<class T> T tex2DLayeredLod(cudaTextureObject_t texObj, float x, float y, int layer, float level, bool\\* isResident);\n\nfetches from the CUDA array specified by the two- dimensional layered texture at layer layer using texture coordinate  $(x,y)$  . Also returns whether the texel is resident in memory via isResident pointer. If not, the values fetched will be zeros."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.8.1.26 tex2DLayeredGrad() - templateclass T T tex2DLayered......fetches from the CUDA array sp...",
    "content": "template<class T> T tex2DLayeredGrad(cudaTextureObject_t texObj, float x, float y, int layer, float2 dx, float2 dy);\n\nfetches from the CUDA array specified by the two- dimensional layered texture at layer layer using texture coordinate  $(x,y)$  and a level- of- detail derived from the dx and dy gradients."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.8.1.28 texCubemap() - templateclass T T tex2DLayered......fetches the CUDA array specifi...",
    "content": "# 10.8.1.27 tex2DLayeredGrad() for sparse CUDA arrays\ntemplate<class T> T tex2DLayeredGrad(cudaTextureObject_t texObj, float x, float y, int layer, float2 dx, float2 dy, bool\\* isResident);\n\nfetches from the CUDA array specified by the two- dimensional layered texture at layer layer using texture coordinate  $(x,y)$  and a level- of- detail derived from the dx and dy gradients. Also returns whether the texel is resident in memory via isResident pointer. If not, the values fetched will be zeros.\n\n# 10.8.1.28 texCubemap()\ntemplate<class T> T texCubemap(cudaTextureObject_t texObj, float x, float y, float z);\n\nfetches the CUDA array specified by the cubemap texture object texObj using texture coordinate  $(x,y,z)$ , as described in Cubemap Textures."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.8.1.30 texCubemapLod() - templateclass T T texCubemapGr......fetches from the CUDA array sp...",
    "content": "# 10.8.1.29 texCubemapGrad()\ntemplate<class T> T texCubemapGrad(cudaTextureObject_t texObj, float x, float, y, float z, float4 dx, float4 dy);\n\nfetches from the CUDA array specified by the cubemap texture object texObj using texture coordinate  $(x,y,z)$  as described in Cubemap Textures. The level- of- detail used is derived from the dx and dy gradients.\n\n# 10.8.1.30 texCubemapLod()\ntemplate<class T> T texCubemapLod(cudaTextureObject_t texObj, float x, float, y, float z, float level);\n\nfetches from the CUDA array specified by the cubemap texture object texObj using texture coordinate  $(x,y,z)$  as described in Cubemap Textures. The level- of- detail used is given by level."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.8.1.32 texCubemapLayeredGrad() - templateclass T T texCubemapLa......fetches from the CUDA array sp...",
    "content": "# 10.8.1.31 texCubemapLayered()\ntemplate<class T> T texCubemapLayered(cudaTextureObject_t texObj, float x, float y, float z, int layer);\n\nfetches from the CUDA array specified by the cubemap layered texture object texObj using texture coordinates  $(x,y,z)$ , and index layer, as described in Cubemap Layered Textures.\n\n# 10.8.1.32 texCubemapLayeredGrad()\ntemplate<class T> T texCubemapLayeredGrad(cudaTextureObject_t texObj, float x, float y, float z, int layer, float4 dx, float4 dy);\n\nfetches from the CUDA array specified by the cubemap layered texture object texObj using texture coordinate  $(x,y,z)$  and index layer, as described in Cubemap Layered Textures, at level- of- detail derived from the dx and dy gradients."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.8.1.33 texCubemapLayeredLod() - templateclass T T texCubemapLa......fetches from the CUDA array sp...",
    "content": "template<class T> T texCubemapLayeredLod(cudaTextureObject_t texObj, float x, float y, float z, int layer, float level);\n\nfetches from the CUDA array specified by the cubemap layered texture object texObj using texture coordinate  $(x,y,z)$  and index layer, as described in Cubemap Layered Textures, at level- of- detail level level."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.9.1. Surface Object API - Surface functions are only sup......In the sections below boundary...",
    "content": "# 10.9. Surface Functions\nSurface functions are only supported by devices of compute capability 2.0 and higher.\n\nSurface objects are described in described in Surface Object API\n\nIn the sections below, boundaryMode specifies the boundary mode, that is how out- of- range surface coordinates are handled; it is equal to either cudaBoundaryModeClamp, in which case out- of- range coordinates are clamped to the valid range, or cudaBoundaryModeZero, in which case out- of- range reads return zero and out- of- range writes are ignored, or cudaBoundaryModeTrap, in which case out- of- range accesses cause the kernel execution to fail.\n\n# 10.9.1. Surface Object API\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.9.1.2 surf1Dwrite - templateclass T T surf1Dreadcu......writes value data to the CUDA ...",
    "content": "template<class T> T surf1Dread(cudaSurfaceObject_t surfObj, int x, boundaryMode = cudaBoundaryModeTrap);\n\nreads the CUDA array specified by the one- dimensional surface object surfObj using byte coordinate x.\n\n# 10.9.1.2 surf1Dwrite\ntemplate<class T> void surf1Dwrite(T data, cudaSurfaceObject_t surfObj, int x, boundaryMode = cudaBoundaryModeTrap);\n\nwrites value data to the CUDA array specified by the one- dimensional surface object surfObj at byte coordinate x."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.9.1.4 surf2Dwrite() - templateclass T T surf2Dreadcu......writes value data to the CUDA ...",
    "content": "# 10.9.1.3 surf2Dread()\ntemplate<class T> T surf2Dread(cudaSurfaceObject_t surfObj, int x, int y, boundaryMode = cudaBoundaryModeTrap);template<class T> void surf2Dread(T* data, cudaSurfaceObject_t surfObj, int x, int y, boundaryMode = cudaBoundaryModeTrap);reads the CUDA array specified by the two- dimensional surface object surfObj using byte coordinates x and y.\n\nreads the CUDA array specified by the two- dimensional surface object surfObj using byte coordinates x and y.\n\n# 10.9.1.4 surf2Dwrite()\ntemplate<class T> void surf2Dwrite(T data, cudaSurfaceObject_t surfobj, int x, int y, boundaryMode  $=$  cudaBoundaryModeTrap);\n\nwrites value data to the CUDA array specified by the two- dimensional surface object surf0bj at byte coordinate x and y."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.9.1.6 surf3Dwrite() - templateclass T T surf3Dreadcu......writes value data to the CUDA ...",
    "content": "# 10.9.1.5 surf3Dread()\ntemplate<class T> T surf3DreadcudaSurfaceObject_t surfobj, int x, int y, int z, boundaryMode  $=$  cudaBoundaryModeTrap); template<class T> void surf3Dread(T\\* data, cudaSurfaceObject_t surfobj, int x, int y, int z, boundaryMode  $=$  cudaBoundaryModeTrap);\n\nreads the CUDA array specified by the three- dimensional surface object surf0bj using byte coordinates x, y, and z.\n\n# 10.9.1.6 surf3Dwrite()\ntemplate<class T> void surf3Dwrite(T data, cudaSurfaceObject_t surfobj, int x, int y, int z, boundaryMode  $=$  cudaBoundaryModeTrap);\n\nwrites value data to the CUDA array specified by the three- dimensional object surf0bj at byte coordinate x, y, and z."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.9.1.8 surf1DLayeredwrite() - templateclass T T surf1DLayere......writes value data to the CUDA ...",
    "content": "# 10.9.1.7 surf1Dlayeredread()\ntemplate<class T> T surf1DLayeredread( cudaSurfaceObject_t surfobj, int x, int layer, boundaryMode  $=$  cudaBoundaryModeTrap); template<class T> void surf1DLayeredread(T data, cudaSurfaceObject_t surfobj, int x, int layer, boundaryMode  $=$  cudaBoundaryModeTrap);\n\nreads the CUDA array specified by the one- dimensional layered surface object surf0bj using byte coordinate x and index layer.\n\n# 10.9.1.8 surf1DLayeredwrite()\ntemplate<class Type> void surf1DLayeredwrite(T data, cudaSurfaceObject_t surfObj, int x, int layer, boundaryMode  $=$  cudaBoundaryModeTrap);\n\nwrites value data to the CUDA array specified by the two- dimensional layered surface object surf0bj at byte coordinate x and index layer."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.9.1.10 surf2DLayeredwrite() - templateclass T T surf2DLayere......writes value data to the CUDA ...",
    "content": "# 10.9.1.9 surf2DLayeredread()\ntemplate<class T> T surf2DLayeredread( cudaSurfaceObject_t surfObj, int x, int y, int layer, boundaryMode  $=$  cudaBoundaryModeTrap); template<class T> void surf2DLayeredread(T data, cudaSurfaceObject_t surfObj, int x, int y, int layer, boundaryMode  $=$  cudaBoundaryModeTrap);\n\nreads the CUDA array specified by the two- dimensional layered surface object surf0bj using byte coordinate x and y, and index layer.\n\n# 10.9.1.10 surf2DLayeredwrite()\ntemplate<class T> void surf2DLayeredwrite(T data, cudaSurfaceObject_t surfObj, int x, int y, int layer, boundaryMode  $=$  cudaBoundaryModeTrap);\n\nwrites value data to the CUDA array specified by the one- dimensional layered surface object surf0bj at byte coordinate x and y, and index layer."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.9.1.12 surfCubemapwrite() - templateclass T T surfCubemapr......writes value data to the CUDA ...",
    "content": "# 10.9.1.11 surfCubemapread()\ntemplate<class T> T surfCubemapread( cudaSurfaceObject_t surfObj, int x, int y, int face, boundaryMode  $=$  cudaBoundaryModeTrap); template<class T> void surfCubemapread(T data, cudaSurfaceObject_t surfObj, int x, int y, int face, boundaryMode  $=$  cudaBoundaryModeTrap);\n\nreads the CUDA array specified by the cubemap surface object surf0bj using byte coordinate x and y, and face index face.\n\n# 10.9.1.12 surfCubemapwrite()\n<table><tr><td>template&lt;class t=&quot;&quot;&gt;</td></tr><tr><td>void surfCubemapwrite(T data, \n  cudaSurfaceObject_t surfObj, \n  int x, int y, int face, \n  boundaryMode = cudaBoundaryModeTrap);</td></tr></table>\n\n\n</class>\n\nwrites value data to the CUDA array specified by the cubemap object surfObj at byte coordinate x and y, and face index face."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.9.1.14 surfCubemapLayeredwrite() - templateclass T T surfCubemapL......boundaryMode  cudaBoundaryMode...",
    "content": "template<class T> T surfCubemapLayeredread( cudaSurfaceObject_t surfObj, int x, int y, int layerFace, boundaryMode  $=$  cudaBoundaryModeTrap); template<class T> void surfCubemapLayeredread(T data, cudaSurfaceObject_t surfObj, int x, int y, int layerFace, boundaryMode  $=$  cudaBoundaryModeTrap);\n\nreads the CUDA array specified by the cubemap layered surface object surfObj using byte coordinate x and y, and index layerFace.\n\n# 10.9.1.14 surfCubemapLayeredwrite()\n<table><tr><td>template&lt;class t&gt;</td></tr><tr><td>void surfCubemapLayeredwrite(T data, \n  cudaSurfaceObject_t surfObj, \n  int x, int y, int layerFace, \n  boundaryMode = cudaBoundaryModeTrap);</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.9.1.14 surfCubemapLayeredwrite() - writes value data to the CUDA ...",
    "content": "writes value data to the CUDA array specified by the cubemap layered object surfObj at byte coordinate x and y, and index layerFace."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.10. Read-Only Data Cache Load Function - The read only data cache load ......header included T can also be ...",
    "content": "# 10.10. Read-Only Data Cache Load Function\nThe read- only data cache load function is only supported by devices of compute capability 5.0 and higher.\n\nT _ldg(const T\\* address);\n\nreturns the data of type T located at address address, where T is char, signed char, short, int, long, long longunsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, char2, char4, short2, short4, int2, int4, longlong2uchar2, uchar4, ushort2, ushort4, uint2, uint4, ulonglong2float, float2, float4, double, or double2. With the cuda_fp16. h header included, T can be _half or _half2. Similarly, with the cuda_bf16. h\n\nheader included, T can also be __nv_bfloat16 or __nv_bfloat162. The operation is cached in the read- only data cache (see Global Memory)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.11. Load Functions Using Cache Hints - These load functions are only ......T ldcgconst T address  T ldcac...",
    "content": "These load functions are only supported by devices of compute capability 5.0 and higher.\n\nT _ldcg(const T* address);  T __ldca(const T* address);  T __ldcs(const T* address);  T __ldlu(const T* address);  T __ldcv(const T* address);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.11. Load Functions Using Cache Hints - returns the data of type T loc...",
    "content": "returns the data of type T located at address address, where T is char, signed char, short, int, long, long longunsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, char2, char4, short2, short4, int2, int4, longlong2uchar2, uchar4, ushort2, ushort4, uint2, uint4, ulonglong2float, float2, float4, double, or double2. With the cuda_fp16. h header included, T can be __half or __half2. Similarly, with the cuda_bf16. h header included, T can also be __nv_bfloat16 or __nv_bfloat162. The operation is using the corresponding cache operator (see PTX ISA)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.12. Store Functions Using Cache Hints - These store functions are only......void stwbT address T value  vo...",
    "content": "These store functions are only supported by devices of compute capability 5.0 and higher.\n\nvoid __stwb(T* address, T value);  void __stcg(T* address, T value);  void __stcs(T* address, T value);  void __stwt(T* address, T value);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.12. Store Functions Using Cache Hints - stores the value argument of t...",
    "content": "stores the value argument of type T to the location at address address, where T is char, signed char, short, int, long, long long unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, char2, char4, short2, short4, int2, int4, longlong2uchar2, uchar4, ushort2, ushort4, uint2, uint4, ulonglong2float, float2, float4, double, or double2. With the cuda_fp16. h header included, T can be __half or __half2. Similarly, with the cuda_bf  $16. \\mathrm{h}$  header included, T can also be __nv_bfloat16 or __nv_bfloat162. The operation is using the corresponding cache operator (see PTX ISA)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.13. Time Function - clockt clock  long long int cl......number of clock cycles the dev...",
    "content": "# 10.13. Time Function\nclock_t clock();  long long int clock64();\n\nwhen executed in device code, returns the value of a per- multiprocessor counter that is incremented every clock cycle. Sampling this counter at the beginning and at the end of a kernel, taking the difference of the two samples, and recording the result per thread provides a measure for each thread of the number of clock cycles taken by the device to completely execute the thread, but not of the\n\nnumber of clock cycles the device actually spent executing thread instructions. The former number is greater than the latter since threads are time sliced."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.14. Atomic Functions - An atomic function performs a ......The atomic functions described...",
    "content": "An atomic function performs a read- modify- write atomic operation on one 32- bit or 64- bit word residing in global or shared memory. In the case of float2 or float4, the read- modify- write operation is performed on each element of the vector residing in global memory. For example, atomicAdd() reads a word at some address in global or shared memory, adds a number to it, and writes the result back to the same address. Atomic functions can only be used in device functions.\n\nThe atomic functions described in this section have ordering cuda::memory_order_relaxed and are only atomic at a particular scope:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.14. Atomic Functions - Atomic APIs with system suffix......global void mykernelint addr  ...",
    "content": "Atomic APIs with _system suffix (example: __atomicAdd_system) are atomic at scope cuda::thread_scope_system. Atomic APIs without a suffix (example: __atomicAdd) are atomic at scope cuda::thread_scope_device. Atomic APIs with _block suffix (example: __atomicAdd_block) are atomic at scope cuda::thread_scope_block.\n\nIn the following example both the CPU and the GPU atomically update an integer value at address addr:\n\n- global__ void mykernel(int *addr) {    atomicAdd_system(addr, 10); // only available on devices with compute capability 6.x}void foo() {    int *addr;    cudaMallocManaged(&addr, 4);    *addr = 0;    mykernel<<<...>>> (addr);    __sync_fetch_and_add(addr, 10); // CPU atomic operation}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.14. Atomic Functions - if CUDAARCH  6000   device dou......continued from previous page",
    "content": "Note that any atomic operation can be implemented based on atomicCAS() (Compare And Swap). For example, atomicAdd() for double- precision floating- point numbers is not available on devices with compute capability lower than 6.0 but it can be implemented as follows:\n\nif CUDA_ARCH < 6000 - - device__ double atomicAdd(double* address, double val) {    unsigned long long int* address_as_ull = (unsigned long long int*) address;    unsigned long long int old = *address_as_ull, assumed;    do {        assumed = old;        old = atomicCAS(address_as_ull, assumed, __double_as_longlong(val +\n\n(continues on next page)\n\n(continued from previous page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.14. Atomic Functions - longlongasdoubleassumed  Note ......triangleright  Devices with co...",
    "content": "__longlong_as_double(assumed))); // Note: uses integer comparison to avoid hang in case of NaN (since NaN != NaN) } while (assumed != old); return __longlong_as_double(old); #endif\n\nThere are system- wide and block- wide variants of the following device- wide atomic APIs, with the following exceptions:\n\n$\\triangleright$  Devices with compute capability less than 6.0 only support device- wide atomic operations,  $\\triangleright$  Tegra devices with compute capability less than 7.2 do not support system- wide atomic operations."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.14.1. Arithmetic Functions",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.14.1.1 atomicAdd() - int atomicAddint address int v...",
    "content": "int atomicAdd(int* address, int val); unsigned int atomicAdd(unsigned int* address, unsigned int val); unsigned long long int atomicAdd(unsigned long long int* address, unsigned long long int val); float atomicAdd(float* address, float val); double atomicAdd(double* address, double val); __half2 atomicAdd(__half2 *address, __half2 val); __half atomicAdd(__half *address, __half val); __nv_bfloat162 atomicAdd(__nv_bfloat162 *address, __nv_bfloat162 val); __nv_bfloat16 atomicAdd(__nv_bfloat16 *address, __nv_bfloat16 val); float2 atomicAdd(float2* address, float2 val); float4 atomicAdd(float4* address, float4 val);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.14.1.1 atomicAdd() - reads the 16 bit 32 bit or 64 ......The 64 bit floating point vers...",
    "content": "reads the 16- bit, 32- bit or 64- bit old located at the address address in global or shared memory, computes (old + val), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old.\n\nThe 32- bit floating- point version of atomicAdd() is only supported by devices of compute capability 2. x and higher.\n\nThe 64- bit floating- point version of atomicAdd() is only supported by devices of compute capability 6. x and higher."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.14.1.1 atomicAdd() - The 32 bit half2 floating poin......The float2 and float4 floating...",
    "content": "The 32- bit __half2 floating- point version of atomicAdd() is only supported by devices of compute capability 6. x and higher. The atomicity of the __half2 or __nv_bfloat162 add operation is guaranteed separately for each of the two __half or __nv_bfloat16 elements; the entire __half2 or __nv_bfloat162 is not guaranteed to be atomic as a single 32- bit access.\n\nThe float2 and float4 floating- point vector versions of atomicAdd() are only supported by devices of compute capability 9. x and higher. The atomicity of the float2 or float4 add operation is guaranteed separately for each of the two or four float elements; the entire float2 or float4 is not guaranteed to be atomic as a single 64- bit or 128- bit access."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.14.1.1 atomicAdd() - The 16 bit half floating point......The float2 and float4 floating...",
    "content": "The 16- bit __half floating- point version of atomicAdd() is only supported by devices of compute capability 7. x and higher.\n\nThe 16- bit __nv_bfloat16 floating- point version of atomicAdd() is only supported by devices of compute capability 8. x and higher.\n\nThe float2 and float4 floating- point vector versions of atomicAdd() are only supported by devices of compute capability 9. x and higher.\n\nThe float2 and float4 floating- point vector versions of atomicAdd() are only supported for global memory addresses."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.14.1.3 atomicExch() - int atomicSubint address int v......int atomicExchint address int ...",
    "content": "int atomicSub(int* address, int val); unsigned int atomicSub(unsigned int* address, unsigned int val);\n\nreads the 32- bit word old located at the address address in global or shared memory, computes (old - val), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old.\n\n# 10.14.1.3 atomicExch()\nint atomicExch(int* address, int val); unsigned int atomicExch(unsigned int* address, unsigned int val); unsigned long long int atomicExch(unsigned long long int* address, unsigned long long int val); float atomicExch(float* address, float val);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.14.1.3 atomicExch() - reads the 32 bit or 64 bit wor...",
    "content": "reads the 32- bit or 64- bit word old located at the address address in global or shared memory and stores val back to memory at the same address. These two operations are performed in one atomic transaction. The function returns old."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.14.1.4 atomicMin() - int atomicMinint address int v......The 64 bit version of atomicMi...",
    "content": "# 10.14.1.4 atomicMin()\nint atomicMin(int* address, int val); unsigned int atomicMin(unsigned int* address, unsigned int val); unsigned long long int atomicMin(unsigned long long int* address, unsigned long long int val); long long int atomicMin(long long int* address, long long int val);\n\nreads the 32- bit or 64- bit word old located at the address address in global or shared memory, computes the minimum of old and val, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old.\n\nThe 64- bit version of atomicMin() is only supported by devices of compute capability 5.0 and higher."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.14.1.5 atomicMax() - int atomicMaxint address int v......The 64 bit version of atomicMa...",
    "content": "# 10.14.1.5 atomicMax()\nint atomicMax(int\\* address, int val); unsigned int atomicMax(unsigned int\\* address, unsigned int val); unsigned long long int atomicMax(unsigned long long int\\* address, unsigned long long int val); long long int atomicMax(long long int\\* address, long long int val);\n\nreads the 32- bit or 64- bit word old located at the address address in global or shared memory, computes the maximum of old and val, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old.\n\nThe 64- bit version of atomicMax () is only supported by devices of compute capability 5.0 and higher."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.14.1.7 atomicDec() - unsigned int atomicIncunsigned......reads the 32 bit word old loca...",
    "content": "# 10.14.1.6 atomicInc()\nunsigned int atomicInc(unsigned int\\* address, unsigned int val);\n\nreads the 32- bit word old located at the address address in global or shared memory, computes ((old  $> =$  val)) 7 0 : (old+1)), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old.\n\n# 10.14.1.7 atomicDec()\nunsigned int atomicDec(unsigned int\\* address, unsigned int val);\n\nreads the 32- bit word old located at the address address in global or shared memory, computes ((old  $= = 0$  ) |l (old  $>$  val)) ? val : (old- 1), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.14.2. Bitwise Functions - int atomicCASint address int c...",
    "content": "# 10.14.1.8 atomicCAS()\nint atomicCAS(int\\* address, int compare, int val); unsigned int atomicCAS(unsigned int\\* address, unsigned int compare, unsigned int val); unsigned long long int atomicCAS(unsigned long long int\\* address, unsigned long long int compare, unsigned long long int val); unsigned short int atomicCAS(unsigned short int \\*address, unsigned short int compare, unsigned short int val); reads the 16- bit, 32- bit or 64- bit word old located at the address address in global or shared memory, computes (old  $= =$  compare ? val : old), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old (Compare And Swap).\n\n# 10.14.2. Bitwise Functions\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.14.2.1 atomicAnd() - int atomicAndint address int v......The 64 bit version of atomicAn...",
    "content": "# 10.14.2.1 atomicAnd()\nint atomicAnd(int\\* address, int val); unsigned int atomicAnd(unsigned int\\* address, unsigned int val); unsigned long long int atomicAnd(unsigned long long int\\* address, unsigned long long int val);\n\nreads the 32- bit or 64- bit word old located at the address address in global or shared memory, computes (old & val), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old.\n\nThe 64- bit version of atomicAnd () is only supported by devices of compute capability 5.0 and higher."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.14.2.2 atomicOr() - int atomicOrint address int va......The 64 bit version of atomicOr...",
    "content": "# 10.14.2.2 atomicOr()\nint atomicOr(int\\* address, int val); unsigned int atomicOr(unsigned int\\* address, unsigned int val); unsigned long long int atomicOr(unsigned long long int\\* address, unsigned long long int val);\n\nreads the 32- bit or 64- bit word old located at the address address in global or shared memory, computes (old | val), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old.\n\nThe 64- bit version of atomicOr () is only supported by devices of compute capability 5.0 and higher."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.15. Address Space Predicate Functions - int atomicXorint address int v......The functions described in thi...",
    "content": "# 10.14.2.3 atomicXor()\nint atomicXor(int\\* address, int val); unsigned int atomicXor(unsigned int\\* address, unsigned int val); unsigned long long int atomicXor(unsigned long long int\\* address, unsigned long long int val);\n\nreads the 32- bit or 64- bit word old located at the address address in global or shared memory, computes (old ^ val), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns old.\n\nThe 64- bit version of atomicXor () is only supported by devices of compute capability 5.0 and higher.\n\n# 10.15. Address Space Predicate Functions\nThe functions described in this section have unspecified behavior if the argument is a null pointer."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.15.3. isConstant() - device unsigned int isGlobalco......Returns 1 if ptr contains the ...",
    "content": "# 10.15.1. isGlobal()\ndevice__ unsigned int __isGlobal(const void *ptr);\n\nReturns 1 if ptr contains the generic address of an object in global memory space, otherwise returns 0.\n\n# 10.15.2. isShared()\ndevice__ unsigned int __isShared(const void *ptr);\n\nReturns 1 if ptr contains the generic address of an object in shared memory space, otherwise returns 0.\n\n# 10.15.3. isConstant()\ndevice__ unsigned int __isConstant(const void *ptr);\n\nReturns 1 if ptr contains the generic address of an object in constant memory space, otherwise returns 0."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.16. Address Space Conversion Functions - device unsigned int isGridCons......Returns the result of executin...",
    "content": "# 10.15.4. isGridConstant()\ndevice__ unsigned int __isGridConstant(const void *ptr);\n\nReturns 1 if ptr contains the generic address of a kernel parameter annotated with __grid_constant__, otherwise returns 0. Only supported for compute architectures greater than or equal to 7. x or later.\n\n# 10.15.5. isLocal()\ndevice__ unsigned int __isLocal(const void *ptr);\n\nReturns 1 if ptr contains the generic address of an object in local memory space, otherwise returns 0.\n\n# 10.16. Address Space Conversion Functions\n10.16.1. _cvta_generic_to_global()\n\ndevice size t cvta_generic_to_global(const void \\*ptr);\n\nReturns the result of executing the PTXcvta.to.global instruction on the generic address denoted by ptr."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.16.5. _cvta_global_to_generic() - device size t cvtagenerictosha......Returns the generic pointer ob...",
    "content": "# 10.16.2. _cvta_generic_to_shared()\ndevice size t cvta_generic_to_shared(const void \\*ptr);\n\nReturns the result of executing the PTXcvta.to.shared instruction on the generic address denoted by ptr.\n\n# 10.16.3. _cvta_generic_to_constant()\ndevice size t cvta_generic_to_constant(const void \\*ptr);\n\nReturns the result of executing the PTXcvta.to.const instruction on the generic address denoted by ptr.\n\n# 10.16.4. _cvta_generic_to_local()\ndevice size t cvta_generic_to_local(const void \\*ptr);\n\nReturns the result of executing the PTXcvta.to.local instruction on the generic address denoted by ptr.\n\n# 10.16.5. _cvta_global_to_generic()\ndevice void \\* cvta_global_to_generic(size_t rawbits);\n\nReturns the generic pointer obtained by executing the PTXcvta.global instruction on the value provided by rawbits."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.17.1. Synopsis - device void  cvtasharedtogener......host device void  allocasizet ...",
    "content": "# 10.16.6. _cvta_shared_to_generic()\ndevice__ void \\* _cvta_shared_to_generic(size_t rawbits);\n\nReturns the generic pointer obtained by executing the PTXcvta. shared instruction on the value provided by rawbits.\n\n# 10.16.7. _cvta_constant_to_generic()\ndevice__ void \\* _cvta_constant_to_generic(size_t rawbits);\n\nReturns the generic pointer obtained by executing the PTXcvta. const instruction on the value provided by rawbits.\n\n# 10.16.8. _cvta_local_to_generic()\ndevice__ void \\* _cvta_local_to_generic(size_t rawbits);\n\nReturns the generic pointer obtained by executing the PTXcvta. local instruction on the value provided by rawbits.\n\n# 10.17. Alloca Function\n\n\n# 10.17.1. Synopsis\nhost__ _device__ void \\* alloca(size_t size);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.17.3. Example - The alloca function allocates ......cppdevice void foounsigned int...",
    "content": "# 10.17.2. Description\nThe alloca() function allocates size bytes of memory in the stack frame of the caller. The returned value is a pointer to allocated memory, the beginning of the memory is 16 bytes aligned when the function is invoked from device code. The allocated memory is automatically freed when the caller to alloca() is returned.\n\nNote: On Windows platform, <malloc.h> must be included before using alloca() Using alloca() may cause the stack to overflow, user needs to adjust stack size accordingly.\n\nIt is supported with compute capability 5.2 or higher.\n\n# 10.17.3. Example\n```cpp__device__ void foo(unsigned int num) {    int4 *ptr = (int4 *)alloca(num * sizeof(int4));    // use of ptr    ...}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.18. Compiler Optimization Hint Functions - The functions described in thi...",
    "content": "The functions described in this section can be used to provide additional information to the compiler optimizer."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.18.1. __builtin_assume_aligned() - cppvoid  builtinassumealigned ......cppvoid res  builtinassumealig...",
    "content": "# 10.18.1. __builtin_assume_aligned()\n```cppvoid * __builtin_assume_aligned (const void *exp, size_t align)```\n\nAllows the compiler to assume that the argument pointer is aligned to at least align bytes, and returns the argument pointer.\n\nExample:\n\n```cppvoid *res = __builtin_assume_aligned(ptr, 32); // compiler can assume 'res' is // at least 32- byte aligned```\n\nThree parameter version:\n\n```cppvoid * __builtin_assume_aligned (const void *exp, size_t align, <integral type> offset)```\n\nAllows the compiler to assume that (char *)exp - offset is aligned to at least align bytes, and returns the argument pointer.\n\nExample:\n\n```cppvoid *res = __builtin_assume_aligned(ptr, 32, 8); // compiler can assume // '(char *)res - 8' is // at least 32- byte aligned.```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.18.3. __assume() - cppvoid builtinassumebool exp...device int getint ptr int idx ...",
    "content": "# 10.18.2. __builtin_assume()\n```cppvoid __builtin_assume(bool exp)```\n\nAllows the compiler to assume that the Boolean argument is true. If the argument is not true at run time, then the behavior is undefined. Note that if the argument has side effects, the behavior is unspecified.\n\nExample:\n\ndevice int get(int \\*ptr, int idx) { __builtin_assume(idx  $< = 2$  ); return ptr[idx]; }\n\n# 10.18.3. __assume()\nvoid __assume(bool exp)\n\nAllows the compiler to assume that the Boolean argument is true. If the argument is not true at run time, then the behavior is undefined. Note that if the argument has side effects, the behavior is unspecified.\n\nExample:\n\ndevice int get(int \\*ptr, int idx) { __assume(idx  $< = 2$  ); return ptr[idx]; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.18.5. __builtin_unreachable() - long builtinexpect long exp lo......indicates to the compiler that...",
    "content": "long __builtin_expect (long exp, long c)\n\nIndicates to the compiler that it is expected that exp  $= = c$ , and returns the value of exp. Typically used to indicate branch prediction information to the compiler.\n\nExample:\n\n// indicate to the compiler that likely \"var  $= = \\theta$  \" // so the body of the if- block is unlikely to be // executed at run time. if __builtin_expect (var, 0)) doit ();\n\n# 10.18.5. __builtin_unreachable()\nvoid __builtin_unreachable(void)\n\nIndicates to the compiler that control flow never reaches the point where this function is being called from. The program has undefined behavior if the control flow does actually reach this point at run time.\n\nExample:\n\n// indicates to the compiler that the default case label is never reached. switch (in) { case 1: return 4;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.18.5. __builtin_unreachable() - continues on next page...case 2 return 10default builti...",
    "content": "(continues on next page)\n\ncase 2: return 10;default: __builtin_unreachable();}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.18.6. Restrictions - assume is only supported when ......If the host compiler supports ...",
    "content": "...assume() is only supported when using c1. exe host compiler. The other functions are supported on all platforms, subject to the following restrictions:\n\nIf the host compiler supports the function, the function can be invoked from anywhere in translation unit. Otherwise, the function must be invoked from within the body of a __device__/ __global__ function, or only when the __CUDA_ARCH__ macro is defined<sup>12</sup>."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.19. Warp Vote Functions - int allsyncunsigned mask int p......Removal notice When targeting ...",
    "content": "int __all_sync(unsigned mask, int predicate);int __any_sync(unsigned mask, int predicate);unsigned __ballot_sync(unsigned mask, int predicate);unsigned __activemask();\n\nDeprecation notice: __any, __all, and __ballot have been deprecated in CUDA 9.0 for all devices.\n\nRemoval notice: When targeting devices with compute capability 7. x or higher, __any, __all, and __ballot are no longer available and their sync variants should be used instead."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.19. Warp Vote Functions - The warp vote functions allow ...",
    "content": "The warp vote functions allow the threads of a given warp to perform a reduction- and- broadcast operation. These functions take as input an integer predicate from each thread in the warp and compare those values with zero. The results of the comparisons are combined (reduced) across the active threads of the warp in one of the following ways, broadcasting a single return value to each participating thread:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.19. Warp Vote Functions - allsyncunsigned mask predicate...",
    "content": "__all_sync(unsigned mask, predicate): Evaluate predicate for all non- exited threads in mask and return non- zero if and only if predicate evaluates to non- zero for all of them. __any_sync(unsigned mask, predicate): Evaluate predicate for all non- exited threads in mask and return non- zero if and only if predicate evaluates to non- zero for any of them. __ballot_sync(unsigned mask, predicate): Evaluate predicate for all non- exited threads in mask and return an integer whose Nth bit is set if and only if predicate evaluates to non- zero for the Nth thread of the warp and the Nth thread is active. __activemask(): Returns a 32- bit integer mask of all currently active threads in the calling warp. The Nth bit is set if the Nth lane in the warp is active when __activemask() is called."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.19. Warp Vote Functions - Inactive threads are represent...",
    "content": " Inactive threads are represented by 0 bits in the returned mask. Threads which have exited the program are always marked as inactive. Note that threads that are convergent at an __activemask() call are not guaranteed to be convergent at subsequent instructions unless those instructions are synchronizing warp- builtin functions."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.19. Warp Vote Functions - For allsync anysync and ballot......These intrinsics do not imply ...",
    "content": "For __all_sync, __any_sync, and __ballot_sync, a mask must be passed that specifies the threads participating in the call. A bit, representing the thread's lane ID, must be set for each participating thread to ensure they are properly converged before the intrinsic is executed by the hardware. Each calling thread must have its own bit set in the mask and all non- exited threads named in mask must execute the same intrinsic with the same mask, or the result is undefined.These intrinsics do not imply a memory barrier. They do not guarantee any memory ordering.\n\nThese intrinsics do not imply a memory barrier. They do not guarantee any memory ordering."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.20.1. Synopsis - matchanysync and matchallsync ......T can be int unsigned int long...",
    "content": "match_any_sync and __match_all_sync perform a broadcast- and- compare operation of a variable between threads within a warp.\n\nSupported by devices of compute capability 7. x or higher.\n\n# 10.20.1. Synopsis\nunsigned int __match_any_sync(unsigned mask, T value); unsigned int __match_all_sync(unsigned mask, T value, int *pred);\n\nT can be int, unsigned int, long, unsigned long, long long, unsigned long long, float or double."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.20.2. Description - The matchsync intrinsics permi......matchanysync Returns mask of t...",
    "content": "The __match_sync() intrinsics permit a broadcast- and- compare of a value value across threads in a warp after synchronizing threads named in mask.\n\n__match_any_sync Returns mask of threads that have same value of value in mask __match_all_sync Returns mask if all threads in mask have the same value for value; otherwise 0 is returned. Predicate pred is set to true if all threads in mask have the same value of value; otherwise the predicate is set to false."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.20.2. Description - The new sync match intrinsics ......These intrinsics do not imply ...",
    "content": "The new \\*_sync match intrinsics take in a mask indicating the threads participating in the call. A bit, representing the thread's lane id, must be set for each participating thread to ensure they are properly converged before the intrinsic is executed by the hardware. Each calling thread must have its own bit set in the mask and all non- exited threads named in mask must execute the same intrinsic with the same mask, or the result is undefined.\n\nThese intrinsics do not imply a memory barrier. They do not guarantee any memory ordering."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.21.1. Synopsis - The reducesyncunsigned mask T ......Supported by devices of comput...",
    "content": "The __reduce_sync(unsigned mask, T value) intrinsics perform a reduction operation on the data provided in value after synchronizing threads named in mask. T can be unsigned or signed for {add, min, max} and unsigned only for {and, or, xor} operations.\n\nSupported by devices of compute capability 8. x or higher.\n\n# 10.21.1. Synopsis\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "// add/min/max - unsigned reduceaddsyncunsigned......andorxor unsigned reduceandsyn...",
    "content": "# // add/min/max\nunsigned __reduce_add_sync(unsigned mask, unsigned value); unsigned __reduce_min_sync(unsigned mask, unsigned value); unsigned __reduce_max_sync(unsigned mask, unsigned value); int __reduce_add_sync(unsigned mask, int value); int __reduce_min_sync(unsigned mask, int value); int __reduce_max_sync(unsigned mask, int value);\n\n// and/or/xor unsigned __reduce_and_sync(unsigned mask, unsigned value); unsigned __reduce_or_sync(unsigned mask, unsigned value); unsigned __reduce_xor_sync(unsigned mask, unsigned value);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.21.2. Description - reduceaddsync reduceminsync re......reduceandsync reduceorsync red...",
    "content": "__reduce_add_sync, __reduce_min_sync, __reduce_max_sync Returns the result of applying an arithmetic add, min, or max reduction operation on the values provided in value by each thread named in mask.\n\n__reduce_and_sync, __reduce_or_sync, __reduce_xor_sync Returns the result of applying a logical AND, OR, or XOR reduction operation on the values provided in value by each thread named in mask."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.21.2. Description - The mask indicates the threads......These intrinsics do not imply ...",
    "content": "The mask indicates the threads participating in the call. A bit, representing the thread's lane id, must be set for each participating thread to ensure they are properly converged before the intrinsic is executed by the hardware. Each calling thread must have its own bit set in the mask and all non- exited threads named in mask must execute the same intrinsic with the same mask, or the result is undefined.\n\nThese intrinsics do not imply a memory barrier. They do not guarantee any memory ordering."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.22. Warp Shuffle Functions - shflsync shflupsync shfldownsy......Removal Notice When targeting ...",
    "content": "__shfl_sync, __shfl_up_sync, __shfl_down_sync, and __shfl_xor_sync exchange a variable between threads within a warp.\n\nSupported by devices of compute capability 5.0 or higher.\n\nDeprecation Notice: __shfl, __shfl_up, __shfl_down, and __shfl_xor have been deprecated in CUDA 9.0 for all devices.\n\nRemoval Notice: When targeting devices with compute capability 7. x or higher, __shfl, __shfl_up, __shfl_down, and __shfl_xor are no longer available and their sync variants should be used instead."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.22.1. Synopsis - T shflsyncunsigned mask T var ......T can be int unsigned int long...",
    "content": "# 10.22.1. Synopsis\nT __shfl_sync(unsigned mask, T var, int srcLane, int width=warpSize);  T __shfl_up_sync(unsigned mask, T var, unsigned int delta, int width=warpSize);  T __shfl_down_sync(unsigned mask, T var, unsigned int delta, int width=warpSize);  T __shfl_xor_sync(unsigned mask, T var, int laneMask, int width=warpSize);\n\nT can be int, unsigned int, long, unsigned long, long, unsigned long, long, float or double. With the cuda_fp16. h header included, T can also be __half or __half2. Similarly, with the cuda_bf16. h header included, T can also be __nv_bfloat16 or __nv_bfloat162."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.22.2. Description - The shflsync intrinsics permit......shflsync Direct copy from inde...",
    "content": "The __shfl_sync() intrinsics permit exchanging of a variable between threads within a warp without use of shared memory. The exchange occurs simultaneously for all active threads within the warp (and named in mask), moving 4 or 8 bytes of data per thread depending on the type.\n\nThreads within a warp are referred to as lanes, and may have an index between 0 and warpSize- 1 (inclusive). Four source- lane addressing modes are supported:\n\n__shfl_sync() Direct copy from indexed lane  __shfl_up_sync() Copy from a lane with lower ID relative to caller  __shfl_down_sync() Copy from a lane with higher ID relative to caller  __shfl_xor_sync() Copy from a lane based on bitwise XOR of own lane ID"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.22.2. Description - Threads may only read data fro......All of the shflsync intrinsics...",
    "content": "Threads may only read data from another thread which is actively participating in the __shfl_sync() command. If the target thread is inactive, the retrieved value is undefined.\n\nAll of the __shfl_sync() intrinsics take an optional width parameter which alters the behavior of the intrinsic. width must have a value which is a power of 2; results are undefined if width is not a power of 2, or is a number greater than warpSize."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.22.2. Description - shflsync returns the value of ......shflupsync calculates a source...",
    "content": "__shfl_sync() returns the value of var held by the thread whose ID is given by srcLane. If width is less than warpSize then each subsection of the warp behaves as a separate entity with a starting logical lane ID of 0. If srcLane is outside the range [0:width- 1], the value returned corresponds to the value of var held by the srcLane modulo width (i.e. within the same subsection).\n\n__shfl_up_sync() calculates a source lane ID by subtracting delta from the caller's lane ID. The value of var held by the resulting lane ID is returned: in effect, var is shifted up the warp by delta"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.22.2. Description - lanes If width is less than wa......shfldownsync calculates a sour...",
    "content": "lanes. If width is less than warpSize then each subsection of the warp behaves as a separate entity with a starting logical lane ID of 0. The source lane index will not wrap around the value of width, so effectively the lower delta lanes will be unchanged.\n\n__shfl_down_sync() calculates a source lane ID by adding delta to the caller's lane ID. The value of var held by the resulting lane ID is returned: this has the effect of shifting var down the warp by delta lanes. If width is less than warpSize then each subsection of the warp behaves as a separate entity with a starting logical lane ID of 0. As for __shfl_up_sync(), the ID number of the source lane will not wrap around the value of width and so the upper delta lanes will remain unchanged."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.22.2. Description - shflxorsync calculates a sourc...",
    "content": "__shfl_xor_sync() calculates a source line ID by performing a bitwise XOR of the caller's lane ID with lameMask. the value of var held by the resulting lane ID is returned: if width is less than warpSize then each group of width consecutive threads are able to access elements from earlier groups of threads, however if they attempt to access elements from later groups of threads their own value of var will be returned. This mode implements a butterfly addressing pattern such as is used in tree reduction and broadcast."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.22.2. Description - The new sync shfl intrinsics t......The width must be a power of 2...",
    "content": "The new *_sync shfl intrinsics take in a mask indicating the threads participating in the call. A bit, representing the thread's lane id, must be set for each participating thread to ensure they are properly converged before the intrinsic is executed by the hardware. Each calling thread must have its own bit set in the mask and all non- exited threads named in mask must execute the same intrinsic with the same mask, or the result is undefined.\n\nThreads may only read data from another thread which is actively participating in the __shfl_sync() command. If the target thread is inactive, the retrieved value is undefined.\n\nThe width must be a power- of- 2 (i.e., 2, 4, 8, 16 or 32). Results are unspecified for other values."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.22.2. Description - These intrinsics do not imply ...",
    "content": "These intrinsics do not imply a memory barrier. They do not guarantee any memory ordering."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.22.3.1 Broadcast of a single value across a warp - cinclude stdiohglobal void bca...",
    "content": "# 10.22.3. Examples\n\n\n# 10.22.3.1 Broadcast of a single value across a warp\n```c#include <stdio.h>__global__ void bcast(int arg) {    int laneId = threadIdx.x & 0x1f;    int value;    if (laneId == 0) // Note unused variable for value = arg; // all threads except lane 0    value = __shfl_sync(0xffffffff, value, 0); // Synchronize all threads in warp, and get \"value\" from lane 0    if (value != arg)        printf(\"Thread %d failed.\\n\", threadIdx.x);}int main() {    bcast<<< 1, 32>>>(1234);    cudaDeviceSynchronize();    return 0;}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.22.3.2 Inclusive plus-scan across sub-partitions of 8 threads - include stdioh",
    "content": "include <stdio.h>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.22.3.2 Inclusive plus-scan across sub-partitions of 8 threads - cglobal void scan4     int lan...",
    "content": "```c__global__ void scan4() {    int laneId = threadIdx.x & 0x1f;    // Seed sample starting value (inverse of lane ID)    int value = 31 - laneId;    // Loop to accumulate scan within my partition.    // Scan requires  $\\log 2(n) = = 3$  steps for 8 threads    // It works by an accumulated sum up the warp    // by 1, 2, 4, 8 etc. steps.    for (int i = 1; i <= 4; i *= 2) {        // We do the __shfl_sync unconditionally so that we        // can read even from threads which won't do a        // sum, and then conditionally assign the result.        int n = __shfl_up_sync(0xffffffff, value, i, 8);        if ((laneId & 7) >= i)            value += n;    }    printf(\"Thread %d final value = %d\\n\", threadIdx."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.22.3.2 Inclusive plus-scan across sub-partitions of 8 threads - x valueint main     scan4 1 32...",
    "content": "x, value);}int main() {    scan4<<< 1, 32>>>(i);    cudaDeviceSynchronize();    return 0;}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.23.2. Description - include stdioh...It is supported with compute c...",
    "content": "# 10.22.3.3 Reduction across a warp\ninclude <stdio.h>\n\n```c__global__ void warpReduce() {    int laneId = threadIdx.x & 0x1f;    // Seed starting value as inverse lane ID    int value = 31 - laneId;    // Use XOR mode to perform butterfly reduction    for (int i = 16; i >= 1; i /= 2)        value += __shfl_xor_sync(0xffffffff, value, i, 32);    // \"value\" now contains the sum across all threads    printf(\"Thread %d final value = %d\\n\", threadIdx.x, value);}int main() {    warpReduce<<< 1, 32>>>(i);    cudaDeviceSynchronize();    return 0;}```\n\n# 10.23. Nanosleep Function\n\n\n# 10.23.1. Synopsis\nT __nanosleep(unsigned ns);\n\n# 10.23.2. Description\n__nanosleep(ns) suspends the thread for a sleep duration approximately close to the delay ns, specified in nanoseconds.It\n\nIt is supported with compute capability 7.0 or higher."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24. Warp Matrix Functions - The following code implements ......C warp matrix operations lever...",
    "content": "# 10.23.3. Example\nThe following code implements a mutex with exponential back- off.\n\ndevice__ void mutex_lock(unsigned int \\*mutex) unsigned int ns  $= 8$  . while (atomicCASmutex, 0, 1) == 1) { _nanosleep(ns); if (ns < 256) { ns  $\\yen 123,456$  } } } _device__ void mutex_unlock(unsigned int \\*mutex) atomicExchmutex, 0); }\n\n# 10.24. Warp Matrix Functions\nC++ warp matrix operations leverage Tensor Cores to accelerate matrix problems of the form D=A*B+C. These operations are supported on mixed- precision floating point data for devices of compute capability 7.0 or higher. This requires co- operation from all threads in a warp. In addition, these operations are allowed in conditional code only if the condition evaluates identically across the entire warp, otherwise the code execution is likely to hang."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.1. Description - All following functions and ty...",
    "content": "All following functions and types are defined in the namespace nvcuda: :wmma. Sub- byte operations are considered preview, i.e. the data structures and APIs for them are subject to change and may not be compatible with future releases. This extra functionality is defined in the nvcuda: :wmma : experimental namespace."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.1. Description - templatetypename Use int m int...",
    "content": "template<typename Use, int m, int n, int k, typename T, typename Layout=void> class  $\\leftrightarrow$  fragment; void load_matrix_sync(fragment<...> &a, const T\\* mptr, unsigned ldm); void load_matrix_sync(fragment<...> &a, const T\\* mptr, unsigned ldm, layout_t layout); void store_matrix_sync(T\\* mptr, const fragment<...> &a, unsigned ldm, Layout_t  $\\leftrightarrow$  layout); void fill_fragment(fragment<...> &a, const T& v); void mma_sync(fragment<...> &d, const fragment<...> &a, const fragment<...> &b, const  $\\leftrightarrow$  fragment<...> &c, bool saf  $\\equiv$  false);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.1. Description - fragment An overloaded class c......matrixa when the fragment is u...",
    "content": "fragment An overloaded class containing a section of a matrix distributed across all threads in the warp. The mapping of matrix elements into fragment internal storage is unspecified and subject to change in future architectures.\n\nOnly certain combinations of template arguments are allowed. The first template parameter specifies how the fragment will participate in the matrix operation. Acceptable values for Use are:\n\nmatrix_a when the fragment is used as the first multiplicand, A, matrix_b when the fragment is used as the second multiplicand, B, or accumulator when the fragment is used as the source or destination accumulators (C or D, respectively)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.1. Description - The m n and k sizes describe t...",
    "content": "The m, n and k sizes describe the shape of the warp- wide matrix tiles participating in the multiplyaccumulate operation. The dimension of each tile depends on its role. For matrix_a the tile takes dimension m x k; for matrix_b the dimension is k x n, and accumulator tiles are m x n."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.1. Description - The data type T may be double ...",
    "content": "The data type, T, may be double, float, _half, _nv_bfloat16, char, or unsigned char for multiplicands and double, float, int, or _half for accumulators. As documented in Element Types and Matrix Sizes, limited combinations of accumulator and multiplicand types are supported. The Layout parameter must be specified for matrix_a and matrix_b fragments. row_major or col_major indicate that elements within a matrix row or column are contiguous in memory, respectively. The Layout parameter for an accumulator matrix should retain the default value of void. A row or column layout is specified only when the accumulator is loaded or stored as described below."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.1. Description - loadmatrixsync Waits until all...",
    "content": "load_matrix_sync Waits until all warp lanes have arrived at load_matrix_sync and then loads the matrix fragment a from memory. mptr must be a 256- bit aligned pointer pointing to the first element of the matrix in memory. ldm describes the stride in elements between consecutive rows (for row major layout) or columns (for column major layout) and must be a multiple of 8 for _half element type or multiple of 4 for float element type. (i.e., multiple of 16 bytes in both cases). If the fragment is an accumulator, the layout argument must be specified as either mem_row_major or mem_col_major. for matrix_a and matrix_b fragments, the layout is inferred from the fragment's layout parameter."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.1. Description - The values of mptr ldm layout ...",
    "content": " The values of mptr, ldm, layout and all template parameters for a must be the same for all threads in the warp. This function must be called by all threads in the warp, or the result is undefined."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.1. Description - storematrixsync Waits until al......element of the matrix in memor...",
    "content": "store_matrix_sync Waits until all warp lanes have arrived at store_matrix_sync and then stores the matrix fragment a to memory. mptr must be a 256- bit aligned pointer pointing to the first\n\nelement of the matrix in memory. 1dm describes the stride in elements between consecutive rows (for row major layout) or columns (for column major layout) and must be a multiple of 8 for __half element type or multiple of 4 for float element type. (i.e., multiple of 16 bytes in both cases). The layout of the output matrix must be specified as either mem_row_major or mem_col_major. The values of mptr, 1dm, layout and all template parameters for a must be the same for all threads in the warp."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.1. Description - fillfragment Fill a matrix fra...",
    "content": "fill_fragment Fill a matrix fragment with a constant value v. Because the mapping of matrix elements to each fragment is unspecified, this function is ordinarily called by all threads in the warp with a common value for v."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.1. Description - mmasync Waits until all warp l......If satf saturate to finite val...",
    "content": "mma_sync Waits until all warp lanes have arrived at mma_sync, and then performs the warpsynchronous matrix multiply- accumulate operation  $\\mathsf{D} = \\mathsf{A}^{\\star}\\mathsf{B} + \\mathsf{C}$  The in- place operation,  $\\mathsf{C} = \\mathsf{A}^{\\star}\\mathsf{B} + \\mathsf{C}$  is also supported. The value of satf and template parameters for each matrix fragment must be the same for all threads in the warp. Also, the template parameters m, n and k must match between fragments A, B, C and D. This function must be called by all threads in the warp, or the result is undefined.\n\nIf satf (saturate to finite value) mode is true, the following additional numerical properties apply for the destination accumulator:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.1. Description - If an element result is Infini......enum fragmentUse m n k T Layou...",
    "content": "If an element result is +Infinity, the corresponding accumulator will contain +MAX_NORM If an element result is - Infinity, the corresponding accumulator will contain - MAX_NORM If an element result is NaN, the corresponding accumulator will contain +0\n\nBecause the map of matrix elements into each thread's fragment is unspecified, individual matrix elements must be accessed from memory (shared or global) after calling store_matrix_sync. In the special case where all threads in the warp will apply an element- wise operation uniformly to all fragment elements, direct element access can be implemented using the following fragment class members.\n\nenum fragment<Use, m, n, k, T, Layout>::num_elements; T fragment<Use, m, n, k, T, Layout>::x[num_elements];"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.1. Description - As an example the following co......wmmafragmentwmmaaccumulator 16...",
    "content": "As an example, the following code scales an accumulator matrix tile by half.\n\nwmma::fragment<wmma::accumulator, 16, 16, 16, float> frag; float alpha = 0.5f; // Same value for all threads in warp /*...*/ for(int t=0; t<frag.num_elements; t++) frag.x[t] *= alpha;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.2. Alternate Floating Point - Tensor Cores support alternate......nvbfloat16 This data format is...",
    "content": "Tensor Cores support alternate types of floating point operations on devices with compute capability 8.0 and higher.\n\n__nv_bfloat16 This data format is an alternate fp16 format that has the same range as f32 but reduced precision (7 bits). You can use this data format directly with the __nv_bfloat16 type available in cuda_bf16. h. Matrix fragments with __nv_bfloat16 data types are required to be composed with accumulators of float type. The shapes and operations supported are the same as with __half."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.2. Alternate Floating Point - tf32 This data format is a spe......To facilitate conversion a new...",
    "content": "tf32 This data format is a special floating point format supported by Tensor Cores, with the same range as f32 and reduced precision  $(> = 10$  bits). The internal layout of this format is implementation defined. In order to use this floating point format with WMMA operations, the input matrices must be manually converted to tf32 precision.\n\nTo facilitate conversion, a new intrinsic __float_to_tf32 is provided. While the input and output arguments to the intrinsic are of float type, the output will be tf32 numerically. This new precision is intended to be used with Tensor Cores only, and if mixed with other floattype operations, the precision and range of the result will be undefined."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.2. Alternate Floating Point - Once an input matrix matrixa o......precisiontf32   float",
    "content": "Once an input matrix (matrix_a or matrix_b) is converted to tf32 precision, the combination of a fragment with precision: . tf32 precision, and a data type of float to load_matrix_sync will take advantage of this new capability. Both the accumulator fragments must have float data types. The only supported matrix size is  $16\\times 16\\times 8$  (m- n- k).\n\nThe elements of the fragment are represented as float, hence the mapping from element_type<T> to storage_element_type<T> is:\n\nprecision:tf32 - > float"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.3. Double Precision - Tensor Cores support double pr...",
    "content": "Tensor Cores support double- precision floating point operations on devices with compute capability 8.0 and higher. To use this new functionality, a fragment with the double type must be used. The mma_sync operation will be performed with the .rn (rounds to nearest even) rounding modifier."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.4. Sub-byte Operations - Sub byte WMMA operations provi......namespace experimental  namesp...",
    "content": "Sub- byte WMMA operations provide a way to access the low- precision capabilities of Tensor Cores. They are considered a preview feature i.e. the data structures and APIs for them are subject to change and may not be compatible with future releases. This functionality is available via the nvcuda: :wmma : : experimental namespace:\n\nnamespace experimental { namespace precision { struct u4; // 4- bit unsigned struct s4; // 4- bit signed struct b1; // 1- bit } enum bmmaBitOp { bmmaBitOpXOR  $= 1$  // compute_75 minimum bmmaBitOpAND  $= 2$  // compute_80 minimum }; enum bmmaAccumulateOp { bmmaAccumulateOpOPC  $= 1$  }; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.4. Sub-byte Operations - For 4 bit precision the APIs a...",
    "content": "For 4 bit precision, the APIs available remain the same, but you must specify experimental::precision::u4 or experimental::precision::s4 as the fragment data type. Since the elements of the fragment are packed together, num_storage_elements will be smaller than num_elements for that fragment. The num_elements variable for a sub- byte fragment, hence returns the number of elements of sub- byte type element_type<T>. This is true for single bit precision as well, in which case, the mapping from element_type<T> to storage_element_type<T> is as follows:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.4. Sub-byte Operations - experimentalprecisionu4   unsi......Note Support for the following...",
    "content": "experimental::precision::u4 - > unsigned (8 elements in 1 storage element)  experimental::precision::s4 - > int (8 elements in 1 storage element)  experimental::precision::b1 - > unsigned (32 elements in 1 storage element)  T - > T //all other types\n\nThe allowed layouts for sub- byte fragments is always row_major for matrix_a and col_major for matrix_b.\n\nFor sub- byte operations the value of ldm in load_matrix_sync should be a multiple of 32 for element type experimental::precision::u4 and experimental::precision::s4 or a multiple of 128 for element type experimental::precision::b1 (i.e., multiple of 16 bytes in both cases).\n\nNote: Support for the following variants for MMA instructions is deprecated and will be removed in sm_90:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.4. Sub-byte Operations - bmmasync Waits until all warp ...",
    "content": "- experimental::precision::u4- experimental::precision::s4- experimental::precision::b1 with bmmaBitOp set to bmmaBitOpXOR\n\nbmma_sync Waits until all warp lanes have executed bmma_sync, and then performs the warpsynchronous bit matrix multiply- accumulate operation  $\\texttt{D} = \\texttt{(A}\\texttt{op}\\texttt{B)} +\\texttt{C}$  where op consists of a logical operation bmmaBitOp followed by the accumulation defined by bmmaAccumulateOp. The available operations are: bmmaBitOpxOR, a 128- bit XOR of a row in matrix_a with the 128- bit column of matrix_b bmmaBitOpAND, a 128- bit AND of a row in matrix_a with the 128- bit column of matrix_b, available on devices with compute capability 8.0 and higher. The accumulate op is always bmmaAccumulateOpPOPC which counts the number of set bits."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.5. Restrictions - The special format required by...",
    "content": "The special format required by tensor cores may be different for each major and minor device architecture. This is further complicated by threads holding only a fragment (opaque architecture- specific ABl data structure) of the overall matrix, with the developer not allowed to make assumptions on how the individual parameters are mapped to the registers participating in the matrix multiply- accumulate."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.5. Restrictions - Since fragments are architectu......fragAcu void foo  wmmafragment...",
    "content": "Since fragments are architecture- specific, it is unsafe to pass them from function A to function B if the functions have been compiled for different link- compatible architectures and linked together into the same device executable. In this case, the size and layout of the fragment will be specific to one architecture and using WMM A APIs in the other will lead to incorrect results or potentially, corruption.\n\nAn example of two link- compatible architectures, where the layout of the fragment differs, is sm_70 and sm_75.\n\nfragA.cu: void foo() { wmma::fragment<...> mat_a; bar(&mat_a); }  fragB.cu: void bar(wmma::fragment<...> *mat_a) { // operate on mat_a }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.5. Restrictions - sm70 fragment layout   mathfra......This undefined behavior might ...",
    "content": "// sm_70 fragment layout   $\\mathfrak{S}>$  nvcc - dc - arch  $\\equiv$  compute_70 - code  $=$  sm_70 fragA.cu - o fragA.o  // sm_75 fragment layout   $\\mathfrak{S}>$  nvcc - dc - arch  $\\equiv$  compute_75 - code  $=$  sm_75 fragB.cu - o fragB.o\n\n(continues on next page)\n\n(continued from previous page)\n\n// Linking the two together  $> nvcc - dlink - arch=sm_75 fragA.o fragB.o - o frag.o\n\nThis undefined behavior might also be undetectable at compilation time and by tools at runtime, so extra care is needed to make sure the layout of the fragments is consistent. This linking hazard is most likely to appear when linking with a legacy library that is both built for a different link- compatible architecture and expecting to be passed a WMA fragment."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.5. Restrictions - To avoid these sorts of proble......Note that since sm70 can run o...",
    "content": "Note that in the case of weak linkages (for example, a CUDA C++ inline function), the linker may choose any available function definition which may result in implicit passes between compilation units.\n\nTo avoid these sorts of problems, the matrix should always be stored out to memory for transit through external interfaces (e.g. wmma::store_matrix_sync(dst, ...);) and then it can be safely passed to bar() as a pointer type [e.g. float *dst].\n\nNote that since sm_70 can run on sm_75, the above example sm_75 code can be changed to sm_70 and correctly work on sm_75. However, it is recommended to have sm_75 native code in your application when linking with other sm_75 separately compiled binaries."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.6. Element Types and Matrix Sizes - Tensor Cores support a variety...",
    "content": "Tensor Cores support a variety of element types and matrix sizes. The following table presents the various combinations of matrix_a, matrix_b and accumulator matrix supported:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.6. Element Types and Matrix Sizes - tabletrtdMatrix AtdtdMatrix Bt...",
    "content": "<table><tr><td>Matrix A</td><td>Matrix B</td><td>Accumulator</td><td>Matrix Size (m-n-k)</td></tr><tr><td>__half</td><td>__half</td><td>float</td><td>16x16x16</td></tr><tr><td>__half</td><td>__half</td><td>float</td><td>32x8x16</td></tr><tr><td>__half</td><td>__half</td><td>float</td><td>8x32x16</td></tr><tr><td>__half</td><td>__half</td><td>__half</td><td>16x16x16</td></tr><tr><td>__half</td><td>__half</td><td>__half</td><td>32x8x16</td></tr><tr><td>__half</td><td>__half</td><td>__half</td><td>8x32x16</td></tr><tr><td>unsigned char</td><td>unsigned char</td><td>int</td><td>16x16x16</td></tr><tr><td>unsigned char</td><td>unsigned char</td><td>int</td><td>32x8x16</td></tr><tr><td>unsigned char</td><td>unsigned char</td><td>int</td><td>8x32x16</td></tr><tr><td>signed char</td><td>signed char"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.6. Element Types and Matrix Sizes - tdtdinttdtd16x16x16tdtrtrtdsig...",
    "content": "</td><td>int</td><td>16x16x16</td></tr><tr><td>signed char</td><td>signed char</td><td>int</td><td>32x8x16</td></tr><tr><td>signed char</td><td>signed char</td><td>int</td><td>8x32x16</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.6. Element Types and Matrix Sizes - Alternate Floating Point suppo......Experimental support for sub b...",
    "content": "Alternate Floating Point support:\n\n<table><tr><td>Matrix A</td><td>Matrix B</td><td>Accumulator</td><td>Matrix Size (m-n-k)</td></tr><tr><td>__nv_bfloat16</td><td>__nv_bfloat16</td><td>float</td><td>16x16x16</td></tr><tr><td>__nv_bfloat16</td><td>__nv_bfloat16</td><td>float</td><td>32x8x16</td></tr><tr><td>__nv_bfloat16</td><td>__nv_bfloat16</td><td>float</td><td>8x32x16</td></tr><tr><td>precision::tf32</td><td>precision::tf32</td><td>float</td><td>16x16x8</td></tr></table>\n\nDouble Precision Support:\n\n<table><tr><td>Matrix A</td><td>Matrix B</td><td>Accumulator</td><td>Matrix Size (m-n-k)</td></tr><tr><td>double</td><td>double</td><td>double</td><td>8x8x4</td></tr></table>\n\nExperimental support for sub- byte operations:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.6. Element Types and Matrix Sizes - tabletrtdMatrix AtdtdMatrix Bt...",
    "content": "<table><tr><td>Matrix A</td><td>Matrix B</td><td>Accumulator</td><td>Matrix Size (m-n-k)</td></tr><tr><td>precision::u4</td><td>precision::u4</td><td>int</td><td>8x8x32</td></tr><tr><td>precision::s4</td><td>precision::s4</td><td>int</td><td>8x8x32</td></tr><tr><td>precision::b1</td><td>precision::b1</td><td>int</td><td>8x8x128</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.24.7. Example - The following code implements ......include mmah using namespace n...",
    "content": "# 10.24.7. Example\nThe following code implements a 16x16x16 matrix multiplication in a single warp.\n\ninclude <mma.h> using namespace nvcuda; global void wmma_ker(half \\*a, half \\*b, float \\*c){ // Declare the fragments wmma::fragment<wmma::matrix_a, 16, 16, 16, half, wmma::col_major> a_frag; wmma::fragment<wmma::matrix_b, 16, 16, 16, half, wmma::row_major> b_frag; wmma::fragment<wmma::accumulator, 16, 16, 16, float> c_frag; // Initialize the output to zero wmma::fill_fragment(c_frag, 0.0f); // Load the inputs wmma::load_matrix_sync(a_frag, a, 16); wmma::load_matrix_sync(b_frag, b, 16); // Perform the matrix multiplication wmma::mma_sync(c_frag, a_frag, b_frag, c_frag); // Store the output wmma::store_matrix_sync(c, c_frag, 16, wmma::mem_row_major); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.25. DPX - DPX is a set of functions that...",
    "content": "DPX is a set of functions that enable finding min and max values, as well as fused addition and min/max, for up to three 16 and 32- bit signed or unsigned integer parameters, with optional ReLU (clamping to zero):"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.25. DPX - three parameters vimax3s32 vim...",
    "content": "three parameters: __vimax3_s32, __vimax3_s16x2, __vimax3_u32, __vimax3_u16x2, __vimin3_s32, __vimin3_s16x2, __vimin3_u32, __vimin3_u16x2 two parameters, with ReLU: __vimax_s32_relu, __vimax_s16x2_relu, __vimin_s32_relu three parameters, with ReLU: __vimax3_s32_relu, __vimax3_s16x2_relu, __vimin3_s32_relu, __vimin3_s16x2_relu two parameters, also returning which parameter was smaller/larger: __vibmax_s32, __vibmax_u32, __vibmin_s32, __vibmin_u32, __vibmax_s16x2, __vibmax_u16x2, __vibmin_s16x2, __vibmin_u16x2 three parameters, comparing (first + second) with the third: __viaddmax_s32, __viad-dmax_s16x2, __viaddmax_u32, __viaddmax_u16x2, __viaddmin_s32, __viaddmin_s16x2, __viaddmin_u32, __viaddmin_u16x2 three parameters, with ReLU, comparing (first + second) with the third and a zero: __viadd"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.25. DPX - maxs32relu viaddmaxs16x2relu v...",
    "content": "max_s32_relu, __viaddmax_s16x2_relu, __viaddmin_s32_relu, __viad-dmin_s16x2_relu"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.25. DPX - These instructions are hardwar......DPX is exceptionally useful wh...",
    "content": "These instructions are hardware- accelerated on devices with compute capability 9 and higher, and software emulation on older devices.\n\nFull API can be found in CUDA Math API documentation.\n\nDPX is exceptionally useful when implementing dynamic programming algorithms, such as Smith- Waterman or Needleman- Wunsch in genomics and Floyd- Warshall in route optimization."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.25.1. Examples - Max value of three signed 32 b......Min value of the sum of two 32...",
    "content": "Max value of three signed 32- bit integers, with ReLU\n\nconst int a  $= - 15$  const int  $\\texttt{b} = \\texttt{8}$  const int  $\\texttt{c} = \\texttt{5}$  int max_value_0  $=$  __vimax3_s32_relu(a, b, c); // max(- 15, 8, 5, 0) = 8 const int  $\\texttt{d} = - 2$  const int  $\\texttt{e} = - 4$  int max_value_1  $=$  __vimax3_s32_relu(a, d, e); // max(- 15, - 2, - 4, 0) = 0\n\nMin value of the sum of two 32- bit signed integers, another 32- bit signed integer and a zero (ReLU)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.25.1. Examples - const int  texttta   5  const ......Min value of two unsigned 32 b...",
    "content": "const int  $\\texttt{a} = - 5$  const int  $\\texttt{b} = \\texttt{6}$  const int  $\\texttt{c} = - 2$  int max_value_0  $=$  __viaddmax_s32_relu(a, b, c); // max(- 5 + 6, - 2, 0) = max(1, - 2, 0)  $\\leftarrow = 1$  const int  $\\texttt{d} = 4$  int max_value_1  $=$  __viaddmax_s32_relu(a, d, c); // max(- 5 + 4, - 2, 0) = max(- 1, - 2, 0)  $\\leftarrow = \\theta$  (continues on next page)\n\nMin value of two unsigned 32- bit integers and determining which value is smaller const unsigned int  $\\texttt{a} = \\texttt{g}$  . const unsigned int  $\\texttt{b} = \\texttt{G}$  . bool smaller_value: unsigned int min_value  $=$  _vibmin_u32(a, b, &smaller_value); // min_value is 6, smaller_value is true"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.25.1. Examples - Max values of three pairs of u...",
    "content": "Max values of three pairs of unsigned 16- bit integers const unsigned a  $=$  0x00050002; const unsigned b  $=$  0x00070004; const unsigned c  $=$  0x00020006; unsigned int max_value  $=$  _vimax3_u16x2(a, b, c); // max(5, 7, 2) and max(2, 4, 6), so  $\\rightarrow$  max_value is 0x00070006"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26. Asynchronous Barrier - The NVIDIA C standard library ......nvcudaexperimentalawbarrier is...",
    "content": "# 10.26. Asynchronous Barrier\nThe NVIDIA C++ standard library introduces a GPU implementation of std::barrier. Along with the implementation of std::barrier the library provides extensions that allow users to specify the scope of barrier objects. The barrier API scopes are documented under Thread Scopes. Devices of compute capability 8.0 or higher provide hardware acceleration for barrier operations and integration of these barriers with the memcpy_async feature. On devices with compute capability below 8.0 but starting 7.0, these barriers are available without hardware acceleration.\n\nnvcuda::experimental::awbarrier is deprecated in favor of cuda::barrier."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.1. Simple Synchronization Pattern - Without the arrivewait barrier......cppinclude cooperativegroupshg...",
    "content": "Without the arrive/wait barrier, synchronization is achieved using __syncthreads() (to synchronize all threads in a block) or group.sync() when using Cooperative Groups.\n\ninclude <cooperative_groups.h>\n\n```cpp#include <cooperative_groups.h>__global__ void simple_sync(int iteration_count) {    auto block = cooperative_groups::this_thread_block();    for (int i = 0; i < iteration_count; ++i) {        /* code before arrive */        block.sync(); /* wait for all threads to arrive here */        /* code after wait */    }}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.1. Simple Synchronization Pattern - Threads are blocked at the syn......Code before sync performs memo...",
    "content": "Threads are blocked at the synchronization point (block.sync()) until all threads have reached the synchronization point. In addition, memory updates that happened before the synchronization point are guaranteed to be visible to all threads in the block after the synchronization point, i.e., equivalent to atomic_thread_fence(memory_order_seq_cst, thread_scope_block) as well as the sync.\n\nThis pattern has three stages:\n\nCode before sync performs memory updates that will be read after the sync.  - Synchronization point  - Code after sync point with visibility of memory updates that happened before sync point."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.2. Temporal Splitting and Five Stages of Synchronization - The temporally split synchroni...",
    "content": "The temporally- split synchronization pattern with the std: : barrier is as follows."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.2. Temporal Splitting and Five Stages of Synchronization - include cudabarrier include co...",
    "content": "include <cuda/barrier> #include <cooperative_groups.h> - - device- - void compute(float\\* data, int curr_iteration); - - global- - void split_arrive_wait(int iteration_count, float \\*data) { using barrier  $=$  cuda: :barrier<cuda::thread_scope_block>; shared- - barrier bar; auto block  $=$  cooperative_groups::this_thread_block(); if (block.thread_rank  $() = =0$  { init(&bar, block.size()); // Initialize the barrier with expected arrival count } block.sync(); for (int curr_iter  $= \\theta$  curr_iter  $\\<$  iteration_count; ++curr_iter)  $\\int x$  code before arrive  $\\neq j$  barrier:arrival_token token  $=$  bar.arrive(); /\\* this thread arrives. Arrival - - does not block a thread \\*/ compute(data, curr_iter); bar."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.2. Temporal Splitting and Five Stages of Synchronization - waitstd movetoken  wait for al...",
    "content": "wait(std: :move(token)); /\\* wait for all threads participating in the barrier - - to complete bar.arrive()  $\\neq j$  /\\* code after wait \\*/ } }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.2. Temporal Splitting and Five Stages of Synchronization - In this pattern the synchroniz...",
    "content": "In this pattern, the synchronization point (block.sync()) is split into an arrive point (bar. arrive()) and a wait point (bar.wait(std::move(token))). A thread begins participating in a cuda: :barrier with its first call to bar.arrive(). When a thread calls bar. wait(std::move(token)) it will be blocked until participating threads have completed bar. arrive() the expected number of times as specified by the expected arrival count argument passed to init(). Memory updates that happen before participating threads call to bar. arrive() are guaranteed to be visible to participating threads after their call to bar. wait(std::move(token)). Note that the call to bar."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.2. Temporal Splitting and Five Stages of Synchronization - arrive does not block a thread...",
    "content": " arrive() does not block a thread, it can proceed with other work that does not depend upon memory updates that happen before other participating threads' call to bar. arrive()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.2. Temporal Splitting and Five Stages of Synchronization - The arrive and then wait patte......Wait point Code after the wait...",
    "content": "The arrive and then wait pattern has five stages which may be iteratively repeated:\n\nCode before arrive performs memory updates that will be read after the wait.  - Arrive point with implicit memory fence (i.e., equivalent to atomic_thread_fence(memory_order_seq_cst, thread_scope_block)).  - Code between arrive and wait.\n\n- Wait point.- Code after the wait, with visibility of updates that were performed before the arrive."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.3. Bootstrap Initialization, Expected Arrival Count, and Participation - Initialization must happen bef......cinclude cudabarrierinclude co...",
    "content": "Initialization must happen before any thread begins participating in a cuda::barrier.\n\n```c#include <cuda/barrier>#include <cooperative_groups.h>__global__ void init_barrier() {    __shared__ cuda::barrier<cuda::thread_scope_block> bar;    auto block = cooperative_groups::this_thread_block();    if (block.thread_rank() == 0) {        init(&bar, block.size()); // Single thread initializes the total expected arrival count.    }    block.sync();}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.3. Bootstrap Initialization, Expected Arrival Count, and Participation - Before any thread can particip...",
    "content": "Before any thread can participate in cuda::barrier, the barrier must be initialized using init() with an expected arrival count, block.size() in this example. Initialization must happen before any thread calls bar.arrive(). This poses a bootstrapping challenge in that threads must synchronize before participating in the cuda::barrier, but threads are creating a cuda::barrier in order to synchronize. In this example, threads that will participate are part of a cooperative group and use block.sync() to bootstrap initialization. In this example a whole thread block is participating in initialization, hence __syncthreads() could also be used."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.3. Bootstrap Initialization, Expected Arrival Count, and Participation - The second parameter of init i...",
    "content": "The second parameter of init() is the expected arrival count, i.e., the number of times bar. arrive() will be called by participating threads before a participating thread is unblocked from its call to bar.wait(std::move(token)). In the prior example the cuda::barrier is initialized with the number of threads in the thread block i.e., cooperative_groups::this_thread_block().size(), and all threads within the thread block participate in the barrier."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.3. Bootstrap Initialization, Expected Arrival Count, and Participation - A cudabarrier is flexible in s...",
    "content": "A cuda::barrier is flexible in specifying how threads participate (split arrive/wait) and which threads participate. In contrast this_thread_block.sync() from cooperative groups or __syncthreads() is applicable to whole- thread- block and __syncwarp(mask) is a specified subset of a warp. If the intention of the user is to synchronize a full thread block or a full warp we recommend using __syncthreads() and __syncwarp(mask) respectively for performance reasons."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.4. A Barrier's Phase: Arrival, Countdown, Completion, and Reset - A cudabarrier counts down from...",
    "content": "A cuda::barrier counts down from the expected arrival count to zero as participating threads call bar.arrive(). When the countdown reaches zero, a cuda::barrier is complete for the current phase. When the last call to bar.arrive() causes the countdown to reach zero, the countdown is automatically and atomically reset. The reset assigns the countdown to the expected arrival count, and moves the cuda::barrier to the next phase."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.4. A Barrier's Phase: Arrival, Countdown, Completion, and Reset - A token object of class cudaba......It is essential to know when a...",
    "content": "A token object of class cuda::barrier::arrival_token, as returned from token=bar.arrive(), is associated with the current phase of the barrier. A call to bar.wait(std::move(token)) blocks the calling thread while the cuda::barrier is in the current phase, i.e., while the phase associated with the token matches the phase of the cuda::barrier. If the phase is advanced (because the countdown reaches zero) before the call to bar.wait(std::move(token)) then the thread does not block; if the phase is advanced while the thread is blocked in bar.wait(std::move(token)), the thread is unblocked.\n\nIt is essential to know when a reset could or could not occur, especially in non- trivial arrive/wait synchronization patterns."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.4. A Barrier's Phase: Arrival, Countdown, Completion, and Reset - A threads calls to tokenbararr...",
    "content": "- A thread's calls to token=bar.arrive() and bar.wait(std::move(token)) must be sequenced such that token=bar.arrive() occurs during the cuda::barrier's current phase, and bar.wait(std::move(token)) occurs during the same or next phase.- A thread's call to bar.arrive() must occur when the barrier's counter is non-zero. After barrier initialization, if a thread's call to bar.arrive() causes the countdown to reach zero then a call to bar.wait(std::move(token)) must happen before the barrier can be reused for a subsequent call to bar.arrive().- bar.wait() must only be called using a token object of the current phase or the immediately preceding phase. For any other values of the token object, the behavior is undefined."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.4. A Barrier's Phase: Arrival, Countdown, Completion, and Reset - For simple arrivewait synchron...",
    "content": "For simple arrive/wait synchronization patterns, compliance with these usage rules is straightforward."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.5. Spatial Partitioning (also known as Warp Specialization) - A thread block can be spatiall......tabletrtdProducertdtdConsumert...",
    "content": "A thread block can be spatially partitioned such that warps are specialized to perform independent computations. Spatial partitioning is used in a producer or consumer pattern, where one subset of threads produces data that is concurrently consumed by the other (disjoint) subset of threads.\n\nA producer/consumer spatial partitioning pattern requires two one sided synchronizations to manage a data buffer between the producer and consumer.\n\n<table><tr><td>Producer</td><td>Consumer</td></tr><tr><td>wait for buffer to be ready to be filled</td><td>signal buffer is ready to be filled</td></tr><tr><td>produce data and fill the buffer</td><td></td></tr><tr><td>signal buffer is filled</td><td>wait for buffer to be filled</td></tr><tr><td></td><td>consume data in filled buffer</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.5. Spatial Partitioning (also known as Warp Specialization) - Producer threads wait for cons......continues on next page",
    "content": "Producer threads wait for consumer threads to signal that the buffer is ready to be filled; however, consumer threads do not wait for this signal. Consumer threads wait for producer threads to signal that the buffer is filled; however, producer threads do not wait for this signal. For full producer/consumer concurrency this pattern has (at least) double buffering where each buffer requires two cuda::barriers.\n\n```c#include <cuda/barrier>#include <cooperative_groups.h>```\n\nusing barrier = cuda::barrier<cuda::thread_scope_block>;\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.5. Spatial Partitioning (also known as Warp Specialization) - continued from previous page d...",
    "content": "(continued from previous page) __device__ void producer(barrier ready[], barrier filled[], float* buffer, float* in, int N, int buffer_len) {    for (int i = 0; i < (N/buffer_len); ++i) {        ready[i%2].arrive_and_wait(); /* wait for buffer_(i%2) to be ready to be filled */        /* produce, i.e., fill in, buffer_(i%2) */        barrier::arrival_token token = filled[i%2].arrive(); /* buffer_(i%2) is filled */    }    __device__ void consumer(barrier ready[], barrier filled[], float* buffer, float* out, int N, int buffer_len) {        barrier::arrival_token token1 = ready[0].arrive(); /* buffer_0 is ready for initial fill */        barrier::arrival_token token2 = ready[1]."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.5. Spatial Partitioning (also known as Warp Specialization) - arrive  buffer1 is ready for i...",
    "content": "arrive(); /* buffer_1 is ready for initial fill */        for (int i = 0; i < (N/buffer_len); ++i) {            filled[i%2].arrive_and_wait(); /* wait for buffer_(i%2) to be filled */            /* consume buffer_(i%2) */            barrier::arrival_token token = ready[i%2].arrive(); /* buffer_(i%2) is ready to be re- filled */        }    }    //N is the total number of float elements in arrays in and out    __global__ void producer_consumer_pattern(int N, int buffer_len, float* in, float* out) {        // Shared memory buffer declared below is of size 2 * buffer_len        // so that we can alternatively work between two buffers."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.5. Spatial Partitioning (also known as Warp Specialization) - buffer0  buffer and buffer1  b...",
    "content": "        // buffer_0 = buffer and buffer_1 = buffer + buffer_len        __shared__ extern float buffer[];        // bar[0] and bar[1] track if buffers buffer_0 and buffer_1 are ready to be filled,        // while bar[2] and bar[3] track if buffers buffer_0 and buffer_1 are filled- in respectively        __shared__ barrier bar[4];        auto block = cooperative_groups::this_thread_block();        if (block.thread_rank() < 4)            init(bar + block.thread_rank(), block.size());        block.sync();        if (block.thread_rank() < warpSize)            producer(bar, bar+2, buffer, in, N, buffer_len);        else            consumer(bar, bar+2, buffer, out, N, buffer_len);    }}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.5. Spatial Partitioning (also known as Warp Specialization) - In this example the first warp......bararriveandwait  pi  is equiv...",
    "content": "In this example the first warp is specialized as the producer and the remaining warps are specialized as the consumer. All producer and consumer threads participate (call bar.arrive() or bar.arrive_and_wait()) in each of the four cuda::barriers so the expected arrival counts are equal\n\nto block.size().\n\nA producer thread waits for the consumer threads to signal that the shared memory buffer can be filled. In order to wait for a cuda::barrier a producer thread must first arrive on that ready  $[1\\% 2]$  arrive() to get a token and then ready  $[1\\% 2]$  .wait(token) with that token. For simplicity ready  $[1\\% 2]$  .arrive_and_wait() combines these operations.\n\nbar.arrive_and_wait();  $/\\pi$  is equivalent to \\*/ bar.wait(bar.arrive());"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.5. Spatial Partitioning (also known as Warp Specialization) - Producer threads compute and f......A consumer thread begins by si...",
    "content": "Producer threads compute and fill the ready buffer, they then signal that the buffer is filled by arriving on the filled barrier, filled  $[1\\% 2]$  .arrive(). A producer thread does not wait at this point, instead it waits until the next iteration's buffer (double buffering) is ready to be filled.\n\nA consumer thread begins by signaling that both buffers are ready to be filled. A consumer thread does not wait at this point, instead it waits for this iteration's buffer to be filled, filled  $[1\\% 2]$  arrive_and_wait(). After the consumer threads consume the buffer they signal that the buffer is ready to be filled again, ready  $[1\\% 2]$  .arrive(), and then wait for the next iteration's buffer to be filled."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.6. Early Exit (Dropping out of Participation) - When a thread that is particip...",
    "content": "When a thread that is participating in a sequence of synchronizations must exit early from that sequence, that thread must explicitly drop out of participation before exiting. The remaining participating threads can proceed normally with subsequent cuda::barrier arrive and wait operations."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.6. Early Exit (Dropping out of Participation) - cinclude cudabarrierinclude co...",
    "content": "```c#include <cuda/barrier>#include <cooperative_groups.h>__device__ bool condition_check();__global__ void early_exit_kernel(int N) {    using barrier = cuda::barrier<cuda::thread_scope_block>;    __shared__ barrier bar;    auto block = cooperative_groups::this_thread_block();    if (block.thread_rank() == 0)        init(&bar, block.size());    block.sync();    for (int i = 0; i < N; ++i) {        if (condition_check()) {            bar.arrive_and_drop();            return;        }        /* other threads can proceed normally */        barrier::arrival_token token = bar.arrive();        /* code between arrive and wait */        bar.wait(std::move(token)); /* wait for all threads to arrive */        /* code after wait */    }}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.6. Early Exit (Dropping out of Participation) - This operation arrives on the ......thread is no longer expected t...",
    "content": "This operation arrives on the cuda::barrier to fulfill the participating thread's obligation to arrive in the current phase, and then decrements the expected arrival count for the next phase so that this\n\nthread is no longer expected to arrive on the barrier."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.7. Completion function - The CompletionFunction of cuda...",
    "content": "The CompletionFunction of cuda::barrier<scope, CompletionFunction> is executed once per phase, after the last thread arrives and before any thread is unblocked from the wait. Memory operations performed by the threads that arrived at the barrier during the phase are visible to the thread executing the CompletionFunction, and all memory operations performed within the CompletionFunction are visible to all threads waiting at the barrier once they are unblocked from the wait."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.7. Completion function - cppinclude cudabarrierinclude ...",
    "content": "```cpp#include <cuda/barrier>#include <cooperative_groups.h>#include <functional>namespace cg = cooperative_groups;__device__ int divergent_compute(int*, int);__device__ int independent_computation(int*, int);__global__ void psum(int* data, int n, int* acc) {auto block = cg::this_thread_block();constexpr int blockSize = 128;__shared__ int smem[BlockSize];assert(BlockSize == block.size());assert(n % 128 == 0);auto completion_fn = [&&] {    int sum = 0;    for (int i = 0; i < 128; ++i)    sum += smem[i];    *acc += sum;};// Barrier storage// Note: the barrier is not default- constructible because// completion_fn is not default- constructible due// to the capture."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.7. Completion function - using completionfnt  decltypec...",
    "content": "using completion_fn_t = decltype(completion_fn);using barrier_t = cuda::barrier<cuda::thread_scope_block, completion_fn_t>::__shared__ std::aligned_storage<sizeof(barrier_t), alignof(barrier_t)> bar_storage;// Initialize barrier:    barrier_t* bar = (barrier_t *)&bar_storage;if (block.rank() == 0) {    assert(*acc == 0);    assert(blockDim.x == blockDim.y == blockDim.y == 1);    new(bar) barrier_t{block.size(), completion_fn};    // equivalent to: init(bar, block.size(), completion_fn);}block.sync();// Main loopfor (int i = 0; i < n; i += block.size()) {```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.7. Completion function - continued from previous page...smemblockthreadrank  datai  ac...",
    "content": "(continued from previous page)\n\nsmem[block_thread_rank()] = data[i] + *acc;  auto t = bar- >arrive();  // We can do independent computation here  bar- >wait(std::move(t));  // shared- memory is safe to re- use in the next iteration  // since all threads are done with it, including the one  // that did the reduction  }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.8.1 Data Types - Memory barrier primitives are ......typedef  implementation define...",
    "content": "Memory barrier primitives are C- like interfaces to cuda::barrier functionality. These primitives are available through including the <cuda_awbarrier_primitives.h> header.\n\n# 10.26.8.1 Data Types\ntypedef /* implementation defined */ __mbarrier_t;  typedef /* implementation defined */ __mbarrier_token_t;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.8.2 Memory Barrier Primitives API - uint32t mbarriermaximumcount  ......mbarriertokent mbarrierarrivem...",
    "content": "uint32_t __mbarrier_maximum_count();  void __mbarrier_init(__mbarrier_t* bar, uint32_t expected_count);\n\n- bar must be a pointer to \n--shared__ memory.  - expected_count <= \n--mbarrier_maximum_count()  - Initialize *bar expected arrival count for the current and next phase to expected_count.\n\nvoid __mbarrier_inval(__mbarrier_t* bar);\n\n- bar must be a pointer to the mbarrier object residing in shared memory.  - Invalidation of *bar is required before the corresponding shared memory can be repurposed.\n\n__mbarrier_token_t __mbarrier_arrive(__mbarrier_t* bar);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.8.2 Memory Barrier Primitives API - mbarriertokent mbarrierarrivea......bool mbarriertestwaitmbarriert...",
    "content": "- Initialization of *bar must happen before this call.  - Pending count must not be zero.  - Atomically decrement the pending count for the current phase of the barrier.  - Return an arrival token associated with the barrier state immediately prior to the decrement.\n\n__mbarrier_token_t __mbarrier_arrive_and_drop(__mbarrier_t* bar);\n\n- Initialization of *bar must happen before this call.  \n- Pending count must not be zero.\n\n- Atomically decrement the pending count for the current phase and expected count for the next phase of the barrier.- Return an arrival token associated with the barrier state immediately prior to the decrement.\n\nbool __mbarrier_test_wait(__mbarrier_t* bar, __mbarrier_token_t token);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.26.8.2 Memory Barrier Primitives API - Note This API has been depreca...",
    "content": "- token must be associated with the immediately preceding phase or current phase of *this.- Returns true if token is associated with the immediately preceding phase of *bar, otherwise returns false.\n\n//Note: This API has been deprecated in CUDA 11.1 uint32_t __mbarrier_pending_count(__mbarrier_token_t token);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27. Asynchronous Data Copies - CUDA 11 introduces Asynchronou...",
    "content": "CUDA 11 introduces Asynchronous Data operations with memcpy_async API to allow device code to explicitly manage the asynchronous copying of data. The memcpy_async feature enables CUDA kernels to overlap computation with data movement."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.1. memcpy_async API - The memcpyasync APIs are provi......The complete API documentation...",
    "content": "The memcpy_async APIs are provided in the cuda/barrier, cuda/pipeline, and cooperative_groups/memcpy_async.h header files.\n\nThe cuda::memcpy_async APIs work with cuda::barrier and cuda::pipeline synchronization primitives, while the cooperative_groups::memcpy_async synchronizes using cooperative_groups::wait.\n\nThese APIs have very similar semantics: copy objects from src to dst as- if performed by another thread which, on completion of the copy, can be synchronized through cuda::pipeline, cuda::barrier, or cooperative_groups::wait.\n\nThe complete API documentation of the cuda::memcpy_async overloads for cuda::barrier and cuda::pipeline is provided in the libcudacxx API documentation along with some examples."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.1. memcpy_async API - The API documentation of coope......The memcpyasync APIs that use ...",
    "content": "The API documentation of cooperative_groups::memcpy_async is provided in the cooperative groups Section of the documentation.\n\nThe memcpy_async APIs that use cuda::barrier and cuda::pipeline require compute capability 7.0 or higher. On devices with compute capability 8.0 or higher, memcpy_async operations from global to shared memory can benefit from hardware acceleration."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.2. Copy and Compute Pattern - Staging Data Through Shared Memory - CUDA applications often employ......The following sections illustr...",
    "content": "CUDA applications often employ a copy and compute pattern that:\n\nfetches data from global memory, stores data to shared memory, and performs computations on shared memory data, and potentially writes results back to global memory.\n\nThe following sections illustrate how this pattern can be expressed without and with the memcpy_async feature:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.2. Copy and Compute Pattern - Staging Data Through Shared Memory - The section Without memcpyasyn...",
    "content": "The section Without memcpy_async introduces an example that does not overlap computation with data movement and uses an intermediate register to copy data. The section With memcpy_async improves the previous example by introducing the cooperative_groups::memcpy_async and the cuda::memcpy_async APIs to directly copy data from global to shared memory without using intermediate registers. Section Asynchronous Data Copies using cuda:barrier shows memcpy with cooperative groups and barrier Section Single- Stage Asynchronous Data Copies using cuda:pipeline show memcpy with single stage pipeline Section Multi- Stage Asynchronous Data Copies using cuda:pipeline show memcpy with multi stage pipeline"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.3. Without memcpy_async - Without memcpyasync the copy p......When this pattern occurs withi...",
    "content": "Without memcpy_async, the copy phase of the copy and compute pattern is expressed as shared[local_idx] = global[global_idx]. This global to shared memory copy is expanded to a read from global memory into a register, followed by a write to shared memory from the register.\n\nWhen this pattern occurs within an iterative algorithm, each thread block needs to synchronize after the shared[local_idx] = global[global_idx] assignment, to ensure all writes to shared memory have completed before the compute phase can begin. The thread block also needs to synchronize again after the compute phase, to prevent overwriting shared memory before all threads have completed their computations. This pattern is illustrated in the following code snippet:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.3. Without memcpy_async - cppinclude cooperativegroupshd......continues on next page",
    "content": "```cpp#include <cooperative_groups.h>__device__ void compute(int* global_out, int const* shared_in) {    // Compares using all values of current batch from shared memory.    // Stores this thread's result back to global memory.}__global__ void without_memory_async(int* global_out, int const* global_in, size_t *size, size_t batch_sz) {    auto grid = cooperative_groups::this_grid();    auto block = cooperative_groups::this_thread_block();    assert(size == batch_sz * grid.size()); // Exposition: input size fits batch_sz * grid_size}```\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.3. Without memcpy_async - extern shared int shared  bloc...",
    "content": "extern __shared__ int shared[]; // block.size() * sizeof(int) bytessize_t local_idx = block.thread_rank();for (size_t batch = 0; batch < batch_sz; ++batch) {    // Compute the index of the current batch for this block in global memory:    size_t block_batch_idx = block.group_index().x * block.size() + grid.size() * _batch;    size_t global_idx = block_batch_idx + threadIdx.x;    shared[local_idx] = global_in[global_idx];    block.sync(); // Wait for all copies to complete    compute送去out + block_batch_idx, shared); // Compute and write result to _global memory    block.sync(); // Wait for compute using shared memory to finish}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.4. With memcpy_async - With memcpyasync the assignmen......The cooperativegroupsmemcpyasy...",
    "content": "With memcpy_async, the assignment of shared memory from global memory shared[local_idx] = global_in[global_idx];\n\nis replaced with an asynchronous copy operation from cooperative groups cooperative_groups::memcpy_async(group, shared, global_in + batch_idx, sizeof(int) * _block.size());\n\nThe cooperative_groups::memcpy_async API copies sizeof(int) * block.size() bytes from global memory starting at global_in + batch_idx to the shared data. This operation happens as- if performed by another thread, which synchronizes with the current thread's call to cooperative_groups::wait after the copy has completed. Until the copy operation completes, modifying the global data or reading or writing the shared data introduces a data race."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.4. With memcpy_async - On devices with compute capabi......cppinclude cooperativegroupshi...",
    "content": "On devices with compute capability 8.0 or higher, memcpy_async transfers from global to shared memory can benefit from hardware acceleration, which avoids transfering the data through an intermediate register.\n\n```cpp#include <cooperative_groups.h>#include <cooperative_groups/memcpy_async.h>__device__ void compute(int* global_out, int const* shared_in);__global__ void with_memcpy_async(int* global_out, int const* global_in, size_t size, _size_t batch_sz) {    auto grid = cooperative_groups::this_grid();    auto block = cooperative_groups::this_thread_block();    assert(size == batch_sz * grid.size()); // Exposition: input size fits batch_sz * _grid_size}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.4. With memcpy_async - extern shared int shared  bloc...",
    "content": "extern __shared__ int shared[]; // block.size() * sizeof(int) bytesfor (size_t batch = 0; batch < batch_sz; ++batch) {    size_t block_batch_idx = block.group_index().x * block.size() + grid.size() * _batch;    // Whole thread- group cooperatively copies whole batch to shared memory;    cooperative_groups::memcpy_async(block, shared, global_in + block_batch_idx, _sizeof(int) * block.size());    cooperative_groups::wait(block); // Joins all threads, waits for all copies to complete    compute(global_out + block_batch_idx, shared);    block.sync();}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.5. Asynchronous Data Copies using cuda::barrier - The cudamemcpyasync overload f...",
    "content": "The cuda::memcpy_async overload for cuda::barrier enables synchronizing asynchronous data transfers using a barrier. This overloads executes the copy operation as- if performed by another thread bound to the barrier by: incrementing the expected count of the current phase on creation, and decrementing it on completion of the copy operation, such that the phase of the barrier will only advance when all threads participating in the barrier have arrived, and all memcpy_async bound to the current phase of the barrier have completed. The following example uses a block- wide barrier, where all block threads participate, and swaps the wait operation with a barrier arrive_and_wait, while providing the same functionality as the previous example:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.5. Asynchronous Data Copies using cuda::barrier - cppinclude cooperativegroupshi...",
    "content": "```cpp#include <cooperative_groups.h>#include <cuda/barrier>__device__ void compute(int* global_out, int const* shared_in);__global__ void with_barrier(int* global_out, int const* global_in, size_t size, size_t batch_sz) {    auto grid = cooperative_groups::this_grid();    auto block = cooperative_groups::this_thread_block();    assert(size == batch_sz * grid.size()); // Assume input size fits batch_sz * grid_size    extern __shared__ int shared[]; // block.size() * sizeof(int) bytes    // Create a synchronization object (C++20 barrier)    __shared__ cuda::barrier<cuda::thread_scope::thread_scope_block> barrier;    if (block.thread_rank() == 0) {        init(&barrier, block.size()); // Friend function initializes barrier    }    block."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.5. Asynchronous Data Copies using cuda::barrier - sync    for sizet batch  0 bat...",
    "content": "sync();    for (size_t batch = 0; batch < batch_sz; ++batch) {        size_t block_batch_idx = block.group_index().x * block.size() + grid.size() * _batch; (continues on next page)    }}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.5. Asynchronous Data Copies using cuda::barrier - continued from previous page c...",
    "content": "(continued from previous page) cuda::memcpy_async(block, shared, global_in + block_batch_idx, sizeof(int) \\* _block.size(), barrier); barrier.arrive_and_wait(); // Waits for all copies to complete compute(global_out  $^+$  block_batch_idx, shared); block.sync(); } }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.6. Performance Guidance for memcpy_async - For compute capability 8 x the......This section highlights the wa...",
    "content": "For compute capability 8. x, the pipeline mechanism is shared among CUDA threads in the same CUDA warp. This sharing causes batches of memcpy_async to be entangled within a warp, which can impact performance under certain circumstances.\n\nThis section highlights the warp- entanglement effect on commit, wait, and arrive operations. Please refer to the Pipeline Interface and the Pipeline Primitives Interface for an overview of the individual operations."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.6.1 Alignment - On devices with compute capabi......Additionally for achieving bes...",
    "content": "On devices with compute capability 8.0, the cp. async family of instructions allows copying data from global to shared memory asynchronously. These instructions support copying 4, 8, and 16 bytes at a time. If the size provided to memcpy async is a multiple of 4, 8, or 16, and both pointers passed to memcpy async are aligned to a 4, 8, or 16 alignment boundary, then memcpy async can be implemented using exclusively asynchronous memory operations.\n\nAdditionally for achieving best performance when using memcpy async API, an alignment of 128 Bytes for both shared memory and global memory is required."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.6.1 Alignment - For pointers to values of type......cudamemcpyasyncgroup dst src c...",
    "content": "For pointers to values of types with an alignment requirement of 1 or 2, it is often not possible to prove that the pointers are always aligned to a higher alignment boundary. Determining whether the cp. async instructions can or cannot be used must be delayed until run- time. Performing such a runtime alignment check increases code- size and adds runtime overhead.\n\nThe cuda::aligned_size_t<size_t Align>(size_t size)Shape can be used to supply a proof that both pointers passed to memcpy async are aligned to an Align alignment boundary and that size is a multiple of Align, by passing it as an argument where the memcpy async APIs expect a Shape:\n\ncuda::memcpy_async(group, dst, src, cuda::aligned_size_t<16>(N * block_size()),  $\\leftrightarrow$  pipeline);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.6.1 Alignment - If the proof is incorrect the ...",
    "content": "If the proof is incorrect, the behavior is undefined."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.6.2 Trivially copyable - On devices with compute capabi...",
    "content": "On devices with compute capability 8.0, the cp.async family of instructions allows copying data from global to shared memory asynchronously. If the pointer types passed to memcpy_async do not point to TriviallyCopyable types, the copy constructor of each output element needs to be invoked, and these instructions cannot be used to accelerate memcpy_Lasync."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.6.3 Warp Entanglement - Commit - The sequence of memcpy async b...",
    "content": "The sequence of memcpy async batches is shared across the warp. The commit operation is coalesced such that the sequence is incremented once for all converged threads that invoke the commit operation. If the warp is fully converged, the sequence is incremented by one; if the warp is fully diverged, the sequence is incremented by 32."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.6.3 Warp Entanglement - Commit - Let PB be the warp shared pipe......For example when a warp is ful...",
    "content": "Let PB be the warp- shared pipeline's actual sequence of batches. PB = {BP0, BP1, BP2, ..., BPL} Let TB be a thread's perceived sequence of batches, as if the sequence were only incremented by this thread's invocation of the commit operation. TB = {BT0, BT1, BT2, ..., BTL} The pipeline::producer_commit() return value is from the thread's perceived batch sequence. An index in a thread's perceived sequence always aligns to an equal or larger index in the actual warp- shared sequence. The sequences are equal only when all commit operations are invoked from converged threads. BTrn BPm where n  $< = m$\n\nFor example, when a warp is fully diverged:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.6.3 Warp Entanglement - Commit - The warp shared pipelines actu...",
    "content": "The warp- shared pipeline's actual sequence would be:  $\\mathsf{PB} = \\{\\mathsf{\\theta},1,2,3,\\ldots ,31\\} (\\mathsf{PL} = 31)$  The perceived sequence for each thread of this warp would be: Thread O:  $\\begin{array}{rl}{\\mathsf{TB}}&{=\\{\\mathsf{\\theta}\\}}\\end{array}$ $\\mathsf{TL} = \\mathsf{\\theta}$  Thread 1:  $\\begin{array}{rl}{\\mathsf{TB}}&{=\\{\\mathsf{\\theta}\\}}\\end{array}$ $\\mathsf{TL} = \\mathsf{\\theta}$  Thread 31:  $\\begin{array}{rl}{\\mathsf{TB}}&{=\\{\\mathsf{\\theta}\\}}\\end{array}$ $\\mathsf{TL} = \\mathsf{\\theta}$"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.6.4 Warp Entanglement - Wait - A CUDA thread invokes either p......In the extreme fully diverged ...",
    "content": "# 10.27.6.4 Warp Entanglement - Wait\nA CUDA thread invokes either pipeline_consumer_wait_prior<N>( or pipeline::consumer_wait() to wait for batches in the perceived sequence TB to complete. Note that pipeline::consumer_wait() is equivalent to pipeline_consumer_wait_prior<N>(), where  $N = \\mathsf{PL}$\n\nThe pipeline_consumer_wait_prior<N>( function waits for batches in the actual sequence at least up to and including PL- N. Since TL  $< = \\mathsf{PL}$  , waiting for batch up to and including PL- N includes waiting for batch TL- N. Thus, when TL  $< \\mathsf{PL}$  , the thread will unintentionally wait for additional, more recent batches.\n\nIn the extreme fully- diverged warp example above, each thread could wait for all 32 batches."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.27.6.6 Keep Commit and Arrive-On Operations Converged - Warp divergence affects the nu......When code preceding these oper...",
    "content": "# 10.27.6.5 Warp Entanglement - Arrive-On\nWarp- divergence affects the number of times an arrive_on(bar) operation updates the barrier. If the invoking warp is fully converged, then the barrier is updated once. If the invoking warp is fully diverged, then 32 individual updates are applied to the barrier.\n\n# 10.27.6.6 Keep Commit and Arrive-On Operations Converged\nIt is recommended that commit and arrive- on invocations are by converged threads:\n\nto not over- wait, by keeping threads' perceived sequence of batches aligned with the actual sequence, and to minimize updates to the barrier object.\n\nWhen code preceding these operations diverges threads, then the warp should be re- converged, via __syncwarp before invoking commit or arrive- on operations."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28. Asynchronous Data Copies using cuda::pipeline - CUDA provides the cudapipeline......The API documentation for cuda...",
    "content": "CUDA provides the cuda::pipeline synchronization object to manage and overlap asynchronous data movement with computation.\n\nThe API documentation for cuda::pipeline is provided in the libcudacxx API. A pipeline object is a double- ended N stage queue with a head and a tail, and is used to process work in a first- in first- out (FIFO) order. The pipeline object has following member functions to manage the stages of the pipeline."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28. Asynchronous Data Copies using cuda::pipeline - tabletrtdPipeline Class Member...",
    "content": "<table><tr><td>Pipeline Class Member Function</td><td>Description</td></tr><tr><td>pro- ducer_acquire</td><td>Acquires an available stage in the pipeline internal queue.</td></tr><tr><td>producer_commit</td><td>Commits the asynchronous operations issued after the producer_acquire call on the currently acquired stage of the pipeline.</td></tr><tr><td>consumer_wait</td><td>Wait for completion of all asynchronous operations on the oldest stage of the pipeline.</td></tr><tr><td>con- sumer_release</td><td>Release the oldest stage of the pipeline to the pipeline object for reuse. The released stage can be then acquired by the producer.</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.1. Single-Stage Asynchronous Data Copies using cuda::pipeline - In previous examples we showed......cppdevice void computeint glob...",
    "content": "In previous examples we showed how to use cooperative_groups and cuda:barrier to do asynchronous data transfers. In this section, we will use the cuda::pipeline API with a single stage to schedule asynchronous copies. And later we will expand this example to show multi staged overlapped compute and copy.\n\n```cpp#include <cooperative_groups/memopy_async.h>#include <cuda/pipeline>```\n\n```cpp__device__ void compute(int* global_out, int const* shared_in);__global__ void with_single_stage(int* global_out, int const* global_in, size_t size, size_t batch_sz) {    auto grid = cooperative_groups::this_grid();    auto block = cooperative_groups::this_thread_block();    assert(size == batch_sz * grid.size()); // Assume input size fits batch_sz * grid_size}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.1. Single-Stage Asynchronous Data Copies using cuda::pipeline - cppconstexpr sizet stagescount......cppfor sizet batch  0 batch  b...",
    "content": "```cppconstexpr size_t stages_count = 1; // Pipeline with one stage// One batch must fit in shared memory:extern __shared__ int shared[]; // block.size() * sizeof(int) bytes```\n\n```cpp// Allocate shared storage for a two- stage cuda::pipeline:__shared__ cuda::pipeline_shared_state<cuda::thread_scope::thread_scope_block, stages_count> shared_state;auto pipeline = cuda::make_pipeline(block, &shared_state);```\n\n```cpp// Each thread processes `batch_sz` elements.// Compute offset of the batch `batch` of this thread block in global memory:auto block_batch = [&](size_t batch) - > int {    return block.group_index().x * block.size() + grid.size() * batch;};```\n\n```cppfor (size_t batch = 0; batch < batch_sz; ++batch) {    size_t global_idx = block_batch(batch);```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.1. Single-Stage Asynchronous Data Copies using cuda::pipeline - cpp Collectively acquire the p......Collectively release the stage...",
    "content": "```cpp// Collectively acquire the pipeline head stage from all producer threads:pipeline.producer_acquire();```\n\n```cpp// Submit async copies to the pipeline's head stage to be// computed in the next loop iteration```\n\n```cpp// cuda::memopy_async(block, shared, global_in + global_idx, sizeof(int) * block.size(), pipeline);```\n\n```cpp// Collectively commit (advance) the pipeline's head stagepipeline.producer_commit();```\n\n```cpp// Collectively wait for the operations committed to the// previous `compute` stage to complete:pipeline.consumer_wait();```\n\n```cpp// Computation overlapped with the memopy_async of the \"copy\" stage:compute(global_out + global_idx, shared);```\n\n// Collectively release the stage resourcespipeline.consumer_release();}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - In the previous examples with ......For that we use the CUDA pipel...",
    "content": "In the previous examples with cooperative_groups::wait and cuda::barrier, the kernel threads immediately wait for the data transfer to shared memory to complete. This avoids data transfers from global memory into registers, but does not hide the latency of the memcpy_async operation by overlapping computation.\n\nFor that we use the CUDA pipeline feature in the following example. It provides a mechanism for managing a sequence of memcpy_async batches, enabling CUDA kernels to overlap memory transfers with computation. The following example implements a two- stage pipeline that overlaps data- transfer with computation. It:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - triangleright  Initializes the......Note that for interoperability...",
    "content": "$\\triangleright$  Initializes the pipeline shared state (more below)  $\\triangleright$  Kickstarts the pipeline by scheduling a memcpy_async for the first batch.  $\\triangleright$  Loops over all the batches: it schedules memcpy_async for the next batch, blocks all threads on the completion of the memcpy_async for the previous batch, and then overlaps the computation on the previous batch with the asynchronous copy of the memory for the next batch.  $\\triangleright$  Finally, it drains the pipeline by performing the computation on the last batch.\n\nNote that, for interoperability with cuda::pipeline, cuda::memcpy_async from the cuda/ pipeline header is used here."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - cppinclude cooperativegroupsme...",
    "content": "```cpp#include <cooperative_groups/memcpy_async.h>#include <cuda/pipeline>__device__ void compute(int* global_out, int const* shared_in);__global__ void with_staging(int* global_out, int const* global_in, size_t size, size_t batch_sz) {    auto grid = cooperative_groups::this_grid();    auto block = cooperative_groups::this_thread_block();    assert(size == batch_sz * grid.size()); // Assume input size fits batch_sz * grid.size    constexpr size_t stages_count = 2; // Pipeline with two stages    // Two batches must fit in shared memory:    extern __shared__ int shared[]; // stages_count * block.size() * sizeof(int) bytes    size_t shared_offset[stages_count] = { 0, block."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - size   Offsets to each batch  ...",
    "content": "size() }; // Offsets to each batch    // Allocate shared storage for a two- stage cuda::pipeline:    __shared__ cuda::pipeline_shared_state< cuda::thread_scope::thread_scope_block, stages_count> shared_state;    auto pipeline = cuda::make_pipeline(block, &shared_state);}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - Each thread processes batchsz ...",
    "content": "// Each thread processes 'batch_sz' elements. // Compute offset of the batch 'batch' of this thread block in global memory: auto_block_batch = [&](size_t batch) - > int { return block.group_index().x * block.size() + grid.size() * batch; }; // Initialize first pipeline stage by submitting a 'memcpy_async' to fetch a whole batch for the block: if (batch_sz == 0) return; pipeline.producer_acquire(); cuda::memcpy_async(block, shared + shared_offset[0], global_in + block_batch(0), sizeof(int) * block.size(), pipeline); pipeline."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - producercommit  Pipelined copy...",
    "content": "producer_commit(); // Pipelined copy/compute: for (size_t batch = 1; batch < batch_sz; ++batch) { // Stage indices for the compute and copy stages: size_t compute_stage_idx = (batch - 1) % 2; size_t copy_stage_idx = batch % 2; size_t global_idx = block_batch(batch); // Collectively acquire the pipeline head stage from all producer threads: pipeline.producer_acquire(); // Submit async copies to the pipeline's head stage to be // computed in the next loop iteration cuda::memcpy_async(block, shared + shared_offset[copy_stage_idx], global_in + global_idx, sizeof(int) * block.size(), pipeline); // Collectively commit (advance) the pipeline's head stage pipeline.producer_commit(); // Collectively wait for the operations commited to the // previous 'compute' stage to complete: pipeline."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - consumerwait  Computation over...",
    "content": "consumer_wait(); // Computation overlapped with the memcpy_async of the \"copy\" stage: compute(global_out + global_idx, shared + shared_offset[compute_stage_idx]); // Collectively release the stage resources pipeline.consumer_release(); } // Compute the data fetch by the last iteration pipeline.consumer_wait(); compute(global_out + block_batch(batch_sz- 1), shared + shared_offset[(batch_sz - - 1) % 2]); pipeline.consumer_release(); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - A pipeline object is a double ......Collectively acquiring the pip...",
    "content": "A pipeline object is a double- ended queue with a head and a tail, and is used to process work in a first- in first- out (FIFO) order. Producer threads commit work to the pipeline's head, while consumer threads pull work from the pipeline's tail. In the example above, all threads are both producer and consumer threads. The threads first commit memcpy_async operations to fetch the next batch while they wait on the previous batch of memcpy_async operations to complete.\n\n- Committing work to a pipeline stage involves:\n\nCollectively acquiring the pipeline head from a set of producer threads using pipeline. producer_acquire(). Submitting memcpy_async operations to the pipeline head. Collectively committing (advancing) the pipeline head using pipeline. producer_commit()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - Using a previously committed s......This example can be written in...",
    "content": "Using a previously committed stage involves:\n\nCollectively waiting for the stage to complete, e.g., using pipeline.consumer_wait() to wait on the tail (oldest) stage. Collectively releasing the stage using pipeline.consumer_release().\n\ncuda::pipeline_shared_state<scope, count> encapsulates the finite resources that allow a pipeline to process up to count concurrent stages. If all resources are in use, pipeline. producer_acquire() blocks producer threads until the resources of the next pipeline stage are released by consumer threads.\n\nThis example can be written in a more concise manner by merging the prolog and epilog of the loop with the loop itself as follows:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - template sizet stagescount   2...",
    "content": "template <size_t stages_count  $= 2$  /\\* Pipeline with stages_count stages  $\\neq \\gamma_{\\geq}$  global__ void with_staging_unified(int\\* global_out, int const\\* global_in, size_t  $\\leftrightarrow$  size, size_t batch_sz){ auto grid  $=$  cooperative_groups::this_grid(); auto block  $=$  cooperative_groups::this_thread_block(); assert(size  $= =$  batch_sz \\* grid.size()); // Assume input size fits batch_sz \\* grid_  $\\leftrightarrow$  size extern__shared__ int shared[]; // stages_count \\* block.size() \\* sizeof(int) bytes size_t shared_offset[stages_count]; for (int  $\\texttt{s} = \\texttt{0}$  ;  $\\texttt{s}\\leq$  stages_count;  $+ + s$  ) shared_offset[s]  $=$  s \\* block."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - size shared cudapipelineshared...",
    "content": "size(); shared__ cuda::pipeline_shared_state< cuda::thread_scope::thread_scope_block, stages_count  $\\gimel$  shared_state; auto pipeline  $=$  cuda::make_pipeline(block, &shared_state); auto block_batch  $=$  [&](size_t batch) - > int { return block.group_index().x \\* block.size()  $^+$  grid."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - size  batch   computebatch nex...",
    "content": "size() \\* batch; }; // compute_batch: next batch to process // fetch_batch: next batch to fetch from global memory for (size_t compute_batch  $= \\theta$  , fetch_batch  $= \\theta$  ; compute_batch  $<$  batch_sz; ++compute_batch) { // The outer loop iterates over the computation of the batches for (; fetch_batch  $<$  batch_sz && fetch_batch  $<$  (compute_batch  $^+$  stages_count); ++fetch_batch) { // This inner loop iterates over the memory transfers, making sure that the  $\\leftrightarrow$  pipeline is always full pipeline."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - produceracquire sizet sharedid...",
    "content": "producer_acquire(); size_t shared_idx  $=$  fetch_batch % stages_count; size_t batch_idx  $=$  fetch_batch; size_t block_batch_idx  $=$  block_batch(batch_idx); cuda::memcpy_async(block, shared  $^+$  shared_offset[shared_idx], global_in  $^+$  block_batch_idx, sizeof(int) \\* block.size(), pipeline);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - continues on next page...The pipelinethreadscopeblock p...",
    "content": "(continues on next page)\n\npipeline.producer_commit(); } pipeline.consumer_wait(); int shared_idx  $=$  compute_batch  $\\%$  stages_count; int batch_idx  $=$  compute_batch; compute(global_out  $^+$  block_batch(batch_idx), shared  $^+$  shared_offset[shared_ idx]); pipeline.consumer_release(); } }\n\nThe pipeline<thread_scope_block> primitive used above is very flexible, and supports two features that our examples above are not using: any arbitrary subset of threads in the block can participate in the pipeline, and from the threads that participate, any subsets can be producers, consumers, or both. In the following example, threads with an \"even\" thread rank are producers, while other threads are consumers:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - device void computeint globalo...",
    "content": "device__ void compute(int\\* global_out, int shared_in); template <size_t stages_count  $= 2>$  global__ void with_specialized_staging_unified(int\\* global_out, int const\\* global_ in, size_t size, size_t batch_sz){ auto grid  $=$  cooperative_groups::this_grid(); auto block  $=$  cooperative_groups::this_thread_block(); // In this example, threads with \"even\" thread rank are producers, while threads with \"odd\" thread rank are consumers: const cuda::pipeline_role thread_role  $=$  block.thread_rank() % 2 == 0? cuda::pipeline_role::producer : cuda::pipeline_ role::consumer; // Each thread block only has half of its threads as producers: auto producer_threads  $=$  block.size() / 2; // Map adjacent even and odd threads to the same id: const int thread_idx  $=$  block."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - threadrank  2 auto elementsper...",
    "content": "thread_rank() / 2; auto elements_per_batch  $=$  size / batch_sz; auto elements_per_batch_per_block  $=$  elements_per_batch / grid.group_dim().x; extern__shared__ int shared[]; // stages_count \\* elements_per_batch_per_block \\* sizeof(int) bytes size_t shared_offset[stages_count]; for (int  $\\texttt{s} = \\texttt{0}$  ; s  $\\epsilon$  stages_count;  $^{+ + }$  s) shared_offset[s]  $=$  s \\* elements_per_batch_ per_block; shared__ cuda::pipeline_shared_state< cuda::thread_scope::thread_scope_block, stages_count  $\\gimel$  shared_state; cuda::pipeline pipeline  $=$  cuda::make_pipeline(block, &shared_state, thread_role); // Each thread block processes 'batch_sz' batches."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - Compute offset of the batch ba...",
    "content": " // Compute offset of the batch 'batch' of this thread block in global memory: auto block_batch  $=$  [&](size_t batch) - > int { return elements_per_batch \\* batch  $^+$  elements_per_batch_per_block \\* blockIdx.x; (continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - for sizet computebatch   0  fe...",
    "content": "}; for (size_t compute_batch  $= 0$  fetch_batch  $= 0$  ; compute_batch  $<$  batch_sz;  $\\rightarrow + +$  compute_batch){ // The outer loop iterates over the computation of the batches for (; fetch_batch  $<$  batch_sz && fetch_batch  $<$  (compute_batch  $^+$  stages_count);  $\\rightarrow + +$  fetch_batch){ // This inner loop iterates over the memory transfers, making sure that the  $\\rightarrow$  pipeline is always full if (thread_role  $= =$  cuda::pipeline_role::producer){ // Only the producer threads schedule asynchronous memcpy: pipeline."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - produceracquire sizet sharedid...",
    "content": "producer_acquire(); size_t shared_idx  $=$  fetch_batch  $\\%$  stages_count; size_t batch_idx  $=$  fetch_batch; size_t global_batch_idx  $=$  block_batch(batch_idx)  $^+$  thread_idx; size_t shared_batch_idx  $=$  shared_offset[shared_idx]  $^+$  thread_idx; cuda::memcpy_async(shared  $^+$  shared_batch_idx, global_in  $^+$  global_  $\\rightarrow$  batch_idx, sizeof(int), pipeline); pipeline.producer_commit(); } } if (thread_role  $= =$  cuda::pipeline_role::consumer){ // Only the consumer threads compute: pipeline."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - consumerwait sizet sharedidx  ...",
    "content": "consumer_wait(); size_t shared_idx  $=$  compute_batch  $\\%$  stages_count; size_t global_batch_idx  $=$  block_batch(compute_batch)  $^+$  thread_idx; size_t shared_batch_idx  $=$  shared_offset[shared_idx]  $^+$  thread_idx; compute(global_out  $^+$  global_batch_idx, \\*(shared  $^+$  shared_batch_idx)); pipeline.consumer_release(); } } } }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - There are some optimizations t......For the particular case in whi...",
    "content": "There are some optimizations that pipeline performs, for example, when all threads are both producers and consumers, but in general, the cost of supporting all these features cannot be fully eliminated. For example, pipeline stores and uses a set of barriers in shared memory for synchronization, which is not really necessary if all threads in the block participate in the pipeline.\n\nFor the particular case in which all threads in the block participate in the pipeline, we can do better than pipeline<thread_scope_block> by using a pipeline<thread_scope_thread> combined with __syncthreads():"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - templatesizet stagescount  glo......continues on next page",
    "content": "template<size_t stages_count> - global__ void with_staging_scope_thread(int\\* global_out, int const\\* global_in, size_  $\\rightarrow \\mathbf{t}$  size, size_t batch_sz){ auto grid  $=$  cooperative_groups::this_grid(); auto block  $=$  cooperative_groups::this_thread_block(); auto thread  $=$  cooperative_groups::this_thread(); assert(size  $= =$  batch_sz \\* grid.size()); // Assume input size fits batch_sz \\* grid_  $\\rightarrow$  size extern__shared__ int shared[]; // stages_count \\* block.size() \\* sizeof(int) bytes size_t shared_offset[stages_count]; for (int  $\\texttt{s} = \\texttt{0}$  ; s  $<$  stages_count;  $^{+ + }$  s) shared_offset[s]  $=$  s \\* block.size(); // No pipeline::shared_state needed\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - continued from previous page c...",
    "content": "(continued from previous page) cuda::pipeline<cuda::thread_scope_thread> pipeline  $=$  cuda::make_pipeline(); auto block_batch  $=$  [&](size_t batch) - > int { return block.group_index().x \\* block.size()  $^+$  grid.size() \\* batch; }; for (size_t compute_batch  $= \\theta$  , fetch_batch  $= \\theta$  ; compute_batch  $<$  batch_sz; ++compute_batch) { for (; fetch_batch  $<$  batch_sz && fetch_batch  $<$  (compute_batch  $^+$  stages_count); ++fetch_batch) { pipeline.producer_acquire(); size_t shared_idx  $=$  fetch_batch  $\\%$  stages_count; size_t batch_idx  $=$  fetch_batch; // Each thread fetches its own data: size_t thread_batch_idx  $=$  block_batch(batch_idx)  $^+$  threadIdx."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - x  The copy is performed by a ...",
    "content": "x; // The copy is performed by a single 'thread' and the size of the batch is now that of a single element: cuda::memcpy_async(thread, shared  $^+$  shared_offset[shared_idx]  $^+$  threadIdx. - x, global_in  $^+$  thread_batch_idx, sizeof(int), pipeline); pipeline.producer_commit(); } pipeline.consumer_wait(); block.sync(); // _syncthreads: All memcpy_async of all threads in the block for this stage have completed here int shared_idx  $=$  compute_batch  $\\%$  stages_count; int batch_idx  $=$  compute_batch; compute(global_out  $^+$  block_batch(batch_idx), shared  $^+$  shared_offset[shared_ idx]); pipeline.consumer_release(); } }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.2. Multi-Stage Asynchronous Data Copies using cuda::pipeline - If the compute operation only ...",
    "content": "If the compute operation only reads shared memory written to by other threads in the same warp as the current thread,  $\\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ ,$  suffices."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.4. Pipeline Primitives Interface - The complete API documentation......10284 Pipeline Primitives Inte...",
    "content": "# 10.28.3. Pipeline Interface\nThe complete API documentation for cuda::memcpy_async is provided in the libcudacxx API documentation along with some examples.\n\nThe pipeline interface requires - at least CUDA 11.0,- at least ISO C++ 2011 compatibility, e.g., to be compiled with \n- std=c++11, and- #include <cuda/pipeline>.\n\nFor a C- like interface, when compiling without ISO C++ 2011 compatibility, see Pipeline Primitives Interface.\n\n# 10.28.4. Pipeline Primitives Interface\n10.28.4. Pipeline Primitives InterfacePipeline primitives are a C- like interface for memcpy_async functionality. The pipeline primitives interface is available by including the <cuda_pipeline.h> header. When compiling without ISO C++ 2011 compatibility, include the <cuda_pipeline_primitives.h> header."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.4.1 memcpy_async Primitive - void pipelinememoryasyncvoid  ......Requirements",
    "content": "void __pipeline_memory_async(void\\* - - restrict__ dst_shared, const void\\* - - restrict__ src_global, size_t size_and_align, size_t zfill  $= 0$  .\n\nRequest that the following operation be submitted for asynchronous evaluation:\n\nsize_t  $\\mathrm{\\bf i} = \\mathrm{\\bf 0}$  .. for (; i < size_and_align - zfill;  $^{+ + }\\mathrm{i}$  ) ((char\\*)dst_shared)[i]  $=$  ((char\\*)src_ - global)[i]; /\\* copy \\*/ for (; i < size_and_align;  $^{+ + }\\mathrm{i}$  ) ((char\\*)dst_shared)[i]  $=$  0; /\\* zero- fill \\*/\n\nRequirements:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.4.1 memcpy_async Primitive - dstshared must be a pointer to......Loading from dstshared Storing...",
    "content": "dst_shared must be a pointer to the shared memory destination for the memcpy_async. src_global must be a pointer to the global memory source for the memcpy_async. size_and_align must be 4, 8, or 16. zfill  $< =$  size_and_align. size_and_align must be the alignment of dst_shared and src_global.\n\nIt is a race condition for any thread to modify the source memory or observe the destination memory prior to waiting for the memcpy_async operation to complete. Between submitting a memcpy_async operation and waiting for its completion, any of the following actions introduces a race condition:\n\nLoading from dst_shared. Storing to dst_shared or src_global. Applying an atomic update to dst_shared or src_global."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.4.4 Arrive On Barrier Primitive - void pipelinecommit...void pipelinearriveonmbarriert...",
    "content": "void __pipeline_commit();\n\nCommit submitted memcpy_async to the pipeline as the current batch.\n\n# 10.28.4.3 Wait Primitive\nvoid __pipeline_wait_prior(size_t n);\n\nLet  $\\{\\theta ,1,2,\\ldots ,L\\}$  be the sequence of indices associated with invocations of __pipeline_commit() by a given thread. Wait for completion of batches at least up to and including L- N.\n\n# 10.28.4.4 Arrive On Barrier Primitive\nvoid __pipeline_arrive_on(__mbarrier_t* bar);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.28.4.4 Arrive On Barrier Primitive - bar points to a barrier in sha...",
    "content": "bar points to a barrier in shared memory.  $\\triangleright$  Increments the barrier arrival count by one, when all memcpy_async operations sequenced before this call have completed, the arrival count is decremented by one and hence the net effect on the arrival count is zero. It is user's responsibility to make sure that the increment on the arrival count does not exceed __mbarrier_maximum_count()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.29. Profiler Counter Function - Each multiprocessor has a set ......The value of counters 0 1  7 c...",
    "content": "# 10.29. Profiler Counter Function\nEach multiprocessor has a set of sixteen hardware counters that an application can increment with a single instruction by calling the __prof_trigger() function.\n\nvoid __prof_trigger(int counter);\n\nincrements by one per warp the per- multiprocessor hardware counter of index counter. Counters 8 to 15 are reserved and should not be used by applications.\n\nThe value of counters 0, 1, ..., 7 can be obtained via nvpref by nvpref - - events prof_trigger_0x where x is 0, 1, ..., 7. All counters are reset before each kernel launch (note that when collecting counters, kernel launches are synchronous as mentioned in Concurrent Execution between Host and Device)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.30. Assertion - Assertion is only supported by......filenameline numberfunction bl...",
    "content": "Assertion is only supported by devices of compute capability 2. x and higher.\n\nvoid assert(int expression);\n\nstops the kernel execution if expression is equal to zero. If the program is run within a debugger, this triggers a breakpoint and the debugger can be used to inspect the current state of the device. Otherwise, each thread for which expression is equal to zero prints a message to stderr after synchronization with the host via cudaDeviceSynchronize(), cudaStreamSynchronize(), or cudaEventSynchronize(). The format of this message is as follows:\n\n<filename>:<line number>:<function>: block: [blockId.x,blockId.x,blockIdx.z], thread: [threadIdx.x,threadIdx.y,threadIdx.z] Assertion `<expression>` failed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.30. Assertion - Any subsequent host side synch......will output",
    "content": "Any subsequent host- side synchronization calls made for the same device will return cudaError- rAssert. No more commands can be sent to this device until cudaDeviceReset() is called to reinitialize the device.\n\nIf expression is different from zero, the kernel execution is unaffected.\n\nFor example, the following program from source file test.cu\n\ninclude <assert.h> global_ void testAssert(void) { int is_one  $= 1$  int should_be_one  $= 0$  // This will have no effect assert(is_one); // This will halt kernel execution assert(should_be_one); } int main(int argc, char\\* argv[]) { testAssert  $\\mathbf{\\epsilon}_{\\epsilon} = \\epsilon \\mathbf{\\epsilon}_{\\epsilon}1,\\mathbf{\\epsilon}_{\\epsilon} > > (\\mathbf{\\epsilon})$  cudaDeviceSynchronize(); return 0; }\n\nwill output:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.30. Assertion - testcu19 void testAssert block......Assertions are for debugging p...",
    "content": "test.cu:19: void testAssert(): block: [0,0,0], thread: [0,0,0] Assertion `should_be_  $\\rightarrow$  one` failed.\n\nAssertions are for debugging purposes. They can affect performance and it is therefore recommended to disable them in production code. They can be disabled at compile time by defining the NDEBUG preprocessor macro before including assert.h. Note that expression should not be an expression with side effects (something like  $(+ + \\mathtt{i} > \\theta)$  , for example), otherwise disabling the assertion will affect the functionality of the code."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.32. Breakpoint Function - A trap operation can be initia......void brkpt",
    "content": "A trap operation can be initiated by calling the  $\\_$  trap() function from any device thread.\n\nvoid  $\\_$ trap();\n\nThe execution of the kernel is aborted and an interrupt is raised in the host program.\n\n# 10.32. Breakpoint Function\nExecution of a kernel function can be suspended by calling the __brkpt() function from any device thread.\n\nvoid __brkpt();"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.33. Formatted Output - Formatted output is only suppo......The in kernel printf function ...",
    "content": "Formatted output is only supported by devices of compute capability 2. x and higher.\n\nint printf(const char \\*format[, arg, ...]);\n\nprints formatted output from a kernel to a host- side output stream.\n\nThe in- kernel printf() function behaves in a similar way to the standard C- library printf() function, and the user is referred to the host system's manual pages for a complete description of printf() behavior. In essence, the string passed in as format is output to a stream on the host, with substitutions made from the argument list wherever a format specifier is encountered. Supported format specifiers are listed below."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.33. Formatted Output - The printf command is executed......It is up to the programmer to ...",
    "content": "The printf() command is executed as any other device- side function: per- thread, and in the context of the calling thread. From a multi- threaded kernel, this means that a straightforward call to printf() will be executed by every thread, using that thread's data as specified. Multiple versions of the output string will then appear at the host stream, once for each thread which encountered the printf().\n\nIt is up to the programmer to limit the output to a single thread if only a single output string is desired (see Examples for an illustrative example)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.33. Formatted Output - Unlike the C standard printf w...",
    "content": "Unlike the C- standard printf(), which returns the number of characters printed, CUDA's printf() returns the number of arguments parsed. If no arguments follow the format string, 0 is returned. If the format string is NULL, - 1 is returned. If an internal error occurs, - 2 is returned."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.33.1. Format Specifiers - As for standard printf format ......Note that CUDAs printf will ac...",
    "content": "# 10.33.1. Format Specifiers\nAs for standard printf(), format specifiers take the form: %[flags][width][. precision][size]type\n\nThe following fields are supported (see widely- available documentation for a complete description of all behaviors):\n\nFlags: '# ' ' '0' '+' Width: ' \\* '0- 9 Precision: '0- 9' Size: 'h' '1' '11' Type: \"%cdlouxXpeEfgGaAs\"\n\nNote that CUDA's printf() will accept any combination of flag, width, precision, size and type, whether or not overall they form a valid format specifier. In other words, \"%hd\" will be accepted and printf will expect a double- precision variable in the corresponding location in the argument list."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.33.2. Limitations - Final formatting of the printf......As described in Format Specifi...",
    "content": "Final formatting of the printf() output takes place on the host system. This means that the format string must be understood by the host- system's compiler and C library. Every effort has been made to ensure that the format specifiers supported by CUDA's printf function form a universal subset from the most common host compilers, but exact behavior will be host- OS- dependent.\n\nAs described in Format Specifiers, printf() will accept all combinations of valid flags and types. This is because it cannot determine what will and will not be valid on the host system where the final output is formatted. The effect of this is that output may be undefined if the program emits a format string which contains invalid combinations."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.33.2. Limitations - The printf command can accept ......Owing to the differing size of...",
    "content": "The printf() command can accept at most 32 arguments in addition to the format string. Additional arguments beyond this will be ignored, and the format specifier output as- is.\n\nOwing to the differing size of the long type on 64- bit Windows platforms (four bytes on 64- bit Windows platforms, eight bytes on other 64- bit platforms), a kernel which is compiled on a non- Windows 64- bit machine but then run on a win64 machine will see corrupted output for all format strings which include \"%ld\". It is recommended that the compilation platform matches the execution platform to ensure safety."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.33.2. Limitations - The output buffer for printf i...",
    "content": "The output buffer for printf() is set to a fixed size before kernel launch (see Associated Host- Side API). It is circular and if more output is produced during kernel execution than can fit in the buffer, older output is overwritten. It is flushed only when one of these actions is performed:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.33.2. Limitations - Kernel launch via  or cuLaunch...",
    "content": "- Kernel launch via <<>>> or cuLaunchKernel() (at the start of the launch, and if the CUDA_LAUNCH_BLOCKING environment variable is set to 1, at the end of the launch as well),- Synchronization via cudaDeviceSynchronize(), cuCtxSynchronize(), cudaStreamSynchronize(), cuStreamSynchronize(), cudaEventSynchronize(), or cuEventSynchronize(),- Memory copies via any blocking version of cudaMempcy*() or cuMempcy*(),- Module loading/unloading via cuModuleLoad() or cuModuleUnload(),- Context destruction via cudaDeviceReset() or cuCtxDestroy().- Prior to executing a stream callback added by cudaStreamAddCallback or cuStreamAddCallback."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.33.2. Limitations - Internally printf uses a share...",
    "content": "Note that the buffer is not flushed automatically when the program exits. The user must call cudaDeviceReset() or cuCtxDestroy() explicitly, as shown in the examples below.\n\nInternally printf() uses a shared data structure and so it is possible that calling printf() might change the order of execution of threads. In particular, a thread which calls printf() might take a longer execution path than one which does not call printf(), and that path length is dependent upon the parameters of the printf(). Note, however, that CUDA makes no guarantees of thread execution order except at explicit __syncthreads() barriers, so it is impossible to tell whether execution order has been modified by printf() or by other scheduling behavior in the hardware."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.33.3. Associated Host-Side API - The following API functions ge......cudaDeviceGetLimitsizet size c...",
    "content": "The following API functions get and set the size of the buffer used to transfer the printf() arguments and internal metadata to the host (default is 1 megabyte):\n\n- cudaDeviceGetLimit(size_t* size, cudaLimitPrintfFifoSize)- cudaDeviceSetLimit(cudaLimitPrintfFifoSize, size_t size)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.33.4. Examples - The following code sample",
    "content": "The following code sample:\n\ninclude <stdio.h> global__ void helloCuDA(float f) { printf(\"Hello thread %d, f=%f\\n\", threadIdx.x, f); } int main() { helloCuDA  $\\epsilon < < 1$  5  $\\geq \\geq \\geq$  (1.2345f); cudaDeviceSynchronize(); return 0; }\n\nwill output:\n\nHello thread 2,  $f = 1.2345$   Hello thread 1,  $f = 1.2345$   Hello thread 4,  $f = 1.2345$   Hello thread 0,  $f = 1.2345$   Hello thread 3,  $f = 1.2345$\n\nNotice how each thread encounters the printf() command, so there are as many lines of output as there were threads launched in the grid. As expected, global values (i.e., float f) are common between all threads, and local values (i.e., threadIdx.x) are distinct per- thread.\n\nThe following code sample:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.33.4. Examples - include stdioh global void hel......Self evidently the if statemen...",
    "content": "include <stdio.h> global__ void helloCuDA(float f) { if (threadIdx.x  $= = 0$  printf(\"Hello thread %d, f=%f\\n\", threadIdx.x, f); } int main() { helloCuDA  $\\epsilon < < 1$  5  $\\geq \\geq \\geq$  (1.2345f); cudaDeviceSynchronize(); return 0; }\n\nwill output:\n\nHello thread 0,  $f = 1.2345$\n\nSelf- evidently, the if() statement limits which threads will call printf, so that only a single line of output is seen."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.34. Dynamic Global Memory Allocation and Operations - Dynamic global memory allocati......set size bytes of memory block...",
    "content": "Dynamic global memory allocation and operations are only supported by devices of compute capability 2. x and higher.\n\n```__host__ __device__ void* malloc(size_t size);__device__ void * _nv_aligned_device_malloc(size_t size, size_t align);__host__ __device__ void free(void* ptr);```\n\nallocate and free memory dynamically from a fixed- size heap in global memory.\n\n```__host__ __device__ void* memcpy(void* dest, const void* src, size_t size);```\n\ncopy size bytes from the memory location pointed by src to the memory location pointed by dest.\n\n```__host__ __device__ void* memset(void* ptr, int value, size_t size);```\n\nset size bytes of memory block pointed by ptr to value (interpreted as an unsigned char)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.34. Dynamic Global Memory Allocation and Operations - The CUDA in kernel malloc func......The CUDA in kernel nvalignedde...",
    "content": "The CUDA in- kernel malloc() function allocates at least size bytes from the device heap and returns a pointer to the allocated memory or NULL if insufficient memory exists to fulfill the request. The returned pointer is guaranteed to be aligned to a 16- byte boundary.\n\nThe CUDA in- kernel __nv_aligned_device_malloc() function allocates at least size bytes from the device heap and returns a pointer to the allocated memory or NULL if insufficient memory exists to fulfill the requested size or alignment. The address of the allocated memory will be a multiple of align. align must be a non- zero power of 2."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.34. Dynamic Global Memory Allocation and Operations - The CUDA in kernel free functi......The memory allocated by a give...",
    "content": "The CUDA in- kernel free() function deallocates the memory pointed to by ptr, which must have been returned by a previous call to malloc() or __nv_aligned_device_malloc(). If ptr is NULL, the call to free() is ignored. Repeated calls to free() with the same ptr has undefined behavior.\n\nThe memory allocated by a given CUDA thread via malloc() or __nv_aligned_device_malloc() remains allocated for the lifetime of the CUDA context, or until it is explicitly released by a call to free(). It can be used by any other CUDA threads even from subsequent kernel launches. Any CUDA thread may free memory allocated by another thread, but care should be taken to ensure that the same pointer is not freed more than once."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.34.1. Heap Memory Allocation - The device memory heap has a f......The heap size granted will be ...",
    "content": "The device memory heap has a fixed size that must be specified before any program using malloc(), _nv_aligned_device_malloc() or free() is loaded into the context. A default heap of eight megabytes is allocated if any program uses malloc() or _nv_aligned_device_malloc() without explicitly specifying the heap size.The following API functions get and set the heap size:\n\nThe following API functions get and set the heap size:\n\n- cudaDeviceGetLimit(size_t* size, cudaLimitMallocHeapSize)- cudaDeviceSetLimit(cudaLimitMallocHeapSize, size_t size)\n\nThe heap size granted will be at least size bytes. cuCtxGetLimit()and cudaDeviceGetLimit() return the currently requested heap size."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.34.1. Heap Memory Allocation - The actual memory allocation f......Memory reserved for the device...",
    "content": "The actual memory allocation for the heap occurs when a module is loaded into the context, either explicitly via the CUDA driver API (see Module), or implicitly via the CUDA runtime API (see CUDA Runtime). If the memory allocation fails, the module load will generate a CUDA_ERROR_SHARED_OBJECT_INIT_FAILED error.\n\nHeap size cannot be changed once a module load has occurred and it does not resize dynamically according to need.\n\nMemory reserved for the device heap is in addition to memory allocated through host- side CUDA API calls such as cudaMalloc()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.34.3. Examples - Memory allocated via device ma......In addition memory allocated b...",
    "content": "# 10.34.2. Interoperability with Host Memory API\nMemory allocated via device malloc() or _nv_aligned_device_malloc() cannot be freed using the runtime (i.e., by calling any of the free memory functions from Device Memory).\n\nSimilarly, memory allocated via the runtime (i.e., by calling any of the memory allocation functions from Device Memory) cannot be freed via free().\n\nIn addition, memory allocated by a call to malloc() or _nv_aligned_device_malloc() in device code cannot be used in any runtime or driver API calls (i.e. cudaMemcpy, cudaMemset, etc).\n\n# 10.34.3. Examples\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.34.3.1 Per Thread Allocation - The following code sample...Thread 0 got pointer 00057020 ...",
    "content": "The following code sample:\n\n```c#include <stdlib.h>#include <stdio.h>- - global__ void mallocTest(){    size_t size = 123;    char* ptr = (char*)malloc(size);    memset(ptr, 0, size);    printf(\"Thread %d got pointer: %p\\n\", threadIdx.x, ptr);}```\n\n(continues on next page)\n\nfree(ptr); } int main() { // Set a heap size of 128 megabytes. Note that this must // be done before any kernel is launched. cudaDeviceSetLimit(cudaLimitMallocSize, 128*1024*1024); mallocTest  $< < 1$ $5 > > > ()$  cudaDeviceSynchronize(); return 0; }\n\nwill output:\n\nThread 0 got pointer: 00057020 Thread 1 got pointer: 0005708c Thread 2 got pointer: 000570f8 Thread 3 got pointer: 00057164 Thread 4 got pointer: 000571d0"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.34.3.1 Per Thread Allocation - Notice how each thread encount...",
    "content": "Notice how each thread encounters the malloc() and memset() commands and so receives and initializes its own allocation. (Exact pointer values will vary: these are illustrative.)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.34.3.2 Per Thread Block Allocation",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "```c#include <stdlib.h>``` - cglobal void mallocTest...cshared int data  The first th...",
    "content": "```c__global__ void mallocTest() {```\n\n```c__shared__ int* data; // The first thread in the block does the allocation and then // shares the pointer with all other threads through shared memory, // so that access can easily be coalesced. // 64 bytes per thread are allocated. if (threadIdx.x == 0) { size_t size = blockDim.x * 64; data = (int*)malloc(size); } _syncthreads(); // Check for failure if (data == NULL) return; // Threads index into the memory, ensuring coalescence int* ptr = data; for (int i = 0; i < 64; ++i) ptr[i * blockDim.x + threadIdx.x] = threadIdx.x; // Ensure all threads complete before freeing _syncthreads(); // Only one thread may free the memory!```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "```c#include <stdlib.h>``` - if threadIdxx  0    freedatain...",
    "content": "if (threadIdx.x == 0)    free(data);}int main(){    cudaDeviceSetLimit(cudaLimitMallocHeapSize, 128*1024*1024);    mallocTest<<10, 128>>>();    cudaDeviceSynchronize();    return 0;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.34.3.3 Allocation Persisting Between Kernel Launches - include stdlibh include stdioh...",
    "content": "include <stdlib.h> #include <stdio.h> #define NUM_BLOCKS 20 __device__ int\\* dataptr[NUM_BLOCKS]; // Per- block pointer global__ void allocmem() { // Only the first thread in the block does the allocation // since we want only one allocation per block. if (threadIdx.x == 0) dataptr[blockIdx.x]  $=$  (int\\*)malloc(blockDim.x \\* 4); _syncthreads(); // Check for failure if (dataptr[blockIdx.x]  $= =$  NULL) return; // Zero the data with all threads in parallel dataptr[blockIdx.x][threadIdx.x]  $= 0$  . } // Simple example: store thread ID into each element global__ void usemem() { int\\* ptr  $=$  dataptr[blockIdx.x]; if (ptr  $! =$  NULL) ptr[threadIdx.x]  $+ =$  threadIdx.x; } // Print the content of the buffer before freeing it global__ void freemem() { int\\* ptr  $=$  dataptr[blockIdx."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.34.3.3 Allocation Persisting Between Kernel Launches - x if ptr     NULL printfBlock ...",
    "content": "x]; if (ptr  $! =$  NULL) printf(\"Block %d, Thread %d: final value  $=$  %d\\n\", blockIdx.x, threadIdx.x, ptr[threadIdx.x]); // Only free from one thread!"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.34.3.3 Allocation Persisting Between Kernel Launches - if threadIdxx    0  freeptr 1 ...",
    "content": "if (threadIdx.x  $= = 0$  free(ptr); 1 int main() { cudaDeviceSetLimit(cudaLimitMallocHeapSize, 128\\*1024\\*1024); // Allocate memory allocmem<<< NUM_BLOCKS, 10 >>>(); // Use memory usemem<<< NUM_BLOCKS, 10 >>>(); usemem<<< NUM_BLOCKS, 10 >>>(); // Free memory freemem<<< NUM_BLOCKS, 10 >>>(); cudaDeviceSynchronize(); return 0; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.35. Execution Configuration - Any call to a global function ......The execution configuration is...",
    "content": "Any call to a __global__ function must specify the execution configuration for that call. The execution configuration defines the dimension of the grid and blocks that will be used to execute the function on the device, as well as the associated stream (see CUDA Runtime for a description of streams).\n\nThe execution configuration is specified by inserting an expression of the form  $< < <$  Dg, Db, Ns, S >>> between the function name and the parenthesized argument list, where:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.35. Execution Configuration - Dg is of type dim3 see dim3 an......As an example a function decla...",
    "content": "Dg is of type dim3 (see dim3) and specifies the dimension and size of the grid, such that Dg.x \\* Dg.y \\* Dg.z equals the number of blocks being launched; Db is of type dim3 (see dim3) and specifies the dimension and size of each block, such that Db.x \\* Db.y \\* Db.z equals the number of threads per block; Ns is of type size_t and specifies the number of bytes in shared memory that is dynamically allocated per block for this call in addition to the statically allocated memory; this dynamically allocated memory is used by any of the variables declared as an external array as mentioned in shared...Ns is an optional argument which defaults to 0; S is of type cudaStream_t and specifies the associated stream; S is an optional argument which defaults to 0.\n\nAs an example, a function declared as"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.35. Execution Configuration - global void Funcfloat paramete......The function call will fail if...",
    "content": "__global__ void Func(float* parameter);\n\nmust be called like this:\n\nFunc<<< Dg, Db, Ns >>> (parameter);\n\nThe arguments to the execution configuration are evaluated before the actual function arguments.\n\nThe function call will fail if Dg or Db are greater than the maximum sizes allowed for the device as specified in Compute Capabilities, or if Ns is greater than the maximum amount of shared memory available on the device, minus the amount of shared memory required for static allocation."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.35. Execution Configuration - Compute capability 90 and abov......global void Funcfloat paramete...",
    "content": "Compute capability 9.0 and above allows users to specify compile time thread block cluster dimensions, so that the kernel can use the cluster hierarchy in CUDA. Compile time cluster dimension can be specified using __cluster_dims__([x, [y, [z]]]). The example below shows compile time cluster size of 2 in X dimension and 1 in Y and Z dimension.\n\n__global__ void __cluster_dims__(?, 1, 1) Func(float* parameter);\n\nThread block cluster dimensions can also be specified at runtime and kernel with the cluster can be launched using cudaLaunchKernelEx API. The API takes a configuration arugument of type cudaLaunchConfig_t, kernel function pointer and kernel arguments. Runtime kernel configuration is shown in the example below.\n\n__global__ void Func(float* parameter);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.35. Execution Configuration - Kernel invocation with runtime...",
    "content": "// Kernel invocation with runtime cluster size { cudaLaunchConfig_t config  $=$  {0}; // The grid dimension is not affected by cluster launch, and is still enumerated // using number of blocks. // The grid dimension should be a multiple of cluster size. config.gridDim  $=$  Dg; config.blockDim  $=$  Db; config.dynamicGmemBytes  $=$  Ns; cudaLaunchAttribute attribute[1]; attribute[0].id  $=$  cudaLaunchAttributeClusterDimension; attribute[0].val.clusterDim.x  $=$  2; // Cluster size in X- dimension attribute[0].val.clusterDim.y  $=$  1; attribute[0].val.clusterDim.z  $=$  1; config.attns  $=$  attribute; config.numAttrs  $=$  1; float\\* parameter; cudaLaunchKernelEx(&config, Func, parameter); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.36. Launch Bounds - As discussed in detail in Mult......global void   launchbounds max...",
    "content": "As discussed in detail in Multiprocessor Level, the fewer registers a kernel uses, the more threads and thread blocks are likely to reside on a multiprocessor, which can improve performance.\n\nTherefore, the compiler uses heuristics to minimize register usage while keeping register spilling (see Device Memory Accesses) and instruction count to a minimum. An application can optionally aid these heuristics by providing additional information to the compiler in the form of launch bounds that are specified using the __launch_bounds__( ) qualifier in the definition of a __global__ function:\n\nglobal void - - launch_bounds__ (maxThreadsPerBlock, minBlocksPerMultiprocessor, maxBlocksPerCluster) MyKernel(...) { }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.36. Launch Bounds - maxThreadsPerBlock specifies t......maxBlocksPerCluster is optiona...",
    "content": "- maxThreadsPerBlock specifies the maximum number of threads per block with which the application will ever launch MyKernel(); it compiles to the .maxntidPTX directive.  \n- minBlocksPerMultiprocessor is optional and specifies the desired minimum number of resident blocks per multiprocessor; it compiles to the .minnctapersmPTX directive.  \n- maxBlocksPerCluster is optional and specifies the desired maximum number thread blocks per cluster with which the application will ever launch MyKernel(); it compiles to the .maxclusterrankPTX directive."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.36. Launch Bounds - If launch bounds are specified...",
    "content": "If launch bounds are specified, the compiler first derives from them the upper limit  $L$  on the number of registers the kernel should use to ensure that minBlocksPerMultiprocessor blocks (or a single block if minBlocksPerMultiprocessor is not specified) of maxThreadsPerBlock threads can reside on the multiprocessor (see Hardware Multithreading for the relationship between the number of registers used by a kernel and the number of registers allocated per block). The compiler then optimizes register usage in the following way:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.36. Launch Bounds - If the initial register usage ...",
    "content": "- If the initial register usage is higher than  $L$ , the compiler reduces it further until it becomes less or equal to  $L$ , usually at the expense of more local memory usage and/or higher number of instructions;  - If the initial register usage is lower than  $L$   - If maxThreadsPerBlock is specified and minBlocksPerMultiprocessor is not, the compiler uses maxThreadsPerBlock to determine the register usage thresholds for the transitions between  $n$  and  $n + 1$  resident blocks (i.e., when using one less register makes room for an additional resident block as in the example of Multiprocessor Level) and then applies similar heuristics as when no launch bounds are specified;  "
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.36. Launch Bounds - If both minBlocksPerMultiproce...",
    "content": "- If both minBlocksPerMultiprocessor and maxThreadsPerBlock are specified, the compiler may increase register usage as high as  $L$  to reduce the number of instructions and better hide single thread instruction latency."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.36. Launch Bounds - A kernel will fail to launch i...",
    "content": "A kernel will fail to launch if it is executed with more threads per block than its launch bound maxThreadsPerBlock.\n\nA kernel will fail to launch if it is executed with more thread blocks per cluster than its launch bound maxBlocksPerCluster."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.36. Launch Bounds - Per thread resources required ...",
    "content": "Per thread resources required by a CUDA kernel might limit the maximum block size in an unwanted way. In order to maintain forward compatibility to future hardware and toolkits and to ensure that at least one thread block can run on an SM, developers should include the single argument __launch_bounds__(maxThreadsPerBlock) which specifies the largest block size that the kernel will be launched with. Failure to do so could lead to \"too many resources requested for launch\" errors. Providing the two argument version of __launch_bounds__(maxThreadsPerBlock, minBlocksPerMultiprocessor) can improve performance in some cases. The right value for minBlocksPerMultiprocessor should be determined using a detailed per kernel analysis."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.36. Launch Bounds - Optimal launch bounds for a gi......define THREADSPERBLOCK 256 if ...",
    "content": "Optimal launch bounds for a given kernel will usually differ across major architecture revisions. The sample code below shows how this is typically handled in device code using the __CUDA_ARCH__ macro introduced in Application Compatibility\n\ndefine THREADS_PER_BLOCK 256 #if _CUDA_ARCH_  $> = 200$  #define MY KERNEL MAX THREADS (2 \\* THREADS_PER_BLOCK) #define MY KERNEL MIN BLOCKS 3 #else #define MY KERNEL MAX THREADS THREADS_PER_BLOCK #define MY KERNEL MIN BLOCKS 2 #endif // Device code global _void _launch_bounds__MY KERNEL MAX THREADS, MY KERNEL MIN BLOCKS) MyKernel(...) { 1 }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.36. Launch Bounds - In the common case where MyKer......Host code MyKernelblocksPerGri...",
    "content": "In the common case where MyKernel is invoked with the maximum number of threads per block (specified as the first parameter of \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_ MY KERNEL MAX THREADS as the number of threads per block in the execution configuration:\n\n// Host code MyKernel<<blocksPerGrid, MY KERNEL MAX THREADS>>>(...);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.36. Launch Bounds - This will not work however sin......Either at compile time using a...",
    "content": "This will not work however since \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_ This will not work however since \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_ MyKernel<<blocksPerGrid, threadsPerBlock>>>(...);\n\nEither at compile time using a macro that does not depend on \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.36. Launch Bounds - Host code MyKernelblocksPerGri......Register usage is reported by ...",
    "content": "// Host code MyKernel<<blocksPerGrid, THREADS_PER_BLOCK>>>(...); Or at runtime based on the compute capability // Host code cudaGetDeviceProperties(&deviceProp, device); int threadsPerBlock = (deviceProp.major >= 2 ? 2 * THREADS_PER_BLOCK : THREADS_PER_BLOCK); MyKernel<<blocksPerGrid, threadsPerBlock>>>(...);\n\nRegister usage is reported by the - - ptxas- options  $\\mathbf{\\beta} = \\mathbf{- v}$  compiler option. The number of resident blocks can be derived from the occupancy reported by the CUDA profiler (see Device Memory Accesses for a definition of occupancy)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.36. Launch Bounds - Register usage can also be con...",
    "content": "Register usage can also be controlled for all \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\  $\\mathbf{\\beta} = \\mathbf{- v}$  compiler option. The value of maxr regcount is ignored for functions with launch bounds."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.37. #pragma unroll - By default the compiler unroll......Examples",
    "content": "By default, the compiler unrolls small loops with a known trip count. The #pragma unroll directive however can be used to control unrolling of any given loop. It must be placed immediately before the loop and only applies to that loop. It is optionally followed by an integral constant expression (ICE)13. If the ICE is absent, the loop will be completely unrolled if its trip count is constant. If the ICE evaluates to 1, the compiler will not unroll the loop. The pragma will be ignored if the ICE evaluates to a non- positive integer or to an integer greater than the maximum value representable by the int data type.\n\nExamples:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.37. #pragma unroll - struct S1t  static const int v...",
    "content": "struct S1_t { static const int value  $= 4$  ; }; template <int X, typename T2> _device__ void foo(int \\*p1, int \\*p2) { // no argument specified, loop will be completely unrolled #pragma unroll for (int  $\\texttt{i} = \\texttt{0}$  ;  $\\texttt{i} < 12$  ;  $^{+ + 1}$  p1[i]  $+ =$  p2[i]\\*2; // unroll value  $= 8$  #pragma unroll  $(x + 1)$  for (int  $\\texttt{i} = \\texttt{0}$  ;  $\\texttt{i} < 12$  ;  $^{+ + 1}$  p1[i]  $+ =$  p2[i]\\*2; // unroll value  $= 1$  loop unrolling disabled #pragma unroll 1 for (int  $\\texttt{i} = \\texttt{0}$  ;  $\\texttt{i} < 12$  ;  $^{+ + 1}$  p1[i]  $+ =$  p2[i]\\*8; // unroll value  $= 4$  #pragma unroll (T2::value) for (int  $\\texttt{i} = \\texttt{0}$  ;  $\\texttt{i} < 12$  ;  $^{+ + 1}$  p1[i]  $+ =$  p2[i]\\*16; } - global__ void bar(int \\*p1, int \\*p2) { f"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.37. #pragma unroll - oo7 S1tp1 p2",
    "content": "oo<7, S1_t>(p1, p2); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.38. SIMD Video Instructions - PTX ISA version 30 includes SI......asmvabsdiff4 u32 u32 add 0 1 2...",
    "content": "PTX ISA version 3.0 includes SIMD (Single Instruction, Multiple Data) video instructions which operate on pairs of 16- bit values and quads of 8- bit values. These are available on devices of compute capability 3.0.\n\nThe SIMD video instructions are:\n\n- vadd2, vadd4- vsub2, vsub4- vavrg2, vavrg4\n\n- vabsdiff2, vabsdiff4- vmin2, vmin4- vmax2, vmax4- vset2, vset4\n\nPTX instructions, such as the SIMD video instructions, can be included in CUDA programs by way of the assembler, asm(), statement.\n\nThe basic syntax of an asm() statement is:\n\nasm(\"template- string\" : \"constraint\"(output) : \"constraint\"(input)\"));\n\nAn example of using the vabsdiff4 PTX instruction is:\n\nasm(\"vabsdiff4. u32. u32. add\" %0, %1, %2, %3;\": \"=r\" (result):\"r\" (A), \"r\" (B), \"r\" (C));"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.38. SIMD Video Instructions - This uses the vabsdiff4 instru......Refer to the document Using In...",
    "content": "This uses the vabsdiff4 instruction to compute an integer quad byte SIMD sum of absolute differences. The absolute difference value is computed for each byte of the unsigned integers A and B in SIMD fashion. The optional accumulate operation (. add) is specified to sum these differences.\n\nRefer to the document \"Using Inline PTX Assembly in CUDA\" for details on using the assembly statement in your code. Refer to the PTX ISA documentation (\"Parallel Thread Execution ISA Version 3.0\" for example) for details on the PTX instructions for the version of PTX that you are using."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.39. Diagnostic Pragmas - The following pragmas may be u......cpragma nvdiagxxxerrornumber e...",
    "content": "The following pragmas may be used to control the error severity used when a given diagnostic message is issued.\n\n```c#pragma nv_diag_suppress#pragma nv_diag_warning#pragma nv_diag_error#pragma nv_diag_default#pragma nv_diag_once```\n\nUses of these pragmas have the following form:\n\n```c#pragma nv_diag_xxx_error_number, error_number ...```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.39. Diagnostic Pragmas - The diagnostic affected is spe......void bar  int  dotmathbf1  The...",
    "content": "The diagnostic affected is specified using an error number showed in a warning message. Any diagnostic may be overridden to be an error, but only warnings may have their severity suppressed or be restored to a warning after being promoted to an error. The nv_diag_default pragmas is used to return the severity of a diagnostic to the one that was in effect before any pragmas were issued (i.e., the normal severity of the message as modified by any command- line options). The following example suppresses the \"declared but never referenced\" warning on the declaration of foo:\n\n```c#pragma nv_diag_suppress177void foo(){    int i = 0;}```\n\n(continues on next page)\n\nvoid bar() { int  $\\dot{\\mathbf{1}} = \\Theta$  }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "10.39. Diagnostic Pragmas - The following pragmas may be u......Removal Notice The support of ...",
    "content": "The following pragmas may be used to save and restore the current diagnostic pragma state:\n\npragma nv_diagnostic push #pragma nv_diagnostic pop\n\nExamples:\n\n#pragma nv_diagnostic push #pragma nv_diag_suppress 177 void foo() { int  $\\dot{\\mathbf{1}} = \\Theta$  } #pragma nv_diagnostic pop void bar() { int  $\\dot{\\mathbf{1}} = \\Theta$  }\n\nNote that the pragmas only affect the nvcc CUDA frontend compiler; they have no effect on the host compiler.\n\nRemoval Notice: The support of diagnostic pragmas without nv_ prefix are removed from CUDA 12.0, if the pragmas are inside the device code, warning unrecognized #pragma in device code will be emitted, otherwise they will be passed to the host compiler. If they are intended for CUDA code, use the pragmas with nv_ prefix instead."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 11. Cooperative Groups",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.1. Introduction - Cooperative Groups is an exten...",
    "content": "Cooperative Groups is an extension to the CUDA programming model, introduced in CUDA 9, for organizing groups of communicating threads. Cooperative Groups allows developers to express the granularity at which threads are communicating, helping them to express richer, more efficient parallel decompositions."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.1. Introduction - Historically the CUDA programm...",
    "content": "Historically, the CUDA programming model has provided a single, simple construct for synchronizing cooperating threads: a barrier across all threads of a thread block, as implemented with the __syncthreads() intrinsic function. However, programmers would like to define and synchronize groups of threads at other granularities to enable greater performance, design flexibility, and software reuse in the form of \"collective\" group- wide function interfaces. In an effort to express broader patterns of parallel interaction, many performance- oriented programmers have resorted to writing their own ad hoc and unsafe primitives for synchronizing threads within a single warp, or across sets of thread blocks running on a single GPU."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.1. Introduction - Whilst the performance improve...",
    "content": " Whilst the performance improvements achieved have often been valuable, this has resulted in an ever- growing collection of brittle code that is expensive to write, tune, and maintain over time and across GPU generations. Cooperative Groups addresses this by providing a safe and future- proof mechanism to enable performant code."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.2.2. CUDA 12.0 - invokeone and invokeonebroadca......It is no longer required to pr...",
    "content": "\n\n# 11.2.1. CUDA 12.1\n- invoke_one and invoke_one_broadcast APIs were added.\n\n# 11.2.2. CUDA 12.0\n- The following experimental APIs are now moved to the main namespace:    \n- asynchronous reduce and scan update added in CUDA 11.7    \n- thread_block_tile larger than 32 added in CUDA 11.1\n\n- It is no longer required to provide memory using the block_tile_memory object in order to create these large tiles on Compute Capability 8.0 or higher."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.3. Programming Model Concept - The Cooperative Groups program...",
    "content": "The Cooperative Groups programming model describes synchronization patterns both within and across CUDA thread blocks. It provides both the means for applications to define their own groups of threads, and the interfaces to synchronize them. It also provides new launch APIs that enforce certain restrictions and therefore can guarantee the synchronization will work. These primitives enable new patterns of cooperative parallelism within CUDA, including producer- consumer parallelism, opportunistic parallelism, and global synchronization across the entire Grid.\n\nThe Cooperative Groups programming model consists of the following elements:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.3. Programming Model Concept - Data types for representing gr...",
    "content": "Data types for representing groups of cooperating threads;  $\\triangleright$  Operations to obtain implicit groups defined by the CUDA launch API (e.g., thread blocks);  $\\triangleright$  Collectives for partitioning existing groups into new groups;  $\\triangleright$  Collective Algorithms for data movement and manipulation (e.g. memcpy_async, reduce, scan);  $\\triangleright$  An operation to synchronize all threads within the group;  $\\triangleright$  Operations to inspect the group properties;  $\\triangleright$  Collectives that expose low- level, group- specific and often HW accelerated, operations."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.3. Programming Model Concept - The main concept in Cooperativ......To write efficient code its be...",
    "content": "The main concept in Cooperative Groups is that of objects naming the set of threads that are part of it. This expression of groups as first- class program objects improves software composition, since collective functions can receive an explicit object representing the group of participating threads. This object also makes programmer intent explicit, which eliminates unsound architectural assumptions that result in brittle code, undesirable restrictions upon compiler optimizations, and better compatibility with new GPU generations.\n\nTo write efficient code, its best to use specialized groups (going generic loses a lot of compile time op. timizations), and pass these group objects by reference to functions that intend to use these threads in some cooperative fashion."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.3. Programming Model Concept - Cooperative Groups requires CU......using namespace cooperativegro...",
    "content": "Cooperative Groups requires CUDA 9.0 or later. To use Cooperative Groups, include the header file:\n\n// Primary header is compatible with pre- C++11, collective algorithm headers require  $\\rightarrow C + + 11$  #include <cooperative_groups.h> // Optionally include for memcpy_async() collective #include <cooperative_groups/memcpy_async.h> // Optionally include for reduce() collective #include <cooperative_groups/reduce.h> // Optionally include for inclusive_scan() and exclusive_scan() collectives #include <cooperative_groups/scan.h>\n\nand use the Cooperative Groups namespace:\n\nusing namespace cooperative_groups; // Alternatively use an alias to avoid polluting the namespace with collective  $\\rightarrow$  algorithms namespace cg = cooperative_groups;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.3. Programming Model Concept - The code can be compiled in a ...",
    "content": "The code can be compiled in a normal way using nvcc, however if you wish to use memcpy_async, reduce or scan functionality and your host compiler's default dialect is not C++11 or higher, then you must add - - std=c++11 to the command line."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.3.1. Composition Example - To illustrate the concept of g......All threads in the thread bloc...",
    "content": "To illustrate the concept of groups, this example attempts to perform a block- wide sum reduction. Previously, there were hidden constraints on the implementation when writing this code:\n\ndevice int sum(int \\*x, int n) { // . . . _syncthreads(); return total; } global void parallel_kernel(float  $\\ast \\times$  ){ // . . . // Entire thread block must call sum sum(x, n); }\n\nAll threads in the thread block must arrive at the __syncthreads() barrier, however, this constraint is hidden from the developer who might want to use sum(...). With Cooperative Groups, a better way of writing this would be:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.3.1. Composition Example - device int sumconst threadbloc...",
    "content": "device int sum(const thread_block& g, int \\*x, int n) { // g.sync() return total; } global void parallel_kernel(...) { // . . . // Entire thread block must call sum thread_block tb  $=$  this_thread_block(); sum(tb, x, n); // }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.4. Group Types",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.4.1. Implicit Groups - Implicit groups represent the ...",
    "content": "Implicit groups represent the launch configuration of the kernel. Regardless of how your kernel is written, it always has a set number of threads, blocks and block dimensions, a single grid and grid dimensions. In addition, if the multi- device cooperative launch API is used, it can have multiple grids (single grid per device). These groups provide a starting point for decomposition into finer grained groups which are typically HW accelerated and are more specialized for the problem the developer is solving."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.4.1. Implicit Groups - Although you can create an imp......Group handles must be initiali...",
    "content": "Although you can create an implicit group anywhere in the code, it is dangerous to do so. Creating a handle for an implicit group is a collective operation- - all threads in the group must participate. If the group was created in a conditional branch that not all threads reach, this can lead to deadlocks or data corruption. For this reason, it is recommended that you create a handle for the implicit group upfront (as early as possible, before any branching has occurred) and use that handle throughout the kernel.\n\nGroup handles must be initialized at declaration time (there is no default constructor) for the same reason and copy- constructing them is discouraged."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.4.1.1 Thread Block Group - Any CUDA programmer is already......threadblock g  thisthreadblock",
    "content": "Any CUDA programmer is already familiar with a certain group of threads: the thread block. The Cooperative Groups extension introduces a new datatype, thread_block, to explicitly represent this concept within the kernel.\n\nclass thread_block:\n\nConstructed via:\n\nthread_block g = this_thread_block();"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Public Member Functions: - static void sync Synchronize t...",
    "content": "# Public Member Functions:\nstatic void sync(): Synchronize the threads named in the group static unsigned int thread_rank(): Rank of the calling thread within [0, num_threads) static dim3 group_index(): 3- Dimensional index of the block within the launched grid static dim3 thread_index(): 3- Dimensional index of the thread within the launched block static dim3 dim_threads(): Dimensions of the launched block in units of threads static unsigned int num_threads(): Total number of threads in the group Legacy member functions (aliases): static unsigned int size(): Total number of threads in the group (alias of num_threads()) static dim3 group_dim(): Dimensions of the launched block (alias of dim_threads())"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - Loading an integer from global......Related The threadblock dataty...",
    "content": "# Example:\n/// Loading an integer from global into shared memory - - global__ void kernel(int *globalInput) { - - shared__ int x; thread_block g = this_thread_block(); // Choose a leader in the thread block if (g.thread_rank() == 0) { // load from global into shared for all threads to work with x = (*globalInput); } // After loading data into shared memory, you want to synchronize // if all threads in your thread block need to see it g.sync(); // equivalent to __syncthreads(); }\n\nNote: that all threads in the group must participate in collective operations, or the behavior is undefined.\n\nRelated: The thread_block datatype is derived from the more generic thread_group datatype, which can be used to represent a wider class of groups."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.4.1.2 Cluster Group - This group object represents a......clustergroup g  thiscluster",
    "content": "This group object represents all the threads launched in a single cluster. Refer to Thread Block Clusters. The APIs are available on all hardware with Compute Capability  $9.0+$  . In such cases, when a non- cluster grid is launched, the APIs assume a 1x1x1 cluster.\n\nclass cluster_group;\n\nConstructed via:\n\ncluster_group g = this_cluster();"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Public Member Functions: - static void sync Synchronize t...",
    "content": "static void sync(): Synchronize the threads named in the group static cluster_group::arrival_token barrier_arrive(): Arrive on the cluster barrier, returns a token that needs to be passed into barrier_wait()"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Public Member Functions: - static void barrierwaitcluster...",
    "content": "static void barrier_wait(cluster_group::arrival_token&& t): Wait on the cluster barrier, takes arrival token returned from barrier_arrive() as a rvalue reference static unsigned int thread_rank(): Rank of the calling thread within [0, num_threads) static unsigned int block_rank(): Rank of the calling block within [0, num_blocks) static unsigned int num_threads(): Total number of threads in the group static unsigned int num_blocks(): Total number of blocks in the group static dim3 dim_threads(): Dimensions of the launched cluster in units of threads static dim3 dim_blocks(): Dimensions of the launched cluster in units of blocks static dim3 block_index(): 3- Dimensional index of the calling block within the launched cluster static unsigned int query_shared_rank(const void \\*addr): Obtain the"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Public Member Functions: - block rank to which a shared m...",
    "content": " block rank to which a shared memory address belongs static T\\* map_shared_rank(T \\*addr, int rank): Obtain the address of a shared memory variable of another block in the cluster"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Public Member Functions: - Legacy member functions aliase......continues on next page",
    "content": "Legacy member functions (aliases):\n\nstatic unsigned int size(): Total number of threads in the group (alias of num_threads())\n\nExample of ``barrier_arrive`` and ``barrier_wait`` used to synchronize initialization of shared memory across the cluster:\n\n```cpp#include <cooperative_groups.h>```\n\nusing namespace cooperative_groups;\n\n```cppvoid __device__init_shared_data(const thread_block& block, int *data);void __device__local_processing(const thread_block& block);void __device__process_shared_data(const thread_block& block, int *data);__global__ void cluster_kernel() {    extern __shared__ int array[];    auto cluster = this_cluster();    auto block = this_thread_block();    // Use this thread block to initialize some shared state}```\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Public Member Functions: - initshareddatablock array0auto...",
    "content": "init_shared_data(block, &array[0]);auto token = cluster.barrier_arrive(); // Let other blocks know this block is running and data was initialized// Do some local processing to hide the synchronization latencylocal_processing(block);// Map data in shared memory from the next block in the clusterint *dsmem = cluster.map_shared_rank(&array[0], (cluster.block_rank() + 1) % cluster.num_blocks());// Make sure all other blocks in the cluster are running and initialized shared data before accessing dsmemcluster.barrier_wait(std::move(token));// Consume data in distributed shared memoryprocess_shared_data(block, dsmem);}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.4.1.3 Grid Group - This group object represents a......gridgroup g  thisgrid",
    "content": "This group object represents all the threads launched in a single grid. APIs other than sync() are available at all times, but to be able to synchronize across the grid, you need to use the cooperative launch API.\n\nclass grid_group;\n\nConstructed via:\n\ngrid_group g = this_grid();"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Public Member Functions: - bool isvalid const Returns whe...",
    "content": "bool is_valid() const: Returns whether the grid_group can synchronizevoid sync() const: Synchronize the threads named in the groupstatic unsigned long long thread_rank() Rank of the calling thread within [0, num_threads)static unsigned long long block_rank(): Rank of the calling block within [0, num_blocks)static unsigned long long cluster_rank() Rank of the calling cluster within [0, num_clusters)static unsigned long long num_threads(): Total number of threads in the groupstatic unsigned long long num_blocks(): Total number of blocks in the groupstatic unsigned long long num_clusters(): Total number of clusters in the groupstatic dim3 dim_blocks(): Dimensions of the launched grid in units of blocksstatic dim3 dim_clusters(): Dimensions of the launched grid in units of clustersstatic dim3 "
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Public Member Functions: - blockindex 3 Dimensional index...",
    "content": "block_index(): 3- Dimensional index of the block within the launched gridstatic dim3 cluster_index(): 3- Dimensional index of the cluster within the launched gridLegacy member functions (aliases):"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Public Member Functions: - static unsigned long long size......static dim3 groupdim Dimension...",
    "content": "static unsigned long long size(): Total number of threads in the group (alias of num_threads())\n\nstatic dim3 group_dim(): Dimensions of the launched grid (alias of dim_blocks())"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.4.1.4 Multi Grid Group - This group object represents a......Kernel must be launched with t...",
    "content": "This group object represents all the threads launched across all devices of a multi- device cooperative launch. Unlike the grid.group, all the APIs require that you have used the appropriate launch API. class multi_grid_group;\n\nConstructed via:\n\n// Kernel must be launched with the cooperative multi- device API multi_grid_group g = this_multi_grid();"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.4.2. Explicit Groups - bool isvalid const Returns whe...",
    "content": "# Public Member Functions:\nbool is_valid() const: Returns whether the multi_grid_group can be used void sync() const: Synchronize the threads named in the group unsigned long long num_threads() const: Total number of threads in the group unsigned long long thread_rank() const: Rank of the calling thread within [0, num_threads) unsigned int grid_rank() const: Rank of the grid within [0, num grids] unsigned int num grids() const: Total number of grids launched Legacy member functions (aliases): unsigned long long size() const: Total number of threads in the group (alias of num_threads()) Deprecation Notice: multi_grid_group has been deprecated in CUDA 11.3 for all devices.\n\n# 11.4.2. Explicit Groups\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.4.2.1 Thread Block Tile - A templated version of a tiled......ParentT is the parent type fro...",
    "content": "# 11.4.2.1 Thread Block Tile\nA templated version of a tiled group, where a template parameter is used to specify the size of the tile - with this known at compile time there is the potential for more optimal execution.\n\ntemplate <unsigned int Size, typename ParentT = void> class thread_block_tile;\n\nConstructed via:\n\ntemplate <unsigned int Size, typename ParentT> _CG_QUALIFIER thread_block_tile<Size, ParentT> tiled_partition(const ParentT& g)\n\nSize must be a power of 2 and less than or equal to 1024. Notes section describes extra steps needed to create tiles of size larger than 32 on hardware with Compute Capability 7.5 or lower.\n\nParentT is the parent- type from which this group was partitioned. It is automatically inferred, but a value of void will store this information in the group handle rather than in the type."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Public Member Functions: - void sync const Synchronize th......T shflT var unsigned int srcra...",
    "content": "void sync() const: Synchronize the threads named in the group unsigned long long num_threads() const: Total number of threads in the group unsigned long long thread_rank() const: Rank of the calling thread within [0, num_threads) unsigned long long meta_group_size() const: Returns the number of groups created when the parent group was partitioned.\n\nunsigned long long meta_group_rank() const: Linear rank of the group within the set of tiles partitioned from a parent group (bounded by meta_group_size)\n\nT shfl(T var, unsigned int src_rank) const: Refer to Warp Shuffle Functions, Note: For sizes larger than 32 all threads in the group have to specify the same src_rank, otherwise the behavior is undefined."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Public Member Functions: - T shflupT var int delta const ......unsigned int matchanyT val con...",
    "content": "T shfl_up(T var, int delta) const: Refer to Warp Shuffle Functions, available only for sizes lower or equal to 32.\n\nT shfl_down(T var, int delta) const: Refer to Warp Shuffle Functions, available only for sizes lower or equal to 32.\n\nT shfl_xor(T var, int delta) const: Refer to Warp Shuffle Functions, available only for sizes lower or equal to 32.\n\nT any(int predicate) const: Refer to Warp Vote Functions\n\nT all(int predicate) const: Refer to Warp Vote Functions\n\nT ballot(int predicate) const: Refer to Warp Vote Functions, available only for sizes lower or equal to 32.\n\nunsigned int match_any(T val) const: Refer to Warp Match Functions, available only for sizes lower or equal to 32."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Public Member Functions: - unsigned int matchallT val int......unsigned long long size const ...",
    "content": "unsigned int match_all(T val, int &pred) const: Refer to Warp Match Functions, available only for sizes lower or equal to 32.\n\nLegacy member functions (aliases):\n\nunsigned long long size() const: Total number of threads in the group (alias of num_threads())"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Notes: - threadblocktile templated data...",
    "content": "thread_block_tile templated data structure is being used here, the size of the group is passed to the tiled_partition call as a template parameter rather than an argument. shfl, shfl_up, shfl_down, and shfl_xor functions accept objects of any type when compiled with  $\\mathtt{C + + 11}$  or later. This means it's possible to shuffle non- integral types as long as they satisfy the below constraints: Qualifies as trivially copyable i.e., is_trivially_copyable<T>::value  $= =$  true sizeof(T)  $< = 32$  for tile sizes lower or equal 32, sizeof(T)  $< = 8$  for larger tiles On hardware with Compute Capability 7.5 or lower tiles of size larger than 32 need small amount of memory reserved for them."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Notes: - This can be done using coopera...",
    "content": " This can be done using cooperative_groups::block_tile_memory struct template that has to reside in either shared or global memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Notes: - template unsigned int MaxBlock......This blocktilememory needs be ...",
    "content": "template <unsigned int MaxBlockSize = 1024>  struct block_tile_memory;\n\nMaxBlockSize Specifies the maximal number of threads in the current thread block. This parameter can be used to minimize the shared memory usage of block_tile_memory in kernels launched only with smaller thread counts.\n\nThis block_tile_memory needs be then passed into cooperative_groups::this_thread_block, allowing the resulting thread_block to be partitioned into tiles of sizes larger than 32. Overload of this_thread_block accepting block_tile_memory argument is a collective operation and has to be called with all threads in the thread_block."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Notes: - blocktilememory can be used on...",
    "content": "block_tile_memory can be used on hardware with Compute Capability 8.0 or higher in order to be able to write one source targeting multiple different Compute Capabilities. It should consume no memory when instantiated in shared memory in cases where its not required."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Examples: - The following code will create...",
    "content": "/// The following code will create two sets of tiled groups, of size 32 and 4  $\\leftrightarrow$  respectively: /// The latter has the provenance encoded in the type, while the first stores it in the  $\\leftrightarrow$  handle thread_block_block  $=$  this_thread_block(); thread_block_tile  $< 32>$  tile32  $=$  tiled_partition  $< 32>$  (block); thread_block_tile  $< 4$  , thread_block> tile4  $=$  tiled_partition  $< 4>$  (block);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Examples: - The following code will create...",
    "content": "/// The following code will create tiles of size 128 on all Compute Capabilities. /// block_tile_memory can be omitted on Compute Capability 8.0 or higher. - - global__ void kernel(...) { // reserve shared memory for thread_block_tile usage, // specify that block_size will be at most 256 threads. - - shared__ block_tile_memory  $< 256>$  shared; thread_block thb  $=$  this_thread_block(shared); // Create tiles with 128 threads. auto tile  $=$  tiled_partition  $< 128>$  (thb); // ... }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.4.2.1.1 Warp-Synchronous Code Pattern - Developers might have had warp......mytilesync",
    "content": "# 11.4.2.1.1 Warp-Synchronous Code Pattern\nDevelopers might have had warp- synchronous codes that they previously made implicit assumptions about the warp size and would code around that number. Now this needs to be specified explicitly.\n\n- global__ void cooperative_kernel(...) { // obtain default \"current thread_block\" group thread_block my_block  $=$  this_thread_block(); // subdivide into 32-thread, tiled subgroups // Tiled subgroups evenly partition a parent group into // adjacent sets of threads \n- in this case each one warp in size auto my_tile  $=$  tiled_partition  $< 32>$  (my_block); // This operation will be performed by only the // first 32-thread tile of each block if (my_tile.meta_group_rank() == 0) { // ...\n\n(continues on next page)\n\nmy_tile.sync(); } }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.4.2.1.2 Single thread group - Group representing the current......More detailed examples of usin...",
    "content": "# 11.4.2.1.2 Single thread group\nGroup representing the current thread can be obtained from this_thread function:\n\nthread_block_tile  $< 1>$  this_thread();\n\nThe following memcpy_async API uses a thread_group, to copy an int element from source to destination:\n\n```c#include <cooperative_groups.h>#include <cooperative_groups/memcpy_async.h>cooperative_groups::memcpy_async(cooperative_groups::this_thread(), dest, src, sizeof(int));```\n\nMore detailed examples of using this_thread to perform asynchronous copies can be found in the Single- Stage Asynchronous Data Copies using cuda::pipeline and Multi- Stage Asynchronous Data Copies using cuda:pipeline sections."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.4.2.1.3 Thread Block Tile of size larger than 32 - It is possible to obtain threa......TileCommunicationSize Determin...",
    "content": "It is possible to obtain thread_block_tile of size 64, 128, 256 or 512 using new API present in cooperative_groups::experimental namespace. To use it, _CG_ABS_EXPERIMENTAL has to be defined in the source code. Before partitioning, a small amount of memory has to be reserved for thread_block_tile usage. This can be done using cooperative_groups::experimental::block_tile_memory struct template shared or global memory.\n\n```cpptemplate <unsigned int TileCommunicationSize = 8, unsigned int MaxBlockSize = 1024> struct block_tile_memory;```\n\nTileCommunicationSize Determines how much memory is reserved for collective operations. If such operation is performed on type of size larger than specified communication size, the collective may involve multiple transfers and take longer to complete."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.4.2.1.3 Thread Block Tile of size larger than 32 - MaxBlockSize Specifies the max......define CGABEXPERIMENTAL  enabl...",
    "content": "MaxBlockSize Specifies the maximal number of threads in the current thread block. This parameter can be used to minimize the shared memory usage of block_tile_memory in kernels launched only with smaller thread counts.\n\n```cppthis_block_tile_memory needs be then passed into cooperative_groups::experimental::this_thread_block, allowing the resulting thread_block to be partitioned into tiles of sizes larger than 32. Overload of this_thread_block accepting block_tile_memory argument is a collective operation and has to be called with all threads in the thread_block. Returned thread_block can be partitioned using experimental::tiled_partition function template, which accepts the same arguments as the regular tiled_partition.```\n\ndefine _CG_AB_EXPERIMENTAL // enable experimental API"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.4.2.1.3 Thread Block Tile of size larger than 32 - define CGABEXPERIMENTAL  enabl...",
    "content": "define _CG_AB_EXPERIMENTAL // enable experimental API```---global__ void cooperative_kernel(...) {    // reserve shared memory for thread_block_tile_usage.    __shared__ experimental::block_tile_memory<4, 256> shared;    thread_block_thb = experimental::this_thread_block(shared);    auto tile = experimental::tiled_partition<128>(thb);    // ...}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Public Member Functions: - void sync const Synchronize th......T shflT var unsigned int srcra...",
    "content": "void sync() const: Synchronize the threads named in the group unsigned long long num_threads() const: Total number of threads in the group  unsigned long long thread_rank() const: Rank of the calling thread within [0, num_threads)  unsigned long long meta_group_size() const: Returns the number of groups created when the parent group was partitioned.\n\nunsigned long long meta_group_rank() const: Linear rank of the group within the set of tiles partitioned from a parent group (bounded by meta_group_size)\n\nT shfl(T var, unsigned int src_rank) const: Refer to Warp Shuffle Functions, Note: All threads in the group have to specify the same src_rank, otherwise the behavior is undefined."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Public Member Functions: - T anyint predicate const Refer......unsigned long long size const ...",
    "content": "T any(int predicate) const: Refer to Warp Vote Functions  T all(int predicate) const: Refer to Warp Vote Functions\n\nLegacy member functions (aliases):\n\nunsigned long long size() const: Total number of threads in the group (alias of num_threads())"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.4.2.2 Coalesced Groups - In CUDAs SIMT architecture at ...",
    "content": "In CUDA's SIMT architecture, at the hardware level the multiprocessor executes threads in groups of 32 called warps. If there exists a data- dependent conditional branch in the application code such that threads within a warp diverge, then the warp serially executes each branch disabling threads not on that path. The threads that remain active on the path are referred to as coalesced. Cooperative Groups has functionality to discover, and create, a group containing all coalesced threads."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.4.2.2 Coalesced Groups - Constructing the group handle ......coalescedgroup active  coalesc...",
    "content": "Constructing the group handle via coalesced_threads() is opportunistic. It returns the set of active threads at that point in time, and makes no guarantee about which threads are returned (as long as they are active) or that they will stay coalesced throughout execution (they will be brought back together for the execution of a collective but can diverge again afterwards).\n\nclass coalesced_group;\n\nConstructed via:\n\ncoalesced_group active = coalesced_threads();"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Public Member Functions: - void sync const Synchronize th......unsigned long long metagroupra...",
    "content": "void sync() const: Synchronize the threads named in the group\n\nunsigned long long num_threads() const: Total number of threads in the group unsigned long long thread_rank() const: Rank of the calling thread within [0, num_threads) unsigned long long meta_group_size() const: Returns the number of groups created when the parent group was partitioned. If this group was created by querying the set of active threads, e.g. coalesced_threads() the value of meta_group_size() will be 1.\n\nunsigned long long meta_group_rank() const: Linear rank of the group within the set of tiles partitioned from a parent group (bounded by meta_group_size). If this group was created by querying the set of active threads, e.g. coalesced_threads() the value of meta_group_rank() will always be 0."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Public Member Functions: - T shflT var unsigned int srcra...",
    "content": "T shfl(T var, unsigned int src_rank) const: Refer to Warp Shuffle Functions  T shfl_up(T var, int delta) const: Refer to Warp Shuffle Functions  T shfl_down(T var, int delta) const: Refer to Warp Shuffle Functions  T any(int predicate) const: Refer to Warp Vote Functions  T all(int predicate) const: Refer to Warp Vote Functions  T ballot(int predicate) const: Refer to Warp Vote Functions  unsigned int match_any(T val) const: Refer to Warp Match Functions  unsigned int match_all(T val, int &pred) const: Refer to Warp Match Functions  Legacy member functions (aliases):  unsigned long long size() const: Total number of threads in the group (alias of num_threads())"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Notes: - shfl shflup and shfldown funct......Qualifies as trivially copyabl...",
    "content": "shfl, shfl_up, and shfl_down functions accept objects of any type when compiled with  $\\mathtt{C + + 11}$  or later. This means it's possible to shuffle non- integral types as long as they satisfy the below constraints:\n\nQualifies as trivially copyable i.e. is_trivially_copyable<T>::value == true  sizeof(T) <= 32"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - Consider a situation whereby t...",
    "content": "# Example:\n// Consider a situation whereby there is a branch in the. // code in which only the 2nd, 4th and 8th threads in each warp are // active. The coalesced_threads() call, placed in that branch, will create (for each // warp) a group, active, that has three threads (with // ranks 0- 2 inclusive). - - global- void kernel(int \\*globalInput) { // Lets say globalInput says that threads 2, 4, 8 should handle the data if (threadIdx.x  $= =$  \\*globalInput) { coalesced_group active  $=$  coalesced_threads(); // active contains 0- 2 inclusive active.sync(); } }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.4.2.2.1 Discovery Pattern - Commonly developers need to wo...",
    "content": "Commonly developers need to work with the current active set of threads. No assumption is made about the threads that are present, and instead developers work with the threads that happen to be there. This is seen in the following \"aggregating atomic increment across threads in a warp\" example (written using the correct CUDA 9.0 set of intrinsics):"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.4.2.2.1 Discovery Pattern - unsigned int writemask    acti......cgcoalescedgroup g    cgcoales...",
    "content": "{ unsigned int writemask  $=$  _activemask(); unsigned int total  $=$  _popc(writemask); unsigned int prefix  $=$  _popc(writemask& _lanemask_lt()); // Find the lowest- numbered active lane int elected_lane  $=$  _ffs(writemask)- 1; int base_offset  $= \\theta$  . if (prefix  $= \\theta$  ){ base_offset  $=$  atomicAdd(p, total); } base_offset  $=$  _shfl_sync(writemask, base_offset, elected_lane); int thread_offset  $=$  prefix  $^+$  base_offset; return thread_offset; }\n\nThis can be re- written with Cooperative Groups as follows:\n\n{ cg::coalesced_group g  $=$  cg::coalesced_threads(); int prev; if (g.thread_rank  $() = =\\theta$  ){ prev  $=$  atomicAdd(p, g.num_threads()); } prev  $=$  g.thread_rank()  $^+$  g.shfl(prev, 0); return prev; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.5. Group Partitioning",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.5.1. tiled_partition - template unsigned int Size typ......The tiledpartition method is a...",
    "content": "template <unsigned int Size, typename ParentThread_block_tiled_Size, ParentT> tiled_partition(const ParentT& g);\n\nthread_group tiled_partition(const thread_group& parent, unsigned int tilesz);\n\nThe tiled_partition method is a collective operation that partitions the parent group into a onedimensional, row- major, tiling of subgroups. A total of (size(parent)/tilesz) subgroups will be created, therefore the parent group size must be evenly divisible by the Size. The allowed parent groups are thread_block or thread_block_tile."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.5.1. tiled_partition - The implementation may cause t......Codegen Requirements Compute C...",
    "content": "The implementation may cause the calling thread to wait until all the members of the parent group have invoked the operation before resuming execution. Functionality is limited to native hardware sizes, 1/2/4/8/16/32 and the cg::size(parent) must be greater than the Size parameter. The templated\n\nversion of tiled_partition supports 64/128/256/512 sizes as well, but some additional steps are required on Compute Capability 7.5 or lower, refer to Thread Block Tile for details.\n\nCodegen Requirements: Compute Capability 5.0 minimum,  $\\mathtt{C + + 11}$  for sizes larger than 32"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - The following code will create......then the statement would be pr...",
    "content": "# Example:\n/// The following code will create a 32- thread tile thread_block block = this_thread_block(); thread_block_tile<32> tile32 = tiled_partition<32>(block);\n\nWe can partition each of these groups into even smaller groups, each of size 4 threads:\n\nauto tile4 = tiled_partition<4>(tile32); // or using a general group // thread_group tile4 = tiled_partition(tile32, 4);\n\nIf, for instance, if we were to then include the following line of code:\n\nif (tile4. thread_rank() == 0) printf(\"Hello from tile4 rank 0\\n\");\n\nthen the statement would be printed by every fourth thread in the block: the threads of rank 0 in each tile4 group, which correspond to those threads with ranks 0,4,8,12,etc. in the block group."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.5.2. labeled_partition - template typename Label coales......Note This functionality is sti...",
    "content": "template <typename Label> coalesced_group labeled_partition(const coalesced_group& g, Label label);\n\ntemplate <unsigned int Size, typename Label> coalesced_group labeled_partition(const thread_block_tile<Size>& g, Label label);\n\nThe labeled_partition method is a collective operation that partitions the parent group into one- dimensional subgroups within which the threads are coalesced. The implementation will evaluate a condition label and assign threads that have the same value for label into the same group.\n\nLabel can be any integral type.\n\nThe implementation may cause the calling thread to wait until all the members of the parent group have invoked the operation before resuming execution.\n\nNote: This functionality is still being evaluated and may slightly change in the future."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.5.2. labeled_partition - Codegen Requirements Compute C...",
    "content": "Codegen Requirements: Compute Capability 7.0 minimum,  $\\mathtt{C + + 11}$"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.5.3. binary_partition - coalescedgroup binarypartition......Note This functionality is sti...",
    "content": "coalesced_group binary_partition(const coalesced_group& g, bool pred);\n\ntemplate <unsigned int Size> coalesced_group binary_partition(const thread_block_tile<Size>& g, bool pred);\n\nThe binary_partition() method is a collective operation that partitions the parent group into one- dimensional subgroups within which the threads are coalesced. The implementation will evaluate a predicate and assign threads that have the same value into the same group. This is a specialized form of labeled_partition(), where the label can only be 0 or 1.\n\nThe implementation may cause the calling thread to wait until all the members of the parent group have invoked the operation before resuming execution.\n\nNote: This functionality is still being evaluated and may slightly change in the future."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.5.3. binary_partition - Codegen Requirements Compute C...",
    "content": "Codegen Requirements: Compute Capability 7.0 minimum, C++11"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6. Group Collectives - This example divides a 32 size...",
    "content": "/// This example divides a 32- sized tile into a group with odd/// numbers and a group with even numbers.global__ void oddEven(int *inputArr) {    auto block = cg::this_thread_block();    auto tile32 = cg::tiled_partition<32>(block);    // inputArr contains random integers    int elem = inputArr[block.thread_rank()];    // after this, tile32 is split into 2 groups,    // a subtle where elem&1 is true and one where its false    auto subtle = cg::binary_partition(tile32, (elem & 1));}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6. Group Collectives - Cooperative Groups library pro...",
    "content": "# 11.6. Group Collectives\nCooperative Groups library provides a set of collective operations that can be performed by a group of threads. These operations require participation of all threads in the specified group in order to complete the operation. All threads in the group need to pass the same values for corresponding arguments to each collective call, unless different values are explicitly allowed in the argument description. Otherwise the behavior of the call is undefined.\n\n# 11.6.1. Synchronization"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.2. Data Transfer - cooperativegroupssyncT group...sync synchronizes the threads ...",
    "content": "cooperative_groups::sync(T& group);\n\nsync synchronizes the threads named in the group. T can be any of the existing group types, as all of them support synchronization. If the group is a grid_group or a multi_grid_group the kernel must have been launched using the appropriate cooperative launch APIs.\n\n# 11.6.2. Data Transfer\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.2.1 memcpy_async - 11621 memcpyasyncmemcpyasync i...",
    "content": "11.6.2.1 memcpy_asyncmemcpy_async is a group- wide collective memcpy that utilizes hardware accelerated support for non- blocking memory transactions from global to shared memory. Given a set of threads named in the group, memcpy_async will move specified amount of bytes or elements of the input type through a single pipeline stage. Additionally for achieving best performance when using the memcpy_async API, an alignment of 16 bytes for both shared memory and global memory is required. It is important to note that while this is a memcpy in the general case, it is only asynchronous if the source is global memory and the destination is shared memory and both can be addressed with 16, 8, or 4 byte alignments."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.2.1 memcpy_async - Asynchronously copied data sho...",
    "content": " Asynchronously copied data should only be read following a call to wait or wait_prior which signals that the corresponding stage has completed moving data to shared memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.2.1 memcpy_async - Having to wait on all outstand...",
    "content": "Having to wait on all outstanding requests can lose some flexibility (but gain simplicity). In order to efficiently overlap data transfer and execution, its important to be able to kick off an N+1 memcpy_async request while waiting on and operating on request N. To do so, use memcpy_async and wait on it using the collective stage- based wait_prior API. See wait and wait_prior for more details."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Usage 1 - template typename TyGroup type......Performs a copy of mindstLayou...",
    "content": "template <typename TyGroup, typename TyElem, typename TyShape> void memcpy_async( const TyGroup &group, TyElem \\*__restrict__ _dst, const TyElem \\*__restrict__ _src, const TyShape &shape );\n\nPerforms a copy of shape' bytes.\n\nUsage 2\n\ntemplate <typename TyGroup, typename TyElem, typename TyDstLayout, typename TySrcLayout> void memcpy_async( const TyGroup &group, TyElem \\*__restrict__ dst, const TyDstLayout &dstLayout, const TyElem \\*__restrict__ src, const TySrcLayout &srcLayout );\n\nPerforms a copy of `min(dstLayout, srcLayout)` elements. If layouts are of type cuda::aligned_size_t<N>, both must specify the same alignment."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Usage 1 - Errata The memcpyasync API int......Codegen Requirements Compute C...",
    "content": "Errata The memcpy_async API introduced in CUDA 11.1 with both src and dst input layouts, expects the layout to be provided in elements rather than bytes. The element type is inferred from TyElem and has the size sizeof(TyElem). If cuda::aligned_size_t<N> type is used as the layout, the number of elements specified times sizeof(TyElem) must be a multiple of N and it is recommended to use std::byte or char as the element type.\n\nIf specified shape or layout of the copy is of type cuda::aligned_size_t<N>, alignment will be guaranteed to be at least min(16, N). In that case both dst and src pointers need to be aligned to N bytes and the number of bytes copied needs to be a multiple of N.\n\nCodegen Requirements: Compute Capability 5.0 minimum, Compute Capability 8.0 for asynchronicity, C++11"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Usage 1 - cooperativegroupsmemcpyasynch ...",
    "content": "cooperative_groups/memcpy_async.h header needs to be included."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - This example streams elementsP...",
    "content": "/// This example streams elementsPerThreadBlock worth of data from global memory /// into a limited sized shared memory (elementsInShared) block to operate on. #include <cooperative_groups.h> #include <cooperative_groups/memcpy_async.h> namespace cg  $=$  cooperative_groups; global_.."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - void kernelint globaldata cgth...",
    "content": " void kernel(int\\* global_data){ cg::thread_block tb  $=$  cg::this_thread_block(); const size_t elementsPerThreadBlock  $=$  16 \\* 1024; const size_t elementsInShared  $=$  128; _shared_- int local_smem[elementsInShared]; size_t copy_count; size_t index  $=$  0; while (index  $\\<$  elementsPerThreadBlock) { cg::memcpy_async(tb, local_smem, elementsInShared, global_data  $^+$  index, _elementsPerThreadBlock - index); copy_count  $=$  min(elementsInShared, elementsPerThreadBlock - index); cg::wait(tb); // Work with local_smem index  $+ =$  copy_count; } }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.2.2 wait and wait_prior - template typename TyGroup void......cooperativegroupsmemcpyasynch ...",
    "content": "# 11.6.2.2 wait and wait_prior\ntemplate <typename TyGroup> void wait(TyGroup & group);\n\ntemplate <unsigned int NumStages, typename TyGroup> void wair_prior(TyGroup & group);\n\nwait and wait_prior collectives allow to wait for memcpy_async copies to complete. wait blocks calling threads until all previous copies are done. wait_prior allows that the latest NumStages are still not done and waits for all the previous requests. So with N total copies requested, it waits until the first N- NumStages are done and the last NumStages might still be in progress. Both wait and wait_prior will synchronize the named group.\n\nCodegen Requirements: Compute Capability 5.0 minimum, Compute Capability 8.0 for asynchronicity, C++11\n\ncooperative_groups/memcpy_async.h header needs to be included."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - This example streams elementsP......namespace cg  cooperativegroup...",
    "content": "/// This example streams elementsPerThreadBlock worth of data from global memory /// into a limited sized shared memory (elementsInShared) block to operate on in /// multiple (two) stages. As stage N is kicked off, we can wait on and operate on  $\\rightarrow$  stage N- 1. #include <cooperative_groups.h> #include <cooperative_groups/memcpy_async.h>\n\nnamespace cg = cooperative_groups;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - cg  cooperativegroupsglobal vo...",
    "content": "```cg = cooperative_groups;__global__ void kernel(int* global_data) {    cg::thread_block tb = cg::this_thread_block();    const size_t elementsPerThreadBlock = 16 * 1024 + 64;    const size_t elementsInShared = 128;    __align__((6) __shared__ int local_smem[2][elementsInShared];    int stage = 0;    // First kick off an extra request    size_t copy_count = elementsInShared;    size_t index = copy_count;    cg::memcpy_async(tb, local_smem[stage], elementsInShared, global_data, elementsPerThreadBlock - index);    while (index < elementsPerThreadBlock) {        // Now we kick off the next request...        cg::memcpy_async(tb, local_smem[stage ^ 1], elementsInShared, global_data + _index, elementsPerThreadBlock - index);        // ..."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - but we wait on the one before ...",
    "content": " but we wait on the one before it        cg::wait_prior<1>(tb);        // Its now available and we can work with local_smem[stage] here        // (...)        // Calculate the amount fo data that was actually copied, for the next iteration.        copy_count = min(elementsInShared, elementsPerThreadBlock - index);        index += copy_count;        // A cg::sync(tb) might be needed here depending on whether        // the work done with local_smem[stage] can release threads to race ahead or not        // Wrap to the next stage        stage ^= 1;    }    cg::wait(tb);    // The last local_smem[stage] can be handled here}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.3. Data Manipulation",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.3.1 reduce - cp11631 reducetemplate typenam......group Valid group types are co...",
    "content": "```cp11.6.3.1 reduce```template <typename TyGroup, typename TyArg, typename TyOp>auto reduce(const TyGroup& group, TyArg&& val, TyOp&& op) - > decltype(op(val, val));\n\nreduce performs a reduction operation on the data provided by each thread named in the group passed in. This takes advantage of hardware acceleration (on compute 80 and higher devices) for the arithmetic add, min, or max operations and the logical AND, OR, or XOR, as well as providing a software fallback on older generation hardware. Only 4B types are accelerated by hardware.\n\ngroup: Valid group types are coalesced_group and thread_block_tile. val: Any type that satisfies the below requirements:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.3.1 reduce - Qualifies as trivially copyabl......Asynchronous reduce",
    "content": "Qualifies as trivially copyable i.e. is_trivially_copyable<TyArg>::value  $= =$  true sizeof(T)  $< = 32$  for coalesced_group and tiles of size lower or equal 32, sizeof(T)  $< = 8$  for larger tiles Has suitable arithmetic or comparative operators for the given function object.\n\nNote: Different threads in the group can pass different values for this argument.\n\nop: Valid function objects that will provide hardware acceleration with integral types are plus(), less(), greater(), bit_and(), bit_xor(), bit_or(). These must be constructed, hence the TyVal template argument is required, i.e. plus<int>(). Reduce also supports lambdas and other function objects that can be invoked using operator()\n\nAsynchronous reduce"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.3.1 reduce - template typename TyGroup type...",
    "content": "template <typename TyGroup, typename TyArg, typename TyAtomic, typename TyOp> void reduce_update_async(const TyGroup& group, TyAtomic& atomic, TyArg&& val, TyOp&&  $\\leftrightarrow$  op);\n\ntemplate <typename TyGroup, typename TyArg, typename TyAtomic, typename TyOp> void reduce_store_async(const TyGroup& group, TyAtomic& atomic, TyArg&& val, TyOp&&  $\\leftrightarrow$  op);\n\ntemplate <typename TyGroup, typename TyArg, typename TyOp> void reduce_store_async(const TyGroup& group, TyArg\\* ptr, TyArg&& val, TyOp&& op);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.3.1 reduce - async variants of the API are ...",
    "content": "\\* async variants of the API are asynchronously calculating the result to either store to or update a specified destination by one of the participating threads, instead of returning it by each thread. To observe the effect of these asynchronous calls, calling group of threads or a larger group containing them need to be synchronized."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.3.1 reduce - In case of the atomic store or...",
    "content": "In case of the atomic store or update variant, atomic argument can be either of cuda::atomic or cuda::atomic_ref available in CUDA C++ Standard Library. This variant of the API is available only on platforms and devices, where these types are supported by the CUDA C++ Standard Library. Result of the reduction is used to atomically update the atomic according to the specified op, eg. the result is atomically added to the atomic in case of cg::plus(). Type held by the atomic must match the type of TyArg. Scope of the atomic must include all the threads in the group and if multiple groups are using the same atomic concurrently, scope must include all threads in all groups using it. Atomic update is performed with relaxed memory ordering."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.3.1 reduce - In case of the pointer store v......continues on next page",
    "content": "In case of the pointer store variant, result of the reduction will be weakly stored into the dst pointer.\n\nCodegen Requirements: Compute Capability 5.0 minimum, Compute Capability 8.0 for HW acceleration,  $\\mathbb{C} + + 11$\n\ncooperative_groups/reduce.h header needs to be included.\n\nExample of approximate standard deviation for integer vector:\n\ninclude <cooperative_groups.h> #include <cooperative_groups/reduce.h> namespace cg  $=$  cooperative_groups;\n\n// Calculate approximate standard deviation of integers in vec - - device- - int std_dev(const cg::thread_block_tile  $< 32 > \\&$  tile, int \\*vec, int length) { int thread_sum  $= 0$  . // calculate average first\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.3.1 reduce - for int i  tilethreadrank i  l...",
    "content": "for (int i = tile.thread_rank(); i < length; i += tile.num_threads()) {    thread_sum += vec[i];}// cg::plus<int> allows cg::reduce() to know it can use hardware acceleration for additionint avg = cg::reduce(tile, thread_sum, cg::plus<int>() / length;int thread_diffs_sum = 0;for (int i = tile.thread_rank(); i < length; i += tile.num_threads()) {    int diff = vec[i] - avg;    thread_diffs_sum += diff * diff;}// temporarily use floats to calculate the square rootfloat diff_sum = static_cast<float>(cg::reduce(tile, thread_diffs_sum, cg::plus<int>() / length;return static_cast<int>(sqrt(diff_sum));}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example of block wide reduction: - include cooperativegroupsh inc...",
    "content": "include <cooperative_groups.h> #include <cooperative_groups/reduce.h> namespace cg  $=$  cooperative_groups; // The following example accepts input in \\*A and outputs a result into \\*sum // It spreads the data equally within the block _device_- void_block_reduce(const int\\* A, int count, cuda::atomic<int, cuda::thread_ scope_block  $>8$  total_sum) { auto block  $=$  cg::this_thread_block(); auto tile  $=$  cg::tiled_partition  $< 32>$  (block); int thread_sum  $= 0$  // Stride loop over all values, each thread accumulates its part of the array. for (int i  $=$  block.thread_rank(); i  $<$  count; i  $+ =$  block."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example of block wide reduction: - size  threadsum     Ai   reduc...",
    "content": "size()) { thread_sum  $+ =$  A[i]; } // reduce thread sums across the tile, add the result to the atomic // cg::plus<int> allows cg::reduce() to know it can use hardware acceleration for addition cg::reduce_update_async(tile, total_sum, thread_sum, cg::plus<int>()); // synchronize the block, to ensure all async reductions are ready block.sync(); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.3.2 Reduce Operators - Below are the prototypes of fu...",
    "content": "Below are the prototypes of function objects for some of the basic operations that can be done with reduce namespace cooperative_groups {template <typename Ty>struct cg::plus;template <typename Ty>struct cg::less;template <typename Ty>struct cg::greater;template <typename Ty>struct cg::bit_and;template <typename Ty>struct cg::bit_xor;template <typename Ty>struct cg::bit_or;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.3.2 Reduce Operators - Reduce is limited to the infor...",
    "content": "Reduce is limited to the information available to the implementation at compile time. Thus in order to make use of intrinsics introduced in CC 8.0, the cg: : namespace exposes several functional objects that mirror the hardware. These objects appear similar to those presented in the  $\\mathtt{C + + }$  STL, with the exception of less/greater. The reason for any difference from the STL is that these function objects are designed to actually mirror the operation of the hardware intrinsics."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Functional description: - cgplus Accepts two values and ...",
    "content": "# Functional description:\n- cg::plus: Accepts two values and returns the sum of both using operator+.- cg::less: Accepts two values and returns the lesser using operator<. This differs in that the lower value is returned rather than a Boolean.- cg::greater: Accepts two values and returns the greater using operator<. This differs in that the greater value is returned rather than a Boolean.- cg::bit_and: Accepts two values and returns the result of operator&.- cg::bit_xor: Accepts two values and returns the result of operator^.- cg::bit_or: Accepts two values and returns the result of operator|."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - cgplusint is specialized withi......continues on next page",
    "content": "{    // cg::plus<int> is specialized within cg::reduce and calls __reduce_add_sync(...)}on CC 8.0+    cg::reduce(tile, (int)val, cg::plus<int>());    // cg::plus<float> fails to match with an accelerator and instead performs a standard shuffle based reduction    cg::reduce(tile, (float)val, cg::plus<float>());    // While individual components of a vector are supported, reduce will not use hardware intrinsics for the following\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - It will also be necessary to d...",
    "content": "// It will also be necessary to define a corresponding operator for vector and any  $\\rightarrow$  custom types that may be used int4 vec  $=$  {...}; cg::reduce(tile, vec, cg::plus<int4>(); // Finally lambdas and other function objects cannot be inspected for dispatch // and will instead perform shuffle based reductions using the provided function  $\\rightarrow$  object. cg::reduce(tile, (int)val, [](int l, int r) - > int {return l + r;}); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.3.3 inclusive_scan and exclusive_scan - template typename TyGroup type...",
    "content": "template <typename TyGroup, typename TyVal, typename TyFn> auto inclusive_scan(const TyGroup& group, TyVal&& val, TyFn&& op) - > decltype(op(val, val)); template <typename TyGroup, typename TyVal> TyVal inclusive_scan(const TyGroup& group, TyVal&& val); template <typename TyGroup, typename TyVal, typename TyFn> auto exclusive_scan(const TyGroup& group, TyVal&& val, TyFn&& op) - > decltype(op(val, val)); template <typename TyGroup, typename TyVal> TyVal exclusive_scan(const TyGroup& group, TyVal&& val);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.3.3 inclusive_scan and exclusive_scan - inclusivescan and exclusivesca......Qualifies as trivially copyabl...",
    "content": "inclusive_scan and exclusive_scan performs a scan operation on the data provided by each thread named in the group passed in. Result for each thread is a reduction of data from threads with lower thread_rank than that thread in case of exclusive_scan. inclusive_scan result also includes the calling thread data in the reduction.\n\ngroup: Valid group types are coalesced_group and thread_block_tile.\n\nval: Any type that satisfies the below requirements:\n\n- Qualifies as trivially copyable i.e. is_trivially_copyable<TyArg>::value == true- sizeof(T) <= 32 for coalesced_group and tiles of size lower or equal 32, sizeof(T) <= 8 for larger tiles- Has suitable arithmetic or comparative operators for the given function object."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.3.3 inclusive_scan and exclusive_scan - op Function objects defined fo...",
    "content": "Note: Different threads in the group can pass different values for this argument.\n\nop: Function objects defined for convenience are plus(), less(), greater(), bit_and(), bit_xor(), bit_or() described in Reduce Operators. These must be constructed, hence the TyVal template argument is required, i.e. plus<int>(). inclusive_scan and exclusive_scan also supports lambdas and other function objects that can be invoked using operator(). Overloads without this argument use cg::plus<TyVal>()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Scan update - template typename TyGroup type...",
    "content": "template <typename TyGroup, typename TyAtomic, typename TyVal, typename TyFn> auto inclusive_scan_update(const TyGroup& group, TyAtomic& atomic, TyVal&& val, TyFn&& op) - > decltype(op(val, val));\n\n(continues on next page)\n\n(continued from previous page)\n\ntemplate <typename TyGroup, typename TyAtomic, typename TyVal> TyVal inclusive_scan_update(const TyGroup& group, TyAtomic& atomic, TyVal&& val); template <typename TyGroup, typename TyAtomic, typename TyVal, typename TyFn> auto exclusive_scan_update(const TyGroup& group, TyAtomic& atomic, TyVal&& val, TyFn&&  $\\leftrightarrow$  op) - > decltypop(op(val, val)); template <typename TyGroup, typename TyAtomic, typename TyVal> TyVal exclusive_scan_update(const TyGroup& group, TyAtomic& atomic, TyVal&& val);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Scan update - scanupdate collectives take an...",
    "content": "\\* scan_update collectives take an additional argument atomic that can be either of cuda: :atomic or cuda: :atomic_ref available in CUDA  $\\mathtt{C + + }$  Standard Library. These variants of the API are available only on platforms and devices, where these types are supported by the CUDA  $\\mathtt{C + + }$  Standard Library. These variants will perform an update to the atomic according to op with value of the sum of input values of all threads in the group. Previous value of the atomic will be combined with the result of scan by each thread and returned. Type held by the atomic must match the type of TyVal. Scope of the atomic must include all the threads in the group and if multiple groups are using the same atomic concurrently, scope must include all threads in all groups using it."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Scan update - Atomic update is performed wit...",
    "content": " Atomic update is performed with relaxed memory ordering."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Scan update - Following pseudocode illustrat......cooperativegroupsscanh header ...",
    "content": "Following pseudocode illustrates how the update variant of scan works:\n\n/\\* inclusive_scan_update behaves as the following block, except both reduce and inclusive_scan is calculated simultaneously. auto total  $=$  reduce(group, val, op); TyVal old; if (group.thread.rank()  $= =$  selected_thread) { atomicaly { old  $=$  atomic.load(); atomic.store(op(old, total)); } } old  $=$  group.shfl(old, selected_thread); return op(inclusive_scan(group, val, op), old); \\*/\n\nCodegen Requirements: Compute Capability 5.0 minimum,  $\\mathtt{C + + 11}$\n\ncooperative_groups/scan.h header needs to be included."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - cinclude stdiohinclude coopera......tabletrtd1 1tdtrtrtd2 3tdtrtrt...",
    "content": "# Example:\n```c#include <stdio.h>#include <cooperative_groups.h>#include <cooperative_groups/scan.h>namespace cg = cooperative_groups;__global__ void kernel() {    auto thread_block = cg::this_thread_block();    auto tile = cg::tiled_partition<8>(thread_block);    unsigned int val = cg::inclusive_scan(tile, tile.thread_rank());    printf(\"%u: %u\\n\", tile.thread_rank(), val);}//* prints for each group:    0: 0```\n\n(continues on next page)\n\n<table><tr><td>1: 1</td></tr><tr><td>2: 3</td></tr><tr><td>3: 6</td></tr><tr><td>4: 10</td></tr><tr><td>5: 15</td></tr><tr><td>6: 21</td></tr><tr><td>7: 28</td></tr><tr><td>*/</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example of stream compaction using exclusive_scan: - include cooperativegroupsh inc...",
    "content": "include <cooperative_groups.h> #include <cooperative_groups/scan.h> namespace cg  $=$  cooperative_groups; // put data from input into output only if it passes test_fn predicate template<typename Group, typename Data, typename TyFn> - - device- - int stream_compaction(Group &g, Data \\*input, int count, TyFn&& test_fn, - - Data \\*output) { int per_thread  $=$  count / g.num_threads(); int thread_start  $=$  min(g.thread_rank() \\* per_thread, count); int my_count  $=$  min(per_thread, count - thread_start); // get all passing items from my part of the input // into a contiguous part of the array and count them."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example of stream compaction using exclusive_scan: - int  texttti   threadstart whi...",
    "content": " int  $\\texttt{i} =$  thread_start; while (i  $<$  my_count  $^+$  thread_start) { if (test_fn(input[i])) {  $\\dot{\\mathbf{1}} ++$  } else { my_count- - ; input[i]  $=$  input[my_count  $^+$  thread_start]; } } // scan over counts from each thread to calculate my starting // index in the output int my_idx  $=$  cg::exclusive_scan(g, my_count); for  $\\texttt{i} = \\texttt{0}$  ;  $\\texttt{i} <$  my_count;  $^{+ + }\\dot{\\mathbf{1}}$  ){ output[my_idx  $^+$  i]  $=$  input[thread_start  $^+$  i]; } // return the total number of items in the output return g.shfl(my_idx  $^+$  my_count, g.num_threads() - 1); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example of dynamic buffer space allocation using exclusive_scan_update: - cppinclude cooperativegroupshi......cpp Buffer partitioning is sta...",
    "content": "```cpp#include <cooperative_groups.h>#include <cooperative_groups/scan.h>namespace cg = cooperative_groups;```\n\n```cpp// Buffer partitioning is static to make the example easier to follow, // but any arbitrary dynamic allocation scheme can be implemented by replacing this function.__device__ int calculate_buffer_space_needed(cg::thread_block_tile<32>& tile) {    (continues on next page)}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example of dynamic buffer space allocation using exclusive_scan_update: - return tilethreadrank  2  1  d...",
    "content": "return tile.thread_rank() % 2 + 1; } _device__ int my_thread_data(int i) { return i; } _global__ void kernel() { _shared__ extern int buffer[]; _shared__ cuda::atomic<int, cuda::thread_scope_block> buffer_used; auto block = cg::this_thread_block(); auto tile = cg::tiled_partition<32>(block); buffer_used = 0; block.sync(); // each thread calculates buffer size it needs int buf_needed = calculate_buffer_space_needed(tile); // scan over the needs of each thread, result for each thread is an offset // of that thread's part of the buffer."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example of dynamic buffer space allocation using exclusive_scan_update: - bufferused is atomically updat...",
    "content": " buffer_used is atomically updated with // the sum of all thread's inputs, to correctly offset other tile's allocations int buf_offset = cg::exclusive_scan_update(tile, buffer_used, buf_needed); // each thread fills its own part of the buffer with thread specific data for (int i = 0; i < buf_needed; ++i) { buffer[buf_offset + i] = my_thread_data(i); } block.sync(); // buffer_used now holds total amount of memory allocated // buffer is {0, 0, 1, 0, 0, 1 ...}; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.4. Execution control",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.4.1 invoke_one and invoke_one_broadcast - templatetypename Group typenam......invokeone selects a single arb...",
    "content": "template<typename Group, typename Fn, typename...Args> void invoke_one(const Group& group, Fn&& fn, Args&&... args); template<typename Group, typename Fn, typename...Args> auto invoke_one_broadcast(const Group& group, Fn&& fn, Args&&... args) - > _declspec(fn(args...));\n\ninvoke_one selects a single arbitrary thread from the calling group and uses that thread to call the supplied invocable fn with the supplied arguments args. In case of invoke_one_broadcast the result of the call is also distributed to all threads in the group and returned from this collective."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.4.1 invoke_one and invoke_one_broadcast - Calling group can be synchroni......fn Function or object that can...",
    "content": "Calling group can be synchronized with the selected thread before and/or after it calls the supplied invocable. It means that communication within the calling group is not allowed inside the supplied invocable body, otherwise forward progress is not guaranteed. Communication with threads outside\n\nof the calling group is allowed in the body of the supplied invocable. Thread selection mechanism is not guaranteed to be deterministic.\n\nOn devices with Compute Capability 9.0 or higher hardware acceleration might be used to select the thread when called with explicit group types.\n\ngroup: All group types are valid for invoke_one, coalesced_group and thread_block_tile are valid for invoke_one_broadcast.\n\nfn: Function or object that can be invoked using operator()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.4.1 invoke_one and invoke_one_broadcast - args Parameter pack of types m......Aggregated atomic example from...",
    "content": "args: Parameter pack of types matching types of parameters of the supplied invocable fn.\n\nIn case of invoke_one_broadcast the return type of the supplied invocable fn must satisfy the below requirements:\n\n- Qualifies as trivially copyable i.e. is_trivially_copyable<T>::value == true- sizeof(T) <= 32 for coalesced_group and tiles of size lower or equal 32, sizeof(T) <= 8 for larger tiles\n\nCodegen Requirements: Compute Capability 5.0 minimum, Compute Capability 9.0 for hardware acceleration, C++11.\n\nAggregated atomic example from Discovery pattern section re- written to use invoke_one_broadcast:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.6.4.1 invoke_one and invoke_one_broadcast - cppinclude cooperativegroupshi...",
    "content": "```cpp#include <cooperative_groups.h>#include <cuda/atomic>namespace cg = cooperative_groups;template <cuda::thread_scope Scope>  - _device__ unsigned int atomicAddOneRelaxed(cuda::atomic<unsigned int, Scope>& atomic) {    auto g = cg::coalesced_threads();    auto prev = cg::invoke_one_broadcast(g, [&] () {        return atomic.fetch_add(g.num_threads(), cuda::memory_order_relaxed);    });    return prev + g.thread_rank();}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.7. Grid Synchronization - Prior to the introduction of C...",
    "content": "Prior to the introduction of Cooperative Groups, the CUDA programming model only allowed synchronization between thread blocks at a kernel completion boundary. The kernel boundary carries with it an implicit invalidation of state, and with it, potential performance implications."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.7. Grid Synchronization - For example in certain use cas......gridgroup grid  thisgrid grids...",
    "content": "For example, in certain use cases, applications have a large number of small kernels, with each kernel representing a stage in a processing pipeline. The presence of these kernels is required by the current CUDA programming model to ensure that the thread blocks operating on one pipeline stage have produced data before the thread block operating on the next pipeline stage is ready to consume it. In such cases, the ability to provide global inter thread block synchronization would allow the application to be restructured to have persistent thread blocks, which are able to synchronize on the device when a given stage is complete.\n\nTo synchronize across the grid, from within a kernel, you would simply use the grid.sync() function:\n\ngrid_group grid = this_grid(); grid.sync();"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.7. Grid Synchronization - gridgroupgrid  thisgridgridsyn...",
    "content": "grid_group_grid = this_grid();grid.sync();And when launching the kernel it is necessary to use, instead of the <<<...>>> execution configuration syntax, the cudaLaunchCooperativeKernel CUDA runtime launch API or the CUDA driver equivalent."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - ExampleTo guarantee co residen......Alternatively you can maximize...",
    "content": "Example:To guarantee co- residency of the thread blocks on the GPU, the number of blocks launched needs to be carefully considered. For example, as many blocks as there are SMs can be launched as follows:\n\nint device  $= 0$  cudaDeviceProp deviceProp; cudaGetDeviceProperties(&deviceProp, dev); // initialize, then launch cudaLaunchCooperativeKernel((void\\*)my_kernel, deviceProp.multiProcessorCount,  $\\hookrightarrow$  numThreads, args);\n\nAlternatively, you can maximize the exposed parallelism by calculating how many blocks can fit simultaneously per- SM using the occupancy calculator as follows:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - This will launch a grid that c......It is good practice to first e...",
    "content": "/// This will launch a grid that can maximally fill the GPU, on the default stream with  $\\hookrightarrow$  kernel arguments int numBlocksPerSm  $= 0$  // Number of threads my_kernel will be launched with int numThreads  $= 128$  cudaDeviceProp deviceProp; cudaGetDeviceProperties(&deviceProp, dev); cudaOcupancyMaxActiveBlocksPerMultiProcessor(&numBlocksPerSm, my_kernel, numThreads,  $\\hookrightarrow 0$  ); // launch void \\*kernelArgs[]  $=$  { /\\* add kernel args \\*/ }; dim3 dimBlock(numThreads, 1, 1); dim3 dimGrid(deviceProp.multiProcessorCount\\*numBlocksPerSm, 1, 1); cudaLaunchCooperativeKernel((void\\*)my_kernel, dimGrid, dimBlock, kernelArgs);\n\nIt is good practice to first ensure the device supports cooperative launches by querying the device attribute cudaDevAttrCooperativeLaunch:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - int dev   0  int supportsCoopL......The Linux platform without MPS...",
    "content": "int dev  $= 0$  int supportsCoopLaunch  $= 0$  cudaDeviceGetAttribute(&supportsCoopLaunch, cudaDevAttrCooperativeLaunch, dev);\n\nwhich will set supportsCoopLaunch to 1 if the property is supported on device O. Only devices with compute capability of 6.0 and higher are supported. In addition, you need to be running on either of these:\n\nThe Linux platform without MPS The Linux platform with MPS and on a device with compute capability 7.0 or higher The latest Windows platform"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.8. Multi-Device Synchronization - In order to enable synchroniza...",
    "content": "In order to enable synchronization across multiple devices with Cooperative Groups, use of the cud- aLaunchCooperativeKernelMultiDevice CUDA API is required. This, a significant departure from existing CUDA APIs, willallow a single host thread to launch a kernel across multiple devices. In addition to the constraints and guarantees made by cudaLaunchCooperativeKernel, this API has additional semantics:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.8. Multi-Device Synchronization - This API will ensure that a la...",
    "content": "This API will ensure that a launch is atomic, i.e. if the API call succeeds, then the provided number of thread blocks will launch on all specified devices. The functions launched via this API must be identical. No explicit checks are done by the driver in this regard because it is largely not feasible. It is up to the application to ensure this. No two entries in the provided cudaLaunchParams may map to the same device. All devices being targeted by this launch must be of the same compute capability - major and minor versions. The block size, grid size and amount of shared memory per grid must be the same across all devices. Note that this means the maximum number of blocks that can be launched per device will be limited by the device with the least number of SMs."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.8. Multi-Device Synchronization - Any user defined device consta...",
    "content": " Any user defined __device__, __constant__ or __managed__ device global variables present in the module that owns the CUfunction being launched are independently instantiated on every device. The user is responsible for initializing such device global variables appropriately."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "11.8. Multi-Device Synchronization - Deprecation Notice cudaLaunchC......The launch parameters should b...",
    "content": "Deprecation Notice: cudaLaunchCooperativeKernelMultiDevice has been deprecated in CUDA 11.3 for all devices. Example of an alternative approach can be found in the multi device conjugate gradient sample.\n\nOptimal performance in multi- device synchronization is achieved by enabling peer access via cuCtx- EnablePeerAccess or cudaDeviceEnablePeerAccess for all participating devices.\n\nThe launch parameters should be defined using an array of structs (one per device), and launched with cudaLaunchCooperativeKernelMultiDevice"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - cudaDeviceProp deviceProp cuda...",
    "content": "cudaDeviceProp (deviceProp; cudaGetDeviceCount(&numGpus); // Per device launch parameters cudaLaunchParams \\*launchParams  $=$  (cudaLaunchParams\\*)malloc(sizeof(cudaLaunchParams) \\*  $\\leftrightarrow$  numGpus); cudaStream_t \\*streams  $=$  (cudaStream_t\\*)malloc(sizeof(cudaStream_t) \\* numGpus); // The kernel arguments are copied over during launch // its also possible to have individual copies of kernel arguments per device, but // the signature and name of the function/kernel must be the same."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - void kernelArgs      Add kerne...",
    "content": " void \\*kernelArgs[]  $=$  { /\\* Add kernel arguments \\*/ }; for (int  $\\texttt{i} = \\texttt{0}$  ;  $\\texttt{i} <$  numGpus;  $\\dot{1} ++$  ){ cudaSetDevice(i); // Per device stream, but its also possible to use the default NULL stream of each  $\\leftrightarrow$  device cudaStreamCreate(&streams[i]); // Loop over other devices and cudaDeviceEnablePeerAccess to get a faster barrier  $\\leftrightarrow$  implementation (continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - continued from previous page...Also as with grid wide synchro...",
    "content": "(continued from previous page)\n\n// Since all devices must be of the same compute capability and have the same launch configuration. // it is sufficient to query device 0 here cudaGetDeviceProperties(&deviceProp[i], 0); dim3 dimBlock(numThreads, 1, 1); dim3 dimGrid(deviceProp.multiProcessorCount, 1, 1); for (int i = 0; i < numGpus; i++) { launchParamsList[i].func = (void*)my_kernel; launchParamsList[i].gridDim = dimGrid; launchParamsList[i].blockDim = dimBlock; launchParamsList[i].sharedMem = 0; launchParamsList[i].stream = streams[i]; launchParamsList[i].args = kernelArgs; } cudaLaunchCooperativeKernelMultiDevice(launchParams, numGpus);\n\nAlso, as with grid- wide synchronization, the resulting device code looks very similar:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - multigridgroup multigrid  this......which will set supportsMdCoopL...",
    "content": "multi_grid_group multi_grid = this_multi_grid(); multi_grid.sync();\n\nHowever, the code needs to be compiled in separate compilation by passing - rdc=true to nvcc.\n\nIt is good practice to first ensure the device supports multi- device cooperative launches by querying the device attribute cudaDevAttrCooperativeMultiDeviceLaunch:\n\nint dev = 0; int supportsMdCoopLaunch = 0; cudaDeviceGetAttribute(&supportsMdCoopLaunch, cudaDevAttrCooperativeMultiDeviceLaunch, dev);\n\nwhich will set supportsMdCoopLaunch to 1 if the property is supported on device 0. Only devices with compute capability of 6.0 and higher are supported. In addition, you need to be running on the Linux platform (without MPS) or on current versions of Windows with the device in TCC mode."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - See the cudaLaunchCooperativeK...",
    "content": "See the cudaLaunchCooperativeKernelMultiDevice API documentation for more information."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.1. Introduction",
    "content": "\n\n# Chapter 12. CUDA Dynamic Parallelism\n\n\n# 12.1. Introduction\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.1.1. Overview - Dynamic Parallelism is an exte...",
    "content": "Dynamic Parallelism is an extension to the CUDA programming model enabling a CUDA kernel to create and synchronize with new work directly on the GPU. The creation of parallelism dynamically at whichever point in a program that it is needed offers exciting capabilities."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.1.1. Overview - The ability to create work dir...",
    "content": "The ability to create work directly from the GPU can reduce the need to transfer execution control and data between host and device, as launch configuration decisions can now be made at runtime by threads executing on the device. Additionally, data- dependent parallel work can be generated inline within a kernel at run- time, taking advantage of the GPU's hardware schedulers and load balancers dynamically and adapting in response to data- driven decisions or workloads. Algorithms and programming patterns that had previously required modifications to eliminate recursion, irregular loop structure, or other constructs that do not fit a flat, single- level of parallelism may more transparently be expressed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.1.1. Overview - This document describes the ex......Dynamic Parallelism is only su...",
    "content": "This document describes the extended capabilities of CUDA which enable Dynamic Parallelism, including the modifications and additions to the CUDA programming model necessary to take advantage of these, as well as guidelines and best practices for exploiting this added capacity.\n\nDynamic Parallelism is only supported by devices of compute capability 3.5 and higher."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.1.2. Glossary - Definitions for terms used in ......Host The Host refers to the ex...",
    "content": "Definitions for terms used in this guide.\n\nGrid A Grid is a collection of Threads. Threads in a Grid execute a Kernel Function and are divided into Thread Blocks.\n\nThread Block A Thread Block is a group of threads which execute on the same multiprocessor (SM). Threads within a Thread Block have access to shared memory and can be explicitly synchronized.\n\nKernel Function A Kernel Function is an implicitly parallel subroutine that executes under the CUDA execution and memory model for every Thread in a Grid.\n\nHost The Host refers to the execution environment that initially invoked CUDA. Typically the thread running on a system's CPU processor."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.1.2. Glossary - Parent A Parent Thread Thread ......Device Runtime The Device Runt...",
    "content": "Parent A Parent Thread, Thread Block, or Grid is one that has launched new grid(s), the Child Grid(s). The Parent is not considered completed until all of its launched Child Grids have also completed.\n\nChild A Child thread, block, or grid is one that has been launched by a Parent grid. A Child grid must complete before the Parent Thread, Thread Block, or Grid are considered complete.\n\nThread Block Scope Objects with Thread Block Scope have the lifetime of a single Thread Block. They only have defined behavior when operated on by Threads in the Thread Block that created the object and are destroyed when the Thread Block that created them is complete.\n\nDevice Runtime The Device Runtime refers to the runtime system and APIs available to enable Kernel Functions to use Dynamic Parallelism."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.1. Execution Environment - The CUDA execution model is ba...",
    "content": "# 12.2. Execution Environment and Memory Model\n\n\n# 12.2.1. Execution Environment\nThe CUDA execution model is based on primitives of threads, thread blocks, and grids, with kernel functions defining the program executed by individual threads within a thread block and grid. When a kernel function is invoked the grid's properties are described by an execution configuration, which has a special syntax in CUDA. Support for dynamic parallelism in CUDA extends the ability to configure, launch, and implicitly synchronize upon new grids to threads that are running on the device."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.1.1 Parent and Child Grids - A device thread that configure......The invocation and completion ...",
    "content": "A device thread that configures and launches a new grid belongs to the parent grid, and the grid created by the invocation is a child grid.\n\nThe invocation and completion of child grids is properly nested, meaning that the parent grid is not considered complete until all child grids created by its threads have completed, and the runtime guarantees an implicit synchronization between the parent and child."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.1.2 Scope of CUDA Primitives - On both host and device the CU......Fig 1 ParentChild Launch Nesti...",
    "content": "# 12.2.1.2 Scope of CUDA Primitives\nOn both host and device, the CUDA runtime offers an API for launching kernels and for tracking dependencies between launches via streams and events. On the host system, the state of launches and the CUDA primitives referencing streams and events are shared by all threads within a process; however processes execute independently and may not share CUDA objects.\n\nOn the device, launched kernels and CUDA objects are visible to all threads in a grid. This means, for example, that a stream may be created by one thread and used by any other thread in the grid.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/ed85098a9c554061b738d6a9123c05d46372c3d44375cbaab1e76d4000c22f0d.jpg)  \nFig. 1: Parent-Child Launch Nesting"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.1.3 Synchronization - Warning Explicit synchronizati...",
    "content": "Warning: Explicit synchronization with child kernels from a parent block (i.e. using cudaDeviceSynchronize() in device code) is deprecated in CUDA 11.6 and removed for compute_90+ compilation. For compute capability < 9.0, compile- time opt- in by specifying - DCUDA_FORCE_CDP1_IF_SUPPORTED is required to continue using cudaDeviceSynchronize() in device code. Note that this is slated for full removal in a future CUDA release."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.1.3 Synchronization - CUDA runtime operations from a...",
    "content": "CUDA runtime operations from any thread, including kernel launches, are visible across all the threads in a grid. This means that an invoking thread in the parent grid may perform synchronization to control the launch order of grids launched by any thread in the grid on streams created by any thread in the grid. Execution of a grid is not considered complete until all launches by all threads in the grid have completed. If all threads in a grid exit before all child launches have completed, an implicit synchronization operation will automatically be triggered."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.1.4 Streams and Events - CUDA Streams and Events allow ......Streams and events created wit...",
    "content": "CUDA Streams and Events allow control over dependencies between grid launches: grids launched into the same stream execute in- order, and events may be used to create dependencies between streams. Streams and events created on the device serve this exact same purpose.\n\nStreams and events created within a grid exist within grid scope, but have undefined behavior when used outside of the grid where they were created. As described above, all work launched by a grid is implicitly synchronized when the grid exits; work launched into streams is included in this, with all dependencies resolved appropriately. The behavior of operations on a stream that has been modified outside of grid scope is undefined."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.1.4 Streams and Events - Streams and events created on ...",
    "content": "Streams and events created on the host have undefined behavior when used within any kernel, just as streams and events created by a parent grid have undefined behavior if used within a child grid."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.1.5 Ordering and Concurrency - The ordering of kernel launche...",
    "content": "The ordering of kernel launches from the device runtime follows CUDA Stream ordering semantics. Within a grid, all kernel launches into the same stream (with the exception of the fire- and- forget stream discussed later) are executed in- order. With multiple threads in the same grid launching into the same stream, the ordering within the stream is dependent on the thread scheduling within the grid, which may be controlled with synchronization primitives such as __syncthready()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.1.5 Ordering and Concurrency - Note that while named streams ...",
    "content": "Note that while named streams are shared by all threads within a grid, the implicit NULL stream is only shared by all threads within a thread block. If multiple threads in a thread block launch into the implicit stream, then these launches will be executed in- order. If multiple threads in different thread blocks launch into the implicit stream, then these launches may be executed concurrently. If concurrency is desired for launches by multiple threads within a thread block, explicit named streams should be used."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.1.5 Ordering and Concurrency - Dynamic Parallelism enables co......The lack of concurrency guaran...",
    "content": "Dynamic Parallelism enables concurrency to be expressed more easily within a program; however, the device runtime introduces no new concurrency guarantees within the CUDA execution model. There is no guarantee of concurrent execution between any number of different thread blocks on a device.\n\nThe lack of concurrency guarantee extends to a parent grid and their child grids. When a parent grid launches a child grid, the child may start to execute once stream dependencies are satisfied and hardware resources are available to host the child, but is not guaranteed to begin execution until the parent grid reaches an implicit synchronization point."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.1.5 Ordering and Concurrency - While concurrency will often e...",
    "content": "While concurrency will often easily be achieved, it may vary as a function of device configuration, application workload, and runtime scheduling. It is therefore unsafe to depend upon any concurrency between different thread blocks."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.2.1 Coherence and Consistency - There is no multi GPU support ......Parent and child grids share t...",
    "content": "There is no multi- GPU support from the device runtime; the device runtime is only capable of operating on the device upon which it is currently executing. It is permitted, however, to query properties for any CUDA capable device in the system.\n\n# 12.2.2. Memory Model\nParent and child grids share the same global and constant memory storage, but have distinct local and shared memory.\n\n# 12.2.2.1 Coherence and Consistency\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.2.1.1 Global Memory - Parent and child grids have co......All global memory operations i...",
    "content": "Parent and child grids have coherent access to global memory, with weak consistency guarantees between child and parent. There is only one point of time in the execution of a child grid when its view of memory is fully consistent with the parent thread: at the point when the child grid is invoked by the parent.\n\nAll global memory operations in the parent thread prior to the child grid's invocation are visible to the child grid. With the removal of cudaDeviceSynchronize(), it is no longer possible to access the modifications made by the threads in the child grid from the parent grid. The only way to access the modifications made by the threads in the child grid before the parent grid exits is via a kernel launched into the cudaStreamTailLaunch stream."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.2.1.1 Global Memory - In the following example the c...",
    "content": "In the following example, the child grid executing child_launch is only guaranteed to see the modifications to data made before the child grid was launched. Since thread O of the parent is performing the launch, the child will be consistent with the memory seen by thread O of the parent. Due to the first __syncthreads() call, the child will see data  $[\\theta ] = \\theta$  data  $[1] = 1$  ..., data  $[255] = 255$  (without the __syncthreads() call, only data  $[\\theta ] = \\theta$  would be guaranteed to be seen by the child). The child grid is only guaranteed to return at an implicit synchronization. This means that the modifications made by the threads in the child grid are never guaranteed to become available to the parent grid."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.2.1.1 Global Memory - To access modifications made b...",
    "content": " To access modifications made by child_launch, a tail_launch kernel is launched into the cudaStreamTailLaunch stream."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.2.1.1 Global Memory - cglobal void taillaunchint dat...",
    "content": "```c--global__ void tail_launch(int *data) {    data[threadIdx.x] = data[threadIdx.x] + 1;}__global__ void child_launch(int *data) {    data[threadIdx.x] = data[threadIdx.x] + 1;}__global__ void parent_launch(int *data) {    data[threadIdx.x] = threadIdx.x;    __syncthreads();    if (threadIdx.x == 0) {        child_launch<<< 1, 256>>>(data);        tail_launch<<< 1, 256, 0, cudaStreamTailLaunch>>>(data);    }}void host_launch(int *data) {    parent_launch<<< 1, 256>>>(data);}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.2.1.2 Zero Copy Memory - Zero copy system memory has id...",
    "content": "Zero- copy system memory has identical coherence and consistency guarantees to global memory, and follows the semantics detailed above. A kernel may not allocate or free zero- copy memory, but may use pointers to zero- copy passed in from the host program."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.2.1.3 Constant Memory - Constants are immutable and ma......Taking the address of a consta...",
    "content": "# 12.2.2.1.3 Constant Memory\nConstants are immutable and may not be modified from the device, even between parent and child launches. That is to say, the value of all __constant__ variables must be set from the host prior to launch. Constant memory is inherited automatically by all child kernels from their respective parents.\n\nTaking the address of a constant memory object from within a kernel thread has the same semantics as for all CUDA programs, and passing that pointer from parent to child or from a child to parent is naturally supported."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.2.1.4 Shared and Local Memory - Shared and Local memory is pri......The NVIDIA compiler will attem...",
    "content": "Shared and Local memory is private to a thread block or thread, respectively, and is not visible or coherent between parent and child. Behavior is undefined when an object in one of these locations is referenced outside of the scope within which it belongs, and may cause an error.\n\nThe NVIDIA compiler will attempt to warn if it can detect that a pointer to local or shared memory is being passed as an argument to a kernel launch. At runtime, the programmer may use the  $\\_$ isGlobal() intrinsic to determine whether a pointer references global memory and so may safely be passed to a child launch."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.2.1.4 Shared and Local Memory - Note that calls to cudaMempcyA...",
    "content": "Note that calls to cudaMempcy\\*Async() or cudaMemset\\*Async() may invoke new child kernels on the device in order to preserve stream semantics. As such, passing shared or local memory pointers to these APIs is illegal and will return an error."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.2.1.5 Local Memory - Local memory is private storag......int xarray10  Creates xarray i...",
    "content": "Local memory is private storage for an executing thread, and is not visible outside of that thread. It is illegal to pass a pointer to local memory as a launch argument when launching a child kernel. The result of dereferencing such a local memory pointer from a child will be undefined.\n\nFor example the following is illegal, with undefined behavior if x_array is accessed by child_launch:\n\nint x_array[10]; // Creates x_array in parent's local memory child_launch<< 1, 1 >>>(x_array);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.2.2.1.5 Local Memory - It is sometimes difficult for ......Invalid  value is local storag...",
    "content": "It is sometimes difficult for a programmer to be aware of when a variable is placed into local memory by the compiler. As a general rule, all storage passed to a child kernel should be allocated explicitly from the global- memory heap, either with cudaMalloc(), new() or by declaring  $\\_$ device__ storage at global scope. For example:\n\n// Correct - \"value\" is global storage - - device__ int value; - - device__ void x() { value = 5; child<< 1, 1 >>>(&value); }\n\n// Invalid - \"value\" is local storage - - device__ void y() { int value = 5; child<< 1, 1 >>>(&value); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3. Programming Interface - Writes to the global memory re...",
    "content": "# 12.2.2.1.6 Texture Memory\nWrites to the global memory region over which a texture is mapped are incoherent with respect to texture accesses. Coherence for texture memory is enforced at the invocation of a child grid and when a child grid completes. This means that writes to memory prior to a child kernel launch are reflected in texture memory accesses of the child. Similarly to Global Memory above, writes to memory by a child are never guaranteed to be reflected in the texture memory accesses by a parent. The only way to access the modifications made by the threads in the child grid before the parent grid exits is via a kernel launched into the cudaStreamTailLaunch stream. Concurrent accesses by parent and child may result in inconsistent data.\n\n# 12.3. Programming Interface\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1. CUDA C++ Reference - This section describes changes......The language interface and API...",
    "content": "This section describes changes and additions to the CUDA  $\\mathtt{C + + }$  language extensions for supporting Dynamic Parallelism.\n\nThe language interface and API available to CUDA kernels using CUDA  $\\mathtt{C + + }$  for Dynamic Parallelism, referred to as the Device Runtime, is substantially like that of the CUDA Runtime API available on the host. Where possible the syntax and semantics of the CUDA Runtime API have been retained in order to facilitate ease of code reuse for routines that may run in either the host or device environments."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1. CUDA C++ Reference - As with all code in CUDA  math...",
    "content": "As with all code in CUDA  $\\mathtt{C + + }$  , the APIs and code outlined here is per- thread code. This enables each thread to make unique, dynamic decisions regarding what kernel or operation to execute next. There are no synchronization requirements between threads within a block to execute any of the provided device runtime APIs, which enables the device runtime API functions to be called in arbitrarily divergent kernel code without deadlock."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.1 Device-Side Kernel Launch - Kernels may be launched from t......Dg is of type dim3 and specifi...",
    "content": "# 12.3.1.1 Device-Side Kernel Launch\nKernels may be launched from the device using the standard CUDA <<< >>> syntax:\n\nkernel_name<<< Dg, Db, Ns, S >>>([kernel arguments]);\n\nDg is of type dim3 and specifies the dimensions and size of the grid Db is of type dim3 and specifies the dimensions and size of each thread block Ns is of type size_t and specifies the number of bytes of shared memory that is dynamically allocated per thread block for this call in addition to statically allocated memory. Ns is an optional argument that defaults to 0. S is of type cudaStream_t and specifies the stream associated with this call. The stream must have been allocated in the same grid where the call is being made. S is an optional argument that defaults to the NULL stream."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.1.1 Launches are Asynchronous - Identical to host side launche......The child grid launch is poste...",
    "content": "# 12.3.1.1.1 Launches are Asynchronous\nIdentical to host- side launches, all device- side kernel launches are asynchronous with respect to the launching thread. That is to say, the  $\\leq \\leq \\leq \\geq \\geq$  launch command will return immediately and the launching thread will continue to execute until it hits an implicit launch- synchronization point (such as at a kernel launched into the cudaStreamTa11L launch stream).\n\nThe child grid launch is posted to the device and will execute independently of the parent thread. The child grid may begin execution at any time after launch, but is not guaranteed to begin execution until the launching thread reaches an implicit launch- synchronization point."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.1.2 Launch Environment Configuration - All global device configuratio......For host launched kernels per ...",
    "content": "# 12.3.1.1.2 Launch Environment Configuration\nAll global device configuration settings (for example, shared memory and L1 cache size as returned from cudaDeviceGetCacheConfig(), and device limits returned from cudaDeviceGetLimit()) will be inherited from the parent. Likewise, device limits such as stack size will remain as- configured.\n\nFor host- launched kernels, per- kernel configurations set from the host will take precedence over the global setting. These configurations will be used when the kernel is launched from the device as well. It is not possible to reconfigure a kernel's environment from the device."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.2 Streams - Both named and unnamed NULL st......Similar to host side launch wo...",
    "content": "Both named and unnamed (NULL) streams are available from the device runtime. Named streams may be used by any thread within a grid, but stream handles may not be passed to other child/parent kernels. In other words, a stream should be treated as private to the grid in which it is created.\n\nSimilar to host- side launch, work launched into separate streams may run concurrently, but actual concurrency is not guaranteed. Programs that depend upon concurrency between child kernels are not supported by the CUDA programming model and will have undefined behavior."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.2 Streams - The host side NULL streams cro......As cudaStreamSynchronize and c...",
    "content": "The host- side NULL stream's cross- stream barrier semantic is not supported on the device (see below for details). In order to retain semantic compatibility with the host runtime, all device streams must be created using the cudaStreamCreateWithFlags () API, passing the cudaStreamNonBlocking flag. The cudaStreamCreate() call is a host- runtime- only API and will fail to compile for the device.\n\nAs cudaStreamSynchronize() and cudaStreamQuery() are unsupported by the device runtime, a kernel launched into the cudaStreamTailLaunch stream should be used instead when the application needs to know that stream- launched child kernels have completed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.2.1 The Implicit (NULL) Stream - Within a host program the unna...",
    "content": "Within a host program, the unnamed (NULL) stream has additional barrier synchronization semantics with other streams (see Default Stream for details). The device runtime offers a single implicit, unnamed stream shared between all threads in a thread block, but as all named streams must be created with the cudaStreamNonBlocking flag, work launched into the NULL stream will not insert an implicit dependency on pending work in any other streams (including NULL streams of other thread blocks)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.2.2 The Fire-and-Forget Stream - The fire and forget named stre......Fire and forget launches are i...",
    "content": "The fire- and- forget named stream (cudaStreamFireAndForget) allows the user to launch fire- andforget work with less boilerplate and without stream tracking overhead. It is functionally identical to, but faster than, creating a new stream per launch, and launching into that stream.\n\nFire- and- forget launches are immediately scheduled for launch without any dependency on the completion of previously launched grids. No other grid launches can depend on the completion of a fireand- forget launch, except through the implicit synchronization at the end of the parent grid. So a tail launch or the next grid in parent grid's stream won't launch before a parent grid's fire- and- forget work has completed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.2.2 The Fire-and-Forget Stream - In this example C2s launch wil......The fire and forget stream can...",
    "content": "// In this example, C2's launch will not wait for C1's completion - global__ void P( ... ) { C1<<< ... , cudaStreamFireAndForget >>>(...) ;\n\n(continues on next page)\n\nThe fire- and- forget stream cannot be used to record or wait on events. Attempting to do so results in cudaErrorInvalidValue. The fire- and- forget stream is not supported when compiled with CUDA_FORCE_CDP1_IF_SUPPORTED defined. Fire- and- forget stream usage requires compilation to be in 64- bit mode."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.2.3 The Tail Launch Stream - The tail launch named stream c......Each grid has its own tail lau...",
    "content": "The tail launch named stream (cudaStreamTailLaunch) allows a grid to schedule a new grid for launch after its completion. It should be possible to use a tail launch to achieve the same functionality as a cudaDeviceSynchronize() in most cases.\n\nEach grid has its own tail launch stream. All non- tail launch work launched by a grid is implicitly synchronized before the tail stream is kicked off. I.e. A parent grid's tail launch does not launch until the parent grid and all work launched by the parent grid to ordinary streams or per- thread or fire- and- forget streams have completed. If two grids are launched to the same grid's tail launch stream, the later grid does not launch until the earlier grid and all its descendent work has completed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.2.3 The Tail Launch Stream - In this example C2 will only l......In this example C will only la...",
    "content": "// In this example, C2 will only launch after C1 completes.  - - global__ void P( ... ) {      C1<<< ... , cudaStreamTailLaunch >>>( ... );      C2<<< ... , cudaStreamTailLaunch >>>( ... );  }\n\nGrids launched into the tail launch stream will not launch until the completion of all work by the parent grid, including all other grids (and their descendants) launched by the parent in all non- tail launched streams, including work executed or launched after the tail launch.\n\n// In this example, C will only launch after all X, F and P complete.  - - global__ void P( ... ) {      C<<< ... , cudaStreamTailLaunch >>>( ... );      X<<< ... , cudaStreamPerThread >>>( ... );      F<<< ... , cudaStreamFireAndForget >>>( ... );  }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.2.3 The Tail Launch Stream - The next grid in the parent gr......Each grid only gets one tail l...",
    "content": "The next grid in the parent grid's stream will not be launched before a parent grid's tail launch work has completed. In other words, the tail launch stream behaves as if it were inserted between its parent grid and the next grid in its parent grid's stream.\n\n// In this example, P2 will only launch after C completes.  - - global__ void P( ... ) {      C<<< ... , cudaStreamTailLaunch >>>( ... );  }  - - global__ void P2( ... ) {  }  int main ( ... ) {      ...      P1<<< ... >>>( ... );      P2<<< ... >>>( ... );      ...  }\n\nEach grid only gets one tail launch stream. To tail launch concurrent grids, it can be done like the example below."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.2.3 The Tail Launch Stream - In this example C1 and C2 will...",
    "content": "// In this example, C1 and C2 will launch concurrently after P's completion \\(\\begin{array}{rl} & \\mathtt{\\_global\\_\\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_ \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_ \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.2.3 The Tail Launch Stream",
    "content": "_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_ \\_\\_ \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_ \\_\\_\\_\\_\\_ \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_ \\_\\_ \\_\\_\\_ \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_ \\_\\_\\_ \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.2.3 The Tail Launch Stream",
    "content": "\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_ \\_\\_\\_\\_\\_\\_ \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_ \\_\\_ \\_\\_\\- \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.2.3 The Tail Launch Stream - The tail launch stream cannot ...",
    "content": "The tail launch stream cannot be used to record or wait on events. Attempting to do so results in cudaErrorInvalidValue. The tail launch stream is not supported when compiled with CUDA_FORCE_CDP1_IF_SUPPORTED defined. Tail launch stream usage requires compilation to be in 64- bit mode."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.3 Events - Only the inter stream synchron......As with named streams event ob...",
    "content": "# 12.3.1.3 Events\nOnly the inter- stream synchronization capabilities of CUDA events are supported. This means that cudaStreamWaitEvent() is supported, but cudaEventSynchronize(), cudaEventElapsedTime(), and cudaEventQuery() are not. As cudaEventElapsedTime() is not supported, cudaEvents must be created via cudaEventCreateWithFlags(), passing the cudaEventDisableTiming flag.\n\nAs with named streams, event objects may be shared between all threads within the grid which created them but are local to that grid and may not be passed to other kernels. Event handles are not guaranteed to be unique between grids, so using an event handle within a grid that did not create it will result in undefined behavior."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.4 Synchronization - It is up to the program to per......As it is not possible to expli...",
    "content": "It is up to the program to perform sufficient inter- thread synchronization, for example via a CUDA Event, if the calling thread is intended to synchronize with child grids invoked from other threads.\n\nAs it is not possible to explicitly synchronize child work from a parent thread, there is no way to guarantee that changes occuring in child grids are visible to threads within the parent grid."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.6 Memory Declarations - Only the device on which a ker...",
    "content": "# 12.3.1.5 Device Management\nOnly the device on which a kernel is running will be controllable from that kernel. This means that device APIs such as cudaSetDevice() are not supported by the device runtime. The active device as seen from the GPU (returned from cudaGetDevice()) will have the same device number as seen from the host system. The cudaDeviceGetAttribute() call may request information about another device as this API allows specification of a device ID as a parameter of the call. Note that the catch- all cudaGetDeviceProperties() API is not offered by the device runtime - properties must be queried individually.\n\n# 12.3.1.6 Memory Declarations\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.6.1 Device and Constant Memory - Memory declared at file scope ...",
    "content": "Memory declared at file scope with __device__ or __constant__ memory space specifiers behaves identically when using the device runtime. All kernels may read or write device variables, whether the kernel was initially launched by the host or device runtime. Equivalently, all kernels will have the same view of __constant__s as declared at the module scope."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.6.2 Textures and Surfaces - CUDA supports dynamically crea...",
    "content": "CUDA supports dynamically created texture and surface objects<sup>14</sup>, where a texture reference may be created on the host, passed to a kernel, used by that kernel, and then destroyed from the host. The device runtime does not allow creation or destruction of texture or surface objects from within device code, but texture and surface objects created from the host may be used and passed around freely on the device. Regardless of where they are created, dynamically created texture objects are always valid and may be passed to child kernels from a parent."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.6.2 Textures and Surfaces - Note The device runtime does n...",
    "content": "Note: The device runtime does not support legacy module- scope (i.e., Fermi- style) textures and surfaces within a kernel launched from the device. Module- scope (legacy) textures may be created from the host and used in device code as for any kernel, but may only be used by a top- level kernel (i.e., the one which is launched from the host)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.6.3 Shared Memory Variable Declarations - In CUDA C shared memory can be......global void permuteint n int d...",
    "content": "In CUDA C++ shared memory can be declared either as a statically sized file- scope or function- scoped variable, or as an extern variable with the size determined at runtime by the kernel's caller via a launch configuration argument. Both types of declarations are valid under the device runtime.\n\n- global__ void permute(int n, int *data) {    extern__shared__ int smem[];    if (n <= 1)        return;    smem[threadIdx.x] = data[threadIdx.x];    __syncthreads();    permute_data(smem, n);    __syncthreads();    // Write back to GMEM since we can't pass SMEM to children.    data[threadIdx.x] = smem[threadIdx.x];    __syncthreads();    if (threadIdx.x == 0) {        permute<<< 1, 256, n/2 * sizeof(int) >>> (n/2, data);        permute<<< 1, 256, n/2 * sizeof(int) >>> (n/2, data + n/2);    }}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.6.3 Shared Memory Variable Declarations - continues on next page...void hostlaunchint data     pe...",
    "content": "(continues on next page)\n\n}\n\nvoid host_launch(int *data) {    permute<<< 1, 256, 256 * sizeof(int)>>>(256, data);}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.6.4 Symbol Addresses - Device side symbols ie those m......Given that device side symbols...",
    "content": "# 12.3.1.6.4 Symbol Addresses\nDevice- side symbols (i.e., those marked __device__) may be referenced from within a kernel simply via the & operator, as all global- scope device variables are in the kernel's visible address space. This also applies to __constant__ symbols, although in this case the pointer will reference read- only data.\n\nGiven that device- side symbols can be referenced directly, those CUDA runtime APIs which reference symbols (e.g., cudaMempyToSymbol() or cudaGetSymbolAddress()) are redundant and hence not supported by the device runtime. Note this implies that constant data cannot be altered from within a running kernel, even ahead of a child kernel launch, as references to __constant__ space are read- only."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.7 API Errors and Launch Failures - As usual for the CUDA runtime ......For device side exceptions eg ...",
    "content": "# 12.3.1.7 API Errors and Launch Failures\nAs usual for the CUDA runtime, any function may return an error code. The last error code returned is recorded and may be retrieved via the cudaGetLastError() call. Errors are recorded per- thread, so that each thread can identify the most recent error that it has generated. The error code is of type cudaError_t.\n\nSimilar to a host- side launch, device- side launches may fail for many reasons (invalid arguments, etc). The user must call cudaGetLastError() to determine if a launch generated an error, however lack of an error after launch does not imply the child kernel completed successfully.\n\nFor device- side exceptions, e.g., access to an invalid address, an error in a child grid will be returned to the host."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.7.1 Launch Setup APIs - Kernel launch is a system leve......As with host side launch the d...",
    "content": "Kernel launch is a system- level mechanism exposed through the device runtime library, and as such is available directly from PTX via the underlying cudaGetParameterBuffer() and cudaLaunchDevice() APIs. It is permitted for a CUDA application to call these APIs itself, with the same requirements as for PTX. In both cases, the user is then responsible for correctly populating all necessary data structures in the correct format according to specification. Backwards compatibility is guaranteed in these data structures.\n\nAs with host- side launch, the device- side operator <<>>> maps to underlying kernel launch APIs. This is so that users targeting PTX will be able to enact a launch, and so that the compiler front- end can translate <<>>> into these calls."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.7.1 Launch Setup APIs - Table 1 Table 5 New Deviceonly......The APIs for these launch func...",
    "content": "Table 1: Table 5. New Device-only Launch Implementation Functions\n\n<table><tr><td>Runtime API Launch Functions</td><td>Description of Difference From Host Runtime Behaviour (behavior is identical if no description)</td></tr><tr><td>cudaGetParameter-Buffer</td><td>Generated automatically from &amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt; . Note different API to host equiv- alent.</td></tr><tr><td>cudaLaunchDevice</td><td>Generated automatically from &amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt; . Note different API to host equiv- alent.</td></tr></table>\n\nThe APIs for these launch functions are different to those of the CUDA Runtime API, and are defined as follows:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.7.1 Launch Setup APIs - extern device cudaErrort cudaG...",
    "content": "extern device cudaError_t cudaGetParameterBuffer(void \\*\\*params); extern __device__ cudaError_t cudaLaunchDevice(void \\*kernel, void \\*params, dim3 gridDim, dim3 blockDim, unsigned int sharedMemSize  $= 0$  cudaStream_t stream  $= 0$"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.8 API Reference - The portions of the CUDA Runti......Table 2Table 6 Supported API F...",
    "content": "The portions of the CUDA Runtime API supported in the device runtime are detailed here. Host and device runtime APIs have identical syntax; semantics are the same except where indicated. The table below provides an overview of the API relative to the version available from the host.\n\nTable 2:Table 6. Supported API Functions"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.8 API Reference - tabletrtdRuntime API Functions...",
    "content": "<table><tr><td>Runtime API Functions</td><td>Details</td></tr><tr><td>cudaDeviceGetCacheConfig</td><td></td></tr><tr><td>cudaDeviceGetLimit</td><td></td></tr><tr><td>cudaGetLastError</td><td>Last error is per-thread state, not per-block state</td></tr><tr><td>cudaPeekAtLastError</td><td></td></tr><tr><td>cudaGetErrorString</td><td></td></tr><tr><td>cudaGetDeviceCount</td><td></td></tr><tr><td>cudaDeviceGetAttribute</td><td>Will return attributes for any device</td></tr><tr><td>cudaGetDevice</td><td>Always returns current device ID as would be seen from host</td></tr><tr><td>cudaStreamCreateWithFlags</td><td>Must pass cudaStreamNonBlocking flag</td></tr><tr><td>cudaStreamDestroy</td><td></td></tr><tr><td>cudaStreamWaitEvent</td><td></td></tr><tr><td>cudaEventCreateWithFlags</td><td>Must pas"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.8 API Reference - s cudaEventDisableTiming flagt...",
    "content": "s cudaEventDisableTiming flag</td></tr><tr><td>cudaEventRecord</td><td></td></tr><tr><td>cudaEventDestroy</td><td></td></tr><tr><td>cudaFuncGetAttributes</td><td></td></tr><tr><td>cudaMemopyAsync</td><td>Notes about all memcpy/memset functions:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.1.8 API Reference - Only async memcpyset functions...",
    "content": "   ➔ Only async memcpy/set functions are sup-ported   ➔ Only device-to-device memcpy is permitted   ➔ May not pass in local or shared memory pointers</td></tr><tr><td>cudaMemopy2DAsync</td><td></td></tr><tr><td>cudaMemopy3DAsync</td><td></td></tr><tr><td>cudaMemsetAsync</td><td></td></tr><tr><td>cudaMemset2DAsync</td><td></td></tr><tr><td>cudaMemset3DAsync</td><td></td></tr><tr><td>cudaRuntimeGetVersion</td><td></td></tr><tr><td>cudaMalloc</td><td>May not call cudaFree on the device on a pointer created on the host, and vice-versa</td></tr><tr><td>cudaFree</td><td></td></tr><tr><td>cudaOccupancyMaxActiveBlocksPerMulti-processor</td><td></td></tr><tr><td>cudaOccupancyMaxPotentialBlockSize</td><td></td></tr><tr><td>cudaOccupancyMaxPotentialBlockSize-VariableSMem</td><td></td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.2.1 Kernel Launch APIs - 1232 Device side Launch from P...",
    "content": "12.3.2. Device- side Launch from PTXThis section is for the programming language and compiler implementers who target Parallel Thread Execution (PTX) and plan to support Dynamic Parallelism in their language. It provides the low- level details related to supporting kernel launches at the PTX level."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.2.1 Kernel Launch APIs - 12321 Kernel Launch APIsDevice...",
    "content": "# 12.3.2.1 Kernel Launch APIs\n12.3.2.1 Kernel Launch APIsDevice- side kernel launches can be implemented using the following two APIs accessible from PTX: cudaLaunchDevice() and cudaGetParameterBuffer(). cudaLaunchDevice() launches the specified kernel with the parameter buffer that is obtained by calling cudaGetParameterBuffer() and filled with the parameters to the launched kernel. The parameter buffer can be NULL, i.e., no need to invoke cudaGetParameterBuffer(), if the launched kernel does not take any parameters."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.2.1.1 cudaLaunchDevice - At the PTX level cudaLaunchDev......The CUDA level declaration bel...",
    "content": "At the PTX level, cudaLaunchDevice()needs to be declared in one of the two forms shown below before it is used.\n\n// PTX- level Declaration of cudaLaunchDevice() when .address_size is 64 .extern .func(.param .b32 func_retval0) cudaLaunchDevice (.param .b64 func, .param .b64 parameterBuffer, .param .align 4 .b8 gridDimension[12], .param .align 4 .b8 blockDimension[12], .param .b32 sharedMemSize, .param .b64 stream ) ;\n\nThe CUDA- level declaration below is mapped to one of the aforementioned PTX- level declarations and is found in the system header file cuda_device_runtime_api.h. The function is defined in the cudadevrt system library, which must be linked with a program in order to use device- side kernel launch functionality."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.2.1.1 cudaLaunchDevice - CUDA level declaration of cuda......The first parameter is a point...",
    "content": "// CUDA- level declaration of cudaLaunchDevice()extern \"C\" __device__cudaError_t cudaLaunchDevice(void *func, void *parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned int sharedMemSize, cudaStream_t stream);\n\nThe first parameter is a pointer to the kernel to be is launched, and the second parameter is the parameter buffer that holds the actual parameters to the launched kernel. The layout of the parameter buffer is explained in Parameter Buffer Layout, below. Other parameters specify the launch configuration, i.e., as grid dimension, block dimension, shared memory size, and the stream associated with the launch (please refer to Execution Configuration for the detailed description of launch configuration."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.2.1.2 cudaGetParameterBuffer - cudaGetParameterBuffer needs t......CUDA level Declaration of cuda...",
    "content": "cudaGetParameterBuffer() needs to be declared at the PTX level before it's used. The PTX- level declaration must be in one of the two forms given below, depending on address size:\n\n// PTX- level Declaration of cudaGetParameterBuffer() when .address_size is 64 .extern .func(.param .b64 func_retval0) cudaGetParameterBuffer ( .param .b64 alignment, .param .b64 size ) ;\n\nThe following CUDA- level declaration of cudaGetParameterBuffer() is mapped to the aforementioned PTX- level declaration:\n\n// CUDA- level Declaration of cudaGetParameterBuffer() extern \"c\" - - device- - void \\*cudaGetParameterBuffer(size_t alignment, size_t size);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.2.1.2 cudaGetParameterBuffer - The first parameter specifies ...",
    "content": "The first parameter specifies the alignment requirement of the parameter buffer and the second parameter the size requirement in bytes. In the current implementation, the parameter buffer returned by cudaGetParameterBuffer() is always guaranteed to be 64- byte aligned, and the alignment requirement parameter is ignored. However, it is recommended to pass the correct alignment requirement value - which is the largest alignment of any parameter to be placed in the parameter buffer - to cudaGetParameterBuffer() to ensure portability in the future."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.3. Toolkit Support for Dynamic Parallelism - Parameter reordering in the pa......For a more detailed descriptio...",
    "content": "# 12.3.2.2 Parameter Buffer Layout\nParameter reordering in the parameter buffer is prohibited, and each individual parameter placed in the parameter buffer is required to be aligned. That is, each parameter must be placed at the  $n^{\\mathrm{th}}$  byte in the parameter buffer, where  $n$  is the smallest multiple of the parameter size that is greater than the offset of the last byte taken by the preceding parameter. The maximum size of the parameter buffer is 4KB.\n\nFor a more detailed description of PTX code generated by the CUDA compiler, please refer to the PTX3.5 specification.\n\n# 12.3.3. Toolkit Support for Dynamic Parallelism\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.3.1 Including Device Runtime API in CUDA Code - Similar to the host side runti...",
    "content": "Similar to the host- side runtime API, prototypes for the CUDA device runtime API are included automatically during program compilation. There is no need to include cuda_device_runtime_api.h explicitly."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.3.2 Compiling and Linking - When compiling and linking CUD......mathfraks  nvcc  arch  equiv  ...",
    "content": "When compiling and linking CUDA programs using dynamic parallelism with nvcc, the program will automatically link against the static device runtime library libcudadevrt.\n\nThe device runtime is offered as a static library (cudadevrt . lib on Windows, libcudadevrt . a under Linux), against which a GPU application that uses the device runtime must be linked. Linking of device libraries can be accomplished through nvcc and/or nvlink. Two simple examples are shown below.\n\nA device runtime program may be compiled and linked in a single step, if all required source files can be specified from the command line:\n\n$\\mathfrak{s}$  nvcc - arch  $\\equiv$  sm_75 - rdc  $\\equiv$  true hello_world.cu - o hello - lcudadevrt"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.3.3.2 Compiling and Linking - It is also possible to compile......Please see the Using Separate ...",
    "content": "It is also possible to compile CUDA .cu source files first to object files, and then link these together in a two- stage process:\n\n$\\mathfrak{s}$  nvcc - arch  $\\equiv$  sm_75 - dc hello_world.cu - o hello_world.o  $\\mathfrak{s}$  nvcc - arch  $\\equiv$  sm_75 - rdc  $\\equiv$  true hello_world.o - o hello - lcudadevrt\n\nPlease see the Using Separate Compilation section of The CUDA Driver Compiler NVCC guide for more details."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.4. Programming Guidelines",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.4.1. Basics - The device runtime is a functi......continues on next page",
    "content": "The device runtime is a functional subset of the host runtime. API level device management, kernel launching, device memcpy, stream management, and event management are exposed from the device runtime.\n\nProgramming for the device runtime should be familiar to someone who already has experience with CUDA. Device runtime syntax and semantics are largely the same as that of the host API, with any exceptions detailed earlier in this document.\n\nThe following example shows a simple Hello World program incorporating dynamic parallelism:\n\ninclude <stdio.h> global__ void childKernel() { printf(\"Hello \"); } global__ void tailKernel() { printf(\"World!\\n\"); } global__ void parentKernel() { // launch child childKernel  $\\leq \\leq \\leq 1$ $1 > > > > ($\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.4.1. Basics - if cudaSuccess     cudaGetLast......nvcc  archsm75  rdctrue hellow...",
    "content": "if (cudaSuccess  $! =$  cudaGetLastError()) { return; } // launch tail into cudaStreamTailLaunch stream // implicitly synchronizes: waits for child to complete tailKernel  $\\scriptstyle \\epsilon < < 1$  ,1,0, cudaStreamTailLaunch  $\\Rightarrow \\Rightarrow ()$  ; } int main(int argc, char \\*argv[]) { // launch parent parentKernel  $\\epsilon < < 1$  ,  $1 > > > ()$  if (cudaSuccess  $! =$  cudaGetLastError()) { return 1; } // wait for parent to complete if (cudaSuccess  $! =$  cudaDeviceSynchronize() { return 2; } return 0; }\n\nThis program may be built in a single step from the command line as follows:\n\n$ nvcc - arch=sm_75 - rdc=true hello_world.cu - o hello - lcudadevrt"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.4.3. Implementation Restrictions and Limitations - System software which is activ......Dynamic Parallelism guarantees...",
    "content": "# 12.4.2. Performance\n\n\n# 12.4.2.1 Dynamic-parallelism-enabled Kernel Overhead\nSystem software which is active when controlling dynamic launches may impose an overhead on any kernel which is running at the time, whether or not it invokes kernel launches of its own. This overhead arises from the device runtime's execution tracking and management software and may result in decreased performance. This overhead is, in general, incurred for applications that link against the device runtime library.\n\n# 12.4.3. Implementation Restrictions and Limitations\nDynamic Parallelism guarantees all semantics described in this document, however, certain hardware and software resources are implementation- dependent and limit the scale, performance and other properties of a program which uses the device runtime."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.4.3.1.2 Pending Kernel Launches - 124311 Memory FootprintThe dev......The size of the fixed size lau...",
    "content": "# 12.4.3.1 Runtime\n\n\n# 12.4.3.1.1 Memory Footprint\n12.4.3.1.1 Memory FootprintThe device runtime system software reserves memory for various management purposes, in particular a reservation for tracking pending grid launches. Configuration controls are available to reduce the size of this reservation in exchange for certain launch limitations. See Configuration Options, below, for details.\n\n# 12.4.3.1.2 Pending Kernel Launches\nWhen a kernel is launched, all associated configuration and parameter data is tracked until the kernel completes. This data is stored within a system- managed launch pool.\n\nThe size of the fixed- size launch pool is configurable by calling cudaDeviceSetLimit () from the host and specifying cudaLimitDevRuntimePendingLaunchCount."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.4.3.1.3 Configuration Options - Resource allocation for the de......The following named limits may...",
    "content": "Resource allocation for the device runtime system software is controlled via the cudaDeviceSetLimit () API from the host program. Limits must be set before any kernel is launched, and may not be changed while the GPU is actively running programs.\n\nThe following named limits may be set:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.4.3.1.3 Configuration Options - tabletrtdLimittdtdBehaviortdtr...",
    "content": "<table><tr><td>Limit</td><td>Behavior</td></tr><tr><td>cud-aLim-it-vRun-timePer-Count</td><td>Controls the amount of memory set aside for buffering kernel launches and events which have not yet begun to execute, due either to unresolved dependencies or lack of execution resources. When the buffer is full, an attempt to allocate a launch slot during a device side kernel launch will fail and return cudaErrorLaunchOutOfResources, while an attempt to allocate an event slot will fail and return cudaErrorMemoryAllocation. The default num-ber of launch slots is 2048. Applications may increase the number of launch and/or event slots by setting cudaLimitDevRuntimePendingLaunchCount. The number of event slots allocated is twice the value of that limit."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.4.3.1.3 Configuration Options - tdtrtrtdcudaLimitStackSizetdtd...",
    "content": "</td></tr><tr><td>cud-aLim-it-Stack-Size</td><td>Controls the stack size in bytes of each GPU thread. The CUDA driver automatically in-creases the per-thread stack size for each kernel launch as needed. This size isn’t reset back to the original value after each launch. To set the per-thread stack size to a different value, cudaDeviceSetLimit() can be called to set this limit. The stack will be immedi-ately resized, and if necessary, the device will block until all preceding requested tasks are complete. cudaDeviceGetLimit() can be called to get the current per-thread stack size.</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.4.3.1.4 Memory Allocation and Lifetime - cudaMalloc and cudaFree have d...",
    "content": "cudaMalloc() and cudaFree() have distinct semantics between the host and device environments. When invoked from the host, cudaMalloc() allocates a new region from unused device memory. When invoked from the device runtime these functions map to device- side malloc() and free(). This implies that within the device environment the total allocatable memory is limited to the device malloc() heap size, which may be smaller than the available unused device memory. Also, it is an error to invoke cudaFree() from the host program on a pointer which was allocated by cudaMalloc() on the device or vice- versa."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.4.3.1.4 Memory Allocation and Lifetime - tabletrtdtdtdcudaMalloc on Hos...",
    "content": "<table><tr><td></td><td>cudaMalloc() on Host</td><td>cudaMalloc() on Device</td></tr><tr><td>cudaFree() on Host</td><td>Supported</td><td>Not Supported</td></tr><tr><td>cudaFree() on Device</td><td>Not Supported</td><td>Supported</td></tr><tr><td>Allocation limit</td><td>Free device memory</td><td>cudaLimitMallocHeapSize</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.4.3.1.6 ECC Errors - No notification of ECC errors ...",
    "content": "# 12.4.3.1.5 SM Id and Warp Id\nNote that in PTX %smid and %warpid are defined as volatile values. The device runtime may reschedule thread blocks onto different SMs in order to more efficiently manage resources. As such, it is unsafe to rely upon %smid or %warpid remaining unchanged across the lifetime of a thread or thread block.\n\n# 12.4.3.1.6 ECC Errors\nNo notification of ECC errors is available to code within a CUDA kernel. ECC errors are reported at the host side once the entire launch tree has completed. Any ECC errors which arise during execution of a nested program will either generate an exception or continue execution (depending upon error and configuration)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.5. CDP2 vs CDP1 - This section summarises the di...",
    "content": "This section summarises the differences between, and the compatibility and interoperability of, the new (CDP2) and legacy (CDP1) CUDA Dynamic Parallelism interfaces. It also shows how to opt- out of the CDP2 interface on devices of compute capability less than 9.0."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.5.1. Differences Between CDP1 and CDP2 - Explicit device side synchroni......CDP2 no longer has a virtualiz...",
    "content": "Explicit device- side synchronization is no longer possible with CDP2 or on devices of compute capability 9.0 or higher. Implicit synchronization (such as tail launches) must be used instead.\n\nAttempting to query or set cudaLimitDevRuntimeSyncDepth (or CU_LIMIT_DEV RUNTIME_SYNC_DEPTH) with CDP2 or on devices of compute capability 9.0 or higher results in cudaErrorUnsupportedLimit.\n\nCDP2 no longer has a virtualized pool for pending launches that don't fit in the fixed- sized pool. cudaLimitDevRuntimePendingLaunchCount must be set to be large enough to avoid running out of launch slots."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.5.1. Differences Between CDP1 and CDP2 - For CDP2 there is a limit to t......CDP2 is supported only under 6...",
    "content": "For CDP2, there is a limit to the total number of events existing at once (note that events are destroyed only after a launch completes), equal to twice the pending launch count. cudaLimitDevRuntimePendingLaunchCount must be set to be large enough to avoid running out of event slots.\n\nStreams are tracked per grid with CDP2 or on devices of compute capability 9.0 or higher, not per thread block. This allows work to be launched into a stream created by another thread block. Attempting to do so with the CDP1 results in cudaErrorInvalidValue.\n\nCDP2 introduces the tail launch (cudaStreamTailLaunch) and fire- and- forget (cudaStreamFireAndForget) named streams.\n\nCDP2 is supported only under 64- bit compilation mode."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.5.2. Compatibility and Interoperability - CDP2 is the default Functions ...",
    "content": "CDP2 is the default. Functions can be compiled with - DCUDA_FORCE_CDP1_IF_SUPPORTED to opt- out of using CDP2 on devices of compute capability less than 9.0."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.5.2. Compatibility and Interoperability - tabletrtd rowspan2Compilationt...",
    "content": "<table><tr><td rowspan=\"2\">Compi-lation</td><td>Function com-piler with CUDA 12.0 and newer (default)</td><td>Function compiled with pre-CUDA FORCE CDP1 IF SUPPORTED specified</td></tr><tr><td>Compile error if device code references cu-daDeviceSyn-chronize.</td><td>Compile error if code references cudaStreamTailLaunch or cudaS-treamFireAndForget. Compile error if device code references cud-aDeviceSynchronize and code is compiled for sm_90 or newer.</td></tr><tr><td>Com-pute capa-bility &amp;lt; 9.0</td><td>New interface is used.</td><td>Legacy interface is used.</td></tr><tr><td>Com-pute capa-bility 9.0 and higher</td><td>New interface is used.</td><td>New interface is used."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.5.2. Compatibility and Interoperability - If function references cudaDev...",
    "content": " If function references cudaDeviceSynchro-nize in device code, function load returns cudaErrorSymbolNot-Found (this could happen if the code is compiled for devices of com-pute capability less than 9.0, but run on devices of compute capability 9.0 or higher using JIT).</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.5.2. Compatibility and Interoperability - Functions using CDP1 and CDP2 ......A function using CDP1 cannot l...",
    "content": "Functions using CDP1 and CDP2 may be loaded and run simultaneously in the same context. The CDP1 functions are able to use CDP1- specific features (e.g. cudaDeviceSynchronize) and CDP2 functions are able to use CDP2- specific features (e.g. tail launch and fire- and- forget launch).\n\nA function using CDP1 cannot launch a function using CDP2, and vice versa. If a function that would use CDP1 contains in its call graph a function that would use CDP2, or vice versa, cudaErrorCdpVersionMismatch would result during function load."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1. Execution Environment and Memory Model (CDP1) - See CUDA Dynamic Parallelism a......See Execution Environment and ...",
    "content": "See CUDA Dynamic Parallelism, above, for CDP2 version of document.\n\n# 12.6.1. Execution Environment and Memory Model (CDP1)\nSee Execution Environment and Memory Model, above, for CDP2 version of document."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.1 Execution Environment (CDP1) - See Execution Environment abov......The CUDA execution model is ba...",
    "content": "See Execution Environment, above, for CDP2 version of document.\n\nThe CUDA execution model is based on primitives of threads, thread blocks, and grids, with kernel functions defining the program executed by individual threads within a thread block and grid. When a kernel function is invoked the grid's properties are described by an execution configuration, which has a special syntax in CUDA. Support for dynamic parallelism in CUDA extends the ability to configure, launch, and synchronize upon new grids to threads that are running on the device."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.1 Execution Environment (CDP1) - Warning Explicit synchronizati...",
    "content": "Warning: Explicit synchronization with child kernels from a parent block (i.e. using cudaDeviceSynchronize() in device code) block is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.1.1 Parent and Child Grids (CDP1) - See Parent and Child Grids abo......The invocation and completion ...",
    "content": "See Parent and Child Grids, above, for CDP2 version of document.\n\nA device thread that configures and launches a new grid belongs to the parent grid, and the grid created by the invocation is a child grid.\n\nThe invocation and completion of child grids is properly nested, meaning that the parent grid is not considered complete until all child grids created by its threads have completed. Even if the invoking threads do not explicitly synchronize on the child grids launched, the runtime guarantees an implicit synchronization between the parent and child."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.1.1 Parent and Child Grids (CDP1) - Warning Explicit synchronizati......Fig 2 ParentChild Launch Nesti...",
    "content": "Warning: Explicit synchronization with child kernels from a parent block (i.e. using cudaDeviceSynchronize() in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/f4d29ba4d0c4de44fa1b8528f1d8c9b8a4753a6a16233fa352933258f5f53d3c.jpg)  \nFig. 2: Parent-Child Launch Nesting"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.1.2 Scope of CUDA Primitives (CDP1) - See Scope of CUDA Primitives a......On both host and device the CU...",
    "content": "See Scope of CUDA Primitives, above, for CDP2 version of document.\n\nOn both host and device, the CUDA runtime offers an API for launching kernels, for waiting for launched work to complete, and for tracking dependencies between launches via streams and events. On the host system, the state of launches and the CUDA primitives referencing streams and events are shared by all threads within a process; however processes execute independently and may not share CUDA objects."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.1.2 Scope of CUDA Primitives (CDP1) - A similar hierarchy exists on ...",
    "content": "A similar hierarchy exists on the device: launched kernels and CUDA objects are visible to all threads in a thread block, but are independent between thread blocks. This means for example that a stream may be created by one thread and used by any other thread in the same thread block, but may not be shared with threads in any other thread block."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.1.3 Synchronization (CDP1) - See Synchronization above for ......CUDA runtime operations from a...",
    "content": "See Synchronization, above, for CDP2 version of document.\n\nWarning: Explicit synchronization with child kernels from a parent block (i.e. using cudaDeviceSynchronize() in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.\n\nCUDA runtime operations from any thread, including kernel launches, are visible across a thread block. This means that an invoking thread in the parent grid may perform synchronization on the grids launched by that thread, by other threads in the thread block, or on streams created within the same thread block. Execution of a thread block is not considered complete until all launches by all threads"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.1.3 Synchronization (CDP1) - in the block have completed If...",
    "content": "in the block have completed. If all threads in a block exit before all child launches have completed, a synchronization operation will automatically be triggered."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.1.4 Streams and Events (CDP1) - See Streams and Events above f......Streams and events created wit...",
    "content": "See Streams and Events, above, for CDP2 version of document.\n\nCUDA Streams and Events allow control over dependencies between grid launches: grids launched into the same stream execute in- order, and events may be used to create dependencies between streams. Streams and events created on the device serve this exact same purpose.\n\nStreams and events created within a grid exist within thread block scope but have undefined behavior when used outside of the thread block where they were created. As described above, all work launched by a thread block is implicitly synchronized when the block exits; work launched into streams is included in this, with all dependencies resolved appropriately. The behavior of operations on a stream that has been modified outside of thread block scope is undefined."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.1.4 Streams and Events (CDP1) - Streams and events created on ...",
    "content": "Streams and events created on the host have undefined behavior when used within any kernel, just as streams and events created by a parent grid have undefined behavior if used within a child grid."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.1.5 Ordering and Concurrency (CDP1) - See Ordering and Concurrency a......Note that because streams are ...",
    "content": "See Ordering and Concurrency, above, for CDP2 version of document.\n\nThe ordering of kernel launches from the device runtime follows CUDA Stream ordering semantics. Within a thread block, all kernel launches into the same stream are executed in- order. With multiple threads in the same thread block launching into the same stream, the ordering within the stream is dependent on the thread scheduling within the block, which may be controlled with synchronization primitives such as __syncthreads().\n\nNote that because streams are shared by all threads within a thread block, the implicit NULL stream is also shared. If multiple threads in a thread block launch into the implicit stream, then these launches will be executed in- order. If concurrency is desired, explicit named streams should be used."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.1.5 Ordering and Concurrency (CDP1) - Dynamic Parallelism enables co......The lack of concurrency guaran...",
    "content": "Dynamic Parallelism enables concurrency to be expressed more easily within a program; however, the device runtime introduces no new concurrency guarantees within the CUDA execution model. There is no guarantee of concurrent execution between any number of different thread blocks on a device.\n\nThe lack of concurrency guarantee extends to parent thread blocks and their child grids. When a parent thread block launches a child grid, the child is not guaranteed to begin execution until the parent thread block reaches an explicit synchronization point (such as cudaDeviceSynchronize()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.1.5 Ordering and Concurrency (CDP1) - Warning Explicit synchronizati......While concurrency will often e...",
    "content": "Warning: Explicit synchronization with child kernels from a parent block (i.e. using cudaDeviceSynchronize() in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.\n\nWhile concurrency will often easily be achieved, it may vary as a function of device configuration, application workload, and runtime scheduling. It is therefore unsafe to depend upon any concurrency between different thread blocks."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1 Coherence and Consistency (CDP1) - See Device Management above fo......See Coherence and Consistency ...",
    "content": "# 12.6.1.1.6 Device Management (CDP1)\nSee Device Management, above, for CDP2 version of document.\n\nThere is no multi- GPU support from the device runtime; the device runtime is only capable of operating on the device upon which it is currently executing. It is permitted, however, to query properties for any CUDA capable device in the system.\n\n# 12.6.1.2 Memory Model (CDP1)\nSee Memory Model, above, for CDP2 version of document.\n\nParent and child grids share the same global and constant memory storage, but have distinct local and shared memory.\n\n# 12.6.1.2.1 Coherence and Consistency (CDP1)\nSee Coherence and Consistency, above, for CDP2 version of document."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.1 Global Memory (CDP1) - See Global Memory above for CD......Warning Explicit synchronizati...",
    "content": "See Global Memory, above, for CDP2 version of document.\n\nParent and child grids have coherent access to global memory, with weak consistency guarantees between child and parent. There are two points in the execution of a child grid when its view of memory is fully consistent with the parent thread: when the child grid is invoked by the parent, and when the child grid completes as signaled by a synchronization API invocation in the parent thread.\n\nWarning: Explicit synchronization with child kernels from a parent block (i.e. using cudaDeviceSynchronize() in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.1 Global Memory (CDP1) - All global memory operations i...",
    "content": "All global memory operations in the parent thread prior to the child grid's invocation are visible to the child grid. All memory operations of the child grid are visible to the parent after the parent has synchronized on the child grid's completion."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.1 Global Memory (CDP1) - In the following example the c...",
    "content": "In the following example, the child grid executing child_1aunch is only guaranteed to see the modifications to data made before the child grid was launched. Since thread O of the parent is performing the launch, the child will be consistent with the memory seen by thread O of the parent. Due to the first __syncthreads() call, the child will see data[0]=0, data[1]=1, ..., data[255]=255 (without the __syncthreads() call, only data[0] would be guaranteed to be seen by the child). When the child grid returns, thread O is guaranteed to see modifications made by the threads in its child grid. Those modifications become available to the other threads of the parent grid only after the second __syncthreads() call:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.1 Global Memory (CDP1) - continues on next page...syncthreads if threadIdxx    0...",
    "content": "- -global__ void child_1aunch(int *data) {    data[threadIdx.x] = data[threadIdx.x]+1;}- -global__ void parent_1aunch(int *data) {    data[threadIdx.x] = threadIdx.x;\n\n(continues on next page)\n\n__syncthreads(); if (threadIdx.x  $= = 0$  ){ child_launch  $\\epsilon \\epsilon \\epsilon \\epsilon$  1,256  $\\geq \\geq \\geq$  (data); cudaDeviceSynchronize(); } __syncthreads(); void host_launch(int \\*data) { parent_launch  $\\epsilon \\epsilon \\epsilon \\epsilon$  1,256  $\\geq \\geq \\geq$  (data); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.2 Zero Copy Memory (CDP1) - See Zero Copy Memory above for......Zero copy system memory has id...",
    "content": "See Zero Copy Memory, above, for CDP2 version of document.\n\nZero- copy system memory has identical coherence and consistency guarantees to global memory, and follows the semantics detailed above. A kernel may not allocate or free zero- copy memory, but may use pointers to zero- copy passed in from the host program."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.3 Constant Memory (CDP1) - See Constant Memory above for ......Taking the address of a consta...",
    "content": "# 12.6.1.2.1.3 Constant Memory (CDP1)\nSee Constant Memory, above, for CDP2 version of document.\n\nConstants are immutable and may not be modified from the device, even between parent and child launches. That is to say, the value of all __constant__ variables must be set from the host prior to launch. Constant memory is inherited automatically by all child kernels from their respective parents.\n\nTaking the address of a constant memory object from within a kernel thread has the same semantics as for all CUDA programs, and passing that pointer from parent to child or from a child to parent is naturally supported."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.4 Shared and Local Memory (CDP1) - See Shared and Local Memory ab......The NVIDIA compiler will attem...",
    "content": "See Shared and Local Memory, above, for CDP2 version of document.\n\nShared and Local memory is private to a thread block or thread, respectively, and is not visible or coherent between parent and child. Behavior is undefined when an object in one of these locations is referenced outside of the scope within which it belongs, and may cause an error.\n\nThe NVIDIA compiler will attempt to warn if it can detect that a pointer to local or shared memory is being passed as an argument to a kernel launch. At runtime, the programmer may use the __isGlobal() intrinsic to determine whether a pointer references global memory and so may safely be passed to a child launch."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.4 Shared and Local Memory (CDP1) - Note that calls to cudaMemopyA...",
    "content": "Note that calls to cudaMemopy*Async() or cudaMemset*Async() may invoke new child kernels on the device in order to preserve stream semantics. As such, passing shared or local memory pointers to these APIs is illegal and will return an error."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.5 Local Memory (CDP1) - See Local Memory above for CDP......For example the following is i...",
    "content": "See Local Memory, above, for CDP2 version of document.\n\nLocal memory is private storage for an executing thread, and is not visible outside of that thread. It is illegal to pass a pointer to local memory as a launch argument when launching a child kernel. The result of dereferencing such a local memory pointer from a child will be undefined.\n\nFor example the following is illegal, with undefined behavior if x_array is accessed by child_launch:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.5 Local Memory (CDP1) - int xarray10  Creates xarray i...",
    "content": "int x_array[10]; // Creates x_array in parent's local memory child_launch  $\\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot$  1, 1 >>>(x_array);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.5 Local Memory (CDP1) - It is sometimes difficult for ...",
    "content": "It is sometimes difficult for a programmer to be aware of when a variable is placed into local memory by the compiler. As a general rule, all storage passed to a child kernel should be allocated explicitly from the global- memory heap, either with cudaMalloc(), new() or by declaring __device__ storage at global scope. For example:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.5 Local Memory (CDP1) - Correct  value is global stora...",
    "content": "// Correct - \"value\" is global storage - - device__ int value; - - device__ void x() { value = 5; child  $\\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle$  1, 1 >>>(&value); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.5 Local Memory (CDP1) - Invalid  value is local storag...",
    "content": "// Invalid - \"value\" is local storage - - device__ void y() { int value = 5; child \\(\\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\scriptstyle \\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script \\cdot \\script\\cdot \\script\\cdot \\script\\"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.5 Local Memory (CDP1) - cdot scriptcdot scriptcdot scr...",
    "content": "cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\textstyle \\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\scri"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.5 Local Memory (CDP1) - ptcdot scriptcdot scriptcdot s...",
    "content": "pt\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot\\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot\\script \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\cdot \\script\\scriptstyle \\scriptstyle"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.5 Local Memory (CDP1) - scriptstyle scriptstyle script...",
    "content": " \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\textstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scripts"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.5 Local Memory (CDP1) - tyle scriptstyle scriptstyle s...",
    "content": "tyle \\scriptstyle \\scriptstyle \\scriptstyle \\script\\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\textstyle \\textstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.5 Local Memory (CDP1) - scriptstyle scriptstyle script...",
    "content": " \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\script\\scriptstyle\\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle\\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.5 Local Memory (CDP1) - scriptstyle scriptstyle script...",
    "content": "scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\textstyle\\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\script\\scriptscriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyl"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.5 Local Memory (CDP1) - e scriptstyle scriptstyle scri...",
    "content": "e \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\begin{array}{l} \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle\\textstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scr"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.5 Local Memory (CDP1) - iptstyle scriptstyle scriptsty...",
    "content": "iptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\text\\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle \\scriptstyle "
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.5 Local Memory (CDP1)",
    "content": "\\]"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.6 Texture Memory (CDP1) - See Texture Memory above for C......Writs to the global memory reg...",
    "content": "See Texture Memory, above, for CDP2 version of document.\n\nWrits to the global memory region over which a texture is mapped are incoherent with respect to texture accesses. Coherence for texture memory is enforced at the invocation of a child grid and when a child grid completes. This means that writes to memory prior to a child kernel launch are reflected in texture memory accesses of the child. Similarly, writes to memory by a child will be reflected in the texture memory accesses by a parent, but only after the parent synchronizes on the child's completion. Concurrent accesses by parent and child may result in inconsistent data."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.1.2.1.6 Texture Memory (CDP1) - Warning Explicit synchronizati...",
    "content": "Warning: Explicit synchronization with child kernels from a parent block (i.e. using cudaDeviceSyncynchronize() in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2. Programming Interface (CDP1) - See Programming Interface abov...",
    "content": "See Programming Interface, above, for CDP2 version of document."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1 CUDA C++ Reference (CDP1) - See CUDA C Reference above for......The language interface and API...",
    "content": "See CUDA C++ Reference, above, for CDP2 version of document.\n\nThis section describes changes and additions to the CUDA C++ language extensions for supporting Dynamic Parallelism.\n\nThe language interface and API available to CUDA kernels using CUDA C++ for Dynamic Parallelism, referred to as the Device Runtime, is substantially like that of the CUDA Runtime API available on the host. Where possible the syntax and semantics of the CUDA Runtime API have been retained in order to facilitate ease of code reuse for routines that may run in either the host or device environments."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1 CUDA C++ Reference (CDP1) - As with all code in CUDA C the...",
    "content": "As with all code in CUDA C++, the APIs and code outlined here is per- thread code. This enables each thread to make unique, dynamic decisions regarding what kernel or operation to execute next. There are no synchronization requirements between threads within a block to execute any of the provided device runtime APIs, which enables the device runtime API functions to be called in arbitrarily divergent kernel code without deadlock."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.1 Device-Side Kernel Launch (CDP1) - See Device Side Kernel Launch ......kernelname Dg Db Ns S kernel a...",
    "content": "See Device- Side Kernel Launch, above, for CDP2 version of document.\n\nKernels may be launched from the device using the standard CUDA  $\\leq \\leq \\leq \\geq \\geq \\geq \\geq$  syntax:\n\nkernel_name<<< Dg, Db, Ns, S >>>([kernel arguments]);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.1 Device-Side Kernel Launch (CDP1) - Dg is of type dim3 and specifi...",
    "content": "Dg is of type dim3 and specifies the dimensions and size of the grid Db is of type dim3 and specifies the dimensions and size of each thread block Ns is of type size_t and specifies the number of bytes of shared memory that is dynamically allocated per thread block for this call and addition to statically allocated memory. Ns is an optional argument that defaults to 0. S is of type cudaStream_t and specifies the stream associated with this call. The stream must have been allocated in the same thread block where the call is being made. S is an optional argument that defaults to 0."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.1.1 Launches are Asynchronous (CDP1) - See Launches are Asynchronous ......Warning Explicit synchronizati...",
    "content": "See Launches are Asynchronous, above, for CDP2 version of document.\n\nIdentical to host- side launches, all device- side kernel launches are asynchronous with respect to the launching thread. That is to say, the  $\\leq \\leq \\leq \\geq \\geq \\geq \\geq$  launch command will return immediately and the launching thread will continue to execute until it hits an explicit launch- synchronization point such as cudaDeviceSynchronize().\n\nWarning: Explicit synchronization with child kernels from a parent block (i.e. using cudaDeviceSynchronize() in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.1.1 Launches are Asynchronous (CDP1) - The grid launch is posted to t...",
    "content": "The grid launch is posted to the device and will execute independently of the parent thread. The child grid may begin execution at any time after launch, but is not guaranteed to begin execution until the launching thread reaches an explicit launch- synchronization point."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.1.2 Launch Environment Configuration (CDP1) - See Launch Environment Configu......For host launched kernels per ...",
    "content": "# 12.6.2.1.1.2 Launch Environment Configuration (CDP1)\nSee Launch Environment Configuration, above, for CDP2 version of document.\n\nAll global device configuration settings (for example, shared memory and L1 cache size as returned from cudaDeviceGetCacheConfig(), and device limits returned from cudaDeviceGetLimit()) will be inherited from the parent. Likewise, device limits such as stack size will remain as- configured.\n\nFor host- launched kernels, per- kernel configurations set from the host will take precedence over the global setting. These configurations will be used when the kernel is launched from the device as well. It is not possible to reconfigure a kernel's environment from the device."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.2 Streams (CDP1) - See Streams above for CDP2 ver......Similar to host side launch wo...",
    "content": "See Streams, above, for CDP2 version of document.\n\nBoth named and unnamed (NULL) streams are available from the device runtime. Named streams may be used by any thread within a thread- block, but stream handles may not be passed to other blocks or child/parent kernels. In other words, a stream should be treated as private to the block in which it is created. Stream handles are not guaranteed to be unique between blocks, so using a stream handle within a block that did not allocate it will result in undefined behavior.\n\nSimilar to host- side launch, work launched into separate streams may run concurrently, but actual concurrency is not guaranteed. Programs that depend upon concurrency between child kernels are not supported by the CUDA programming model and will have undefined behavior."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.2 Streams (CDP1) - The host side NULL streams cro......As cudaStreamSynchronize and c...",
    "content": "The host- side NULL stream's cross- stream barrier semantic is not supported on the device (see below for details). In order to retain semantic compatibility with the host runtime, all device streams must be created using the cudaStreamCreateWithFlags() API, passing the cudaStreamNonBlocking flag. The cudaStreamCreate() call is a host- runtime- only API and will fail to compile for the device.\n\nAs cudaStreamSynchronize() and cudaStreamQuery() are unsupported by the device runtime, cudaDeviceSynchronize() should be used instead when the application needs to know that stream- launched child kernels have completed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.2 Streams (CDP1) - Warning Explicit synchronizati...",
    "content": "Warning: Explicit synchronization with child kernels from a parent block (i.e. using cudaDeviceSynchronize() in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.2.1 The Implicit (NULL) Stream (CDP1) - See The Implicit NULL Stream a......Within a host program the unna...",
    "content": "# 12.6.2.1.2.1 The Implicit (NULL) Stream (CDP1)\nSee The Implicit (NULL) Stream, above, for CDP2 version of document.\n\nWithin a host program, the unnamed (NULL) stream has additional barrier synchronization semantics with other streams (see Default Stream for details). The device runtime offers a single implicit, unnamed stream shared between all threads in a block, but as all named streams must be created with the cudaStreamNonBlocking flag, work launched into the NULL stream will not insert an implicit dependency on pending work in any other streams (including NULL streams of other thread blocks)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.3 Events (CDP1) - See Events above for CDP2 vers......Only the inter stream synchron...",
    "content": "See Events, above, for CDP2 version of document.\n\nOnly the inter- stream synchronization capabilities of CUDA events are supported. This means that cudaStreamWaitEvent() is supported, but cudaEventSynchronize(), cudaEventElapsedTime(), and cudaEventQuery() are not. As cudaEventElapsedTime() is not supported, cudaEvents must be created via cudaEventCreateWithFlags(), passing the cudaEventDisableTiming flag."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.3 Events (CDP1) - As for all device runtime obje...",
    "content": "As for all device runtime objects, event objects may be shared between all threads within the threadblock which created them but are local to that block and may not be passed to other kernels, or between blocks within the same kernel. Event handles are not guaranteed to be unique between blocks, so using an event handle within a block that did not create it will result in undefined behavior."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.4 Synchronization (CDP1) - See Synchronization above for ......The cudaDeviceSynchronize func...",
    "content": "See Synchronization, above, for CDP2 version of document.\n\nWarning: Explicit synchronization with child kernels from a parent block (i.e. using cudaDeviceSynchronize() in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.\n\nThe cudaDeviceSynchronize() function will synchronize on all work launched by any thread in the thread- block up to the point where cudaDeviceSynchronize() was called. Note that cudaDeviceSynchronize() may be called from within divergent code (see Block Wide Synchronization (CDP1))."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.4 Synchronization (CDP1) - It is up to the program to per...",
    "content": "It is up to the program to perform sufficient additional inter- thread synchronization, for example via a call to __syncthreads(), if the calling thread is intended to synchronize with child grids invoked from other threads."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.4.1 Block Wide Synchronization (CDP1) - See CUDA Dynamic Parallelism a......The cudaDeviceSynchronize func...",
    "content": "See CUDA Dynamic Parallelism, above, for CDP2 version of document.\n\nThe cudaDeviceSynchronize() function does not imply intra- block synchronization. In particular, without explicit synchronization via a __syncthreads() directive the calling thread can make no assumptions about what work has been launched by any thread other than itself. For example if multiple threads within a block are each launching work and synchronization is desired for all this work at once (perhaps because of event- based dependencies), it is up to the program to guarantee that this work is submitted by all threads before calling cudaDeviceSynchronize()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.4.1 Block Wide Synchronization (CDP1) - Because the implementation is ...",
    "content": "Because the implementation is permitted to synchronize on launches from any thread in the block, it is quite possible that simultaneous calls to cudaDeviceSynchronize() by multiple threads will drain all work in the first call and then have no effect for the later calls."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.6 Memory Declarations (CDP1) - See Device Management above fo......See Memory Declarations above ...",
    "content": "# 12.6.2.1.5 Device Management (CDP1)\nSee Device Management, above, for CDP2 version of document.\n\nOnly the device on which a kernel is running will be controllable from that kernel. This means that device APIs such as cudaSetDevice() are not supported by the device runtime. The active device as seen from the GPU (returned from cudaGetDevice()) will have the same device number as seen from the host system. The cudaDeviceGetAttribute() call may request information about another device as this API allows specification of a device ID as a parameter of the call. Note that the catch- all cudaGetDeviceProperties() API is not offered by the device runtime - properties must be queried individually.\n\n# 12.6.2.1.6 Memory Declarations (CDP1)\nSee Memory Declarations, above, for CDP2 version of document."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.6.1 Device and Constant Memory (CDP1) - See Device and Constant Memory......Memory declared at file scope ...",
    "content": "See Device and Constant Memory, above, for CDP2 version of document.\n\nMemory declared at file scope with __device__ or __constant__ memory space specifiers behaves identically when using the device runtime. All kernels may read or write device variables, whether the kernel was initially launched by the host or device runtime. Equivalently, all kernels will have the same view of __constant__s as declared at the module scope."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.6.2 Textures and Surfaces (CDP1) - See Textures and Surfaces abov......CUDA supports dynamically crea...",
    "content": "See Textures and Surfaces, above, for CDP2 version of document.\n\nCUDA supports dynamically created texture and surface objects<sup>Page 279, 14</sup>, where a texture reference may be created on the host, passed to a kernel, used by that kernel, and then destroyed from the host. The device runtime does not allow creation or destruction of texture or surface objects from within device code, but texture and surface objects created from the host may be used and passed around freely on the device. Regardless of where they are created, dynamically created texture objects are always valid and may be passed to child kernels from a parent."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.6.2 Textures and Surfaces (CDP1) - Note The device runtime does n...",
    "content": "Note: The device runtime does not support legacy module- scope (i.e., Fermi- style) textures and surfaces within a kernel launched from the device. Module- scope (legacy) textures may be created from the host and used in device code as for any kernel, but may only be used by a top- level kernel (i.e., the one which is launched from the host)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.6.3 Shared Memory Variable Declarations (CDP1) - See Shared Memory Variable Dec......In CUDA C shared memory can be...",
    "content": "See Shared Memory Variable Declarations, above, for CDP2 version of document.\n\nIn CUDA C++ shared memory can be declared either as a statically sized file- scope or function- scoped variable, or as an extern variable with the size determined at runtime by the kernel's caller via a launch configuration argument. Both types of declarations are valid under the device runtime."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.6.3 Shared Memory Variable Declarations (CDP1) - cppglobal void permuteint n in...",
    "content": "```cpp__global__ void permute(int n, int *data) {    extern __shared__ int smem[];    if (n <= 1)        return;    smem[threadIdx.x] = data[threadIdx.x];    __syncthreads();    permute_data(smem, n);    __syncthreads();    // Write back to GMEM since we can't pass SMEM to children.    data[threadIdx.x] = smem[threadIdx.x];    __syncthreads();    if (threadIdx.x == 0) {        permute<<< 1, 256, n/2 * sizeof(int)>>>(n/2, data);        permute<<< 1, 256, n/2 * sizeof(int)>>>(n/2, data + n/2);    }}void host_launch(int *data) {    permute<<< 1, 256, 256 * sizeof(int)>>>(256, data);}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.6.4 Symbol Addresses (CDP1) - See Symbol Addresses above for......Given that device side symbols...",
    "content": "# 12.6.2.1.6.4 Symbol Addresses (CDP1)\nSee Symbol Addresses, above, for CDP2 version of document.\n\nDevice- side symbols (i.e., those marked __device__) may be referenced from within a kernel simply via the & operator, as all global- scope device variables are in the kernel's visible address space. This also applies to __constant__ symbols, although in this case the pointer will reference read- only data.\n\nGiven that device- side symbols can be referenced directly, those CUDA runtime APIs which reference symbols (e.g., cudaIMemcpyToSymbol() or cudaGetSymbolAddress()) are redundant and hence not supported by the device runtime. Note this implies that constant data cannot be altered from within a running kernel, even ahead of a child kernel launch, as references to __constant__ space are readonly."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.7 API Errors and Launch Failures (CDP1) - See API Errors and Launch Fail......Similar to a host side launch ...",
    "content": "See API Errors and Launch Failures, above, for CDP2 version of document.\n\nAs usual for the CUDA runtime, any function may return an error code. The last error code returned is recorded and may be retrieved via the cudaGetLastError() call. Errors are recorded per- thread, so that each thread can identify the most recent error that it has generated. The error code is of type cudaError_t.\n\nSimilar to a host- side launch, device- side launches may fail for many reasons (invalid arguments, etc). The user must call cudaGetLastError() to determine if a launch generated an error, however lack of an error after launch does not imply the child kernel completed successfully."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.7 API Errors and Launch Failures (CDP1) - For device side exceptions eg ...",
    "content": "For device- side exceptions, e.g., access to an invalid address, an error in a child grid will be returned to the host instead of being returned by the parent's call to cudaDeviceSynchronize()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.7.1 Launch Setup APIs (CDP1) - See Launch Setup APIs above fo......Kernel launch is a system leve...",
    "content": "See Launch Setup APIs, above, for CDP2 version of document.\n\nKernel launch is a system- level mechanism exposed through the device runtime library, and as such is available directly from PTX via the underlying cudaGetParameterBuffer() and cudaLaunchDevice() APIs. It is permitted for a CUDA application to call these APIs itself, with the same requirements as for PTX in both cases, the user is then responsible for correctly populating all necessary data structures in the correct format according to specification. Backwards compatibility is guaranteed in these data structures."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.7.1 Launch Setup APIs (CDP1) - As with host side launch the d......Table 3 Table 5 New Deviceonly...",
    "content": "As with host- side launch, the device- side operator  $\\leq \\leq \\geq \\geq \\geq$  maps to underlying kernel launch APIs. This is so that users targeting PTX will be able to enact a launch, and so that the compiler front- end can translate  $\\leq \\leq \\geq \\geq \\geq$  into these calls.\n\nTable 3: Table 5. New Device-only Launch Implementation Functions"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.7.1 Launch Setup APIs (CDP1) - tabletrtdRuntime API Launch Fu......The APIs for these launch func...",
    "content": "<table><tr><td>Runtime API Launch Functions</td><td>Description of Difference From Host Runtime Behaviour (behavior is identical if no description)</td></tr><tr><td>cudaGetParameter-Buffer</td><td>Generated automatically from &amp;lt;&amp;lt;&amp;gt;&amp;gt;&gt;. Note different API to host equiv- alent.</td></tr><tr><td>cudaLaunchDevice</td><td>Generated automatically from &amp;lt;&amp;lt;&amp;gt;&amp;gt;&gt;. Note different API to host equiv- alent.</td></tr></table>\n\nThe APIs for these launch functions are different to those of the CUDA Runtime API, and are defined as follows:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.7.1 Launch Setup APIs (CDP1) - extern device cudaErrort cudaG...",
    "content": "extern device cudaError_t cudaGetParameterBuffer(void \\*\\*params); extern __device__ cudaError_t cudaLaunchDevice(void \\*kernel, void \\*params, dim3 gridDim, dim3 blockDim, unsigned int sharedMemSize  $= \\theta$  cudaStream_t stream  $= \\theta$"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.8 API Reference (CDP1) - See API Reference above for CD......Table 4Table 6 Supported API F...",
    "content": "See API Reference, above, for CDP2 version of document.\n\nThe portions of the CUDA Runtime API supported in the device runtime are detailed here. Host and device runtime APIs have identical syntax; semantics are the same except where indicated. The table below provides an overview of the API relative to the version available from the host.\n\nTable 4:Table 6. Supported API Functions"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.1.8 API Reference (CDP1) - tabletrtdRuntime API Functions......Note that call ing this API fr...",
    "content": "<table><tr><td>Runtime API Functions</td><td>Details</td></tr><tr><td rowspan=\"2\">cudaDeviceSynchronize</td><td>Synchronizes on work launched from thread&#x27;s own block only.</td></tr><tr><td>Warning:\nNote that call- ing this API from code is ep- rated CUDA 11.6, removed for com- pute_90+ com- p- l- tion, and is stated for full re- moval if future CUDA re- lase.</td></tr><tr><td>cudaDeviceGetCacheConfig</td><td></td></tr><tr><td>cudaDeviceGetLimit</td><td></td></tr><tr><td>cudaGetLastError</td><td>Last error is per-thread state, not per-block state</td></tr><tr><td>cudaPeekAtLastError</td><td>303</td></tr><tr><td>cudaGetDeviceCount</td><td></td></tr><tr><td>cudaDeviceGetAttribute</td><td>Will return attributes for any device</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.2 Device-side Launch from PTX (CDP1) - See Device side Launch from PT......This section is for the progra...",
    "content": "See Device- side Launch from PTX, above, for CDP2 version of document.\n\nThis section is for the programming language and compiler implementers who target Parallel Thread Execution (PTX) and plan to support Dynamic Parallelism in their language. It provides the low- level details related to supporting kernel launches at the PTX level."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.2.1 Kernel Launch APIs (CDP1) - See Kernel Launch APIs above f......Device side kernel launches ca...",
    "content": "# 12.6.2.2.1 Kernel Launch APIs (CDP1)\nSee Kernel Launch APIs, above, for CDP2 version of document.\n\nDevice- side kernel launches can be implemented using the following two APIs accessible from PTX: cudaLaunchDevice() and cudaGetParameterBuffer(). cudaLaunchDevice() launches the specified kernel with the parameter buffer that is obtained by calling cudaGetParameterBuffer() and filled with the parameters to the launched kernel. The parameter buffer can be NULL, i.e., no need to invoke cudaGetParameterBuffer(), if the launched kernel does not take any parameters."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.2.1.1 cudaLaunchDevice (CDP1) - See cudaLaunchDevice above for......PTX level Declaration of cudaL...",
    "content": "See cudaLaunchDevice, above, for CDP2 version of document.\n\nAt the PTX level, cudaLaunchDevice() needs to be declared in one of the two forms shown below before it is used.\n\n// PTX- level Declaration of cudaLaunchDevice() when .address_size is 64 .extern .func(.param .b32 func_retval0) cudaLaunchDevice ( .param .b64 func, .param .b64 parameterBuffer, .param .align 4 .b8 gridDimension[12], .param .align 4 .b8 blockDimension[12], .param .b32 sharedMemSize, .param .b64 stream ) ;\n\n// PTX- level Declaration of cudaLaunchDevice() when .address_size is 32 .extern .func(.param .b32 func_retval0) cudaLaunchDevice ( .param .b32 func, .param .b32 parameterBuffer, .param .align 4 .b8 gridDimension[12], .param .align 4 .b8 blockDimension[12], .param .b32 sharedMemSize, .param .b32 stream ) ;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.2.1.1 cudaLaunchDevice (CDP1) - The CUDA level declaration bel......CUDA level declaration of cuda...",
    "content": "The CUDA- level declaration below is mapped to one of the aforementioned PTX- level declarations and is found in the system header file cuda_device_runtime_api.h. The function is defined in the cudadevrt system library, which must be linked with a program in order to use device- side kernel launch functionality.\n\n// CUDA- level declaration of cudaLaunchDevice()extern \"C\" __device__cudaError_t cudaLaunchDevice(void *func, void *parameterBuffer,    dim3 gridDimension, dim3 blockDimension,    unsigned int sharedMemSize,    cudaStream_t stream);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.2.1.1 cudaLaunchDevice (CDP1) - The first parameter is a point...",
    "content": "The first parameter is a pointer to the kernel to be is launched, and the second parameter is the parameter buffer that holds the actual parameters to the launched kernel. The layout of the parameter buffer is explained in Parameter Buffer Layout (CDP1), below. Other parameters specify the launch configuration, i.e., as grid dimension, block dimension, shared memory size, and the stream associated with the launch (please refer to Execution Configuration for the detailed description of launch configuration."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.2.1.2 cudaGetParameterBuffer (CDP1) - See cudaGetParameterBuffer abo......The following CUDA level decla...",
    "content": "See cudaGetParameterBuffer, above, for CDP2 version of document.\n\ncudaGetParameterBuffer() needs to be declared at the PTX level before it's used. The PTX- level declaration must be in one of the two forms given below, depending on address size:\n\n// PTX- level Declaration of cudaGetParameterBuffer() when .address_size is 64// When .address_size is 64extern .func(.param .b64 func_retval0) cudaGetParameterBuffer(.param .b64 alignment,.param .b64 size);\n\n// PTX- level Declaration of cudaGetParameterBuffer() when .address_size is 32extern .func(.param .b32 func_retval0) cudaGetParameterBuffer(.param .b32 alignment,.param .b32 size);\n\nThe following CUDA- level declaration of cudaGetParameterBuffer() is mapped to the aforementioned PTX- level declaration:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.2.1.2 cudaGetParameterBuffer (CDP1) - CUDA level Declaration of cuda......The first parameter specifies ...",
    "content": "// CUDA- level Declaration of cudaGetParameterBuffer()extern \"C\" __device__void *cudaGetParameterBuffer(size_t alignment, size_t size);\n\nThe first parameter specifies the alignment requirement of the parameter buffer and the second parameter the size requirement in bytes. In the current implementation, the parameter buffer returned by cudaGetParameterBuffer() is always guaranteed to be 64- byte aligned, and the alignment requirement parameter is ignored. However, it is recommended to pass the correct alignment requirement value - which is the largest alignment of any parameter to be placed in the parameter buffer - to cudaGetParameterBuffer() to ensure portability in the future."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.3 Toolkit Support for Dynamic Parallelism (CDP1) - See Parameter Buffer Layout ab......See Toolkit Support for Dynami...",
    "content": "# 12.6.2.2.2 Parameter Buffer Layout (CDP1)\nSee Parameter Buffer Layout, above, for CDP2 version of document.\n\nParameter reordering in the parameter buffer is prohibited, and each individual parameter placed in the parameter buffer is required to be aligned. That is, each parameter must be placed at the  $n^{\\mathrm{th}}$  byte in the parameter buffer, where  $n$  is the smallest multiple of the parameter size that is greater than the offset of the last byte taken by the preceding parameter. The maximum size of the parameter buffer is 4KB.\n\nFor a more detailed description of PTX code generated by the CUDA compiler, please refer to the PTX3.5 specification.\n\n# 12.6.2.3 Toolkit Support for Dynamic Parallelism (CDP1)\nSee Toolkit Support for Dynamic Parallelism, above, for CDP2 version of document."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.3.1 Including Device Runtime API in CUDA Code (CDP1) - See Including Device Runtime A......Similar to the host side runti...",
    "content": "See Including Device Runtime API in CUDA Code, above, for CDP2 version of document.\n\nSimilar to the host- side runtime API, prototypes for the CUDA device runtime API are included automatically during program compilation. There is no need to include cuda_device_runtime_api.h explicitly."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.3.2 Compiling and Linking (CDP1) - See Compiling and Linking abov......nvcc  archsm75  rdctrue hellow...",
    "content": "See Compiling and Linking, above, for CDP2 version of document.\n\nWhen compiling and linking CUDA programs using dynamic parallelism with nvcc, the program will automatically link against the static device runtime library libcudadevrt.\n\nThe device runtime is offered as a static library (cudadevrt . lib on Windows, libcudadevrt . a under Linux), against which a GPU application that uses the device runtime must be linked. Linking of device libraries can be accomplished through nvcc and/or nvlink. Two simple examples are shown below.\n\nA device runtime program may be compiled and linked in a single step, if all required source files can be specified from the command line:\n\n$ nvcc - arch=sm_75 - rdc=true hello_world.cu - o hello - lcudadevrt"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.2.3.2 Compiling and Linking (CDP1) - It is also possible to compile......Please see the Using Separate ...",
    "content": "It is also possible to compile CUDA .cu source files first to object files, and then link these together in a two- stage process:\n\n$ nvcc - arch=sm_75 - dc hello_world.cu - o hello_world.o  $ nvcc - arch=sm_75 - rdc=true hello_world.o - o hello - lcudadevrt\n\nPlease see the Using Separate Compilation section of The CUDA Driver Compiler NVCC guide for more details."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3. Programming Guidelines (CDP1) - See Programming Guidelines abo...",
    "content": "See Programming Guidelines, above, for CDP2 version of document."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.1 Basics (CDP1) - See Basics above for CDP2 vers......Warning Explicit synchronizati...",
    "content": "See Basics, above, for CDP2 version of document.\n\nThe device runtime is a functional subset of the host runtime. API level device management, kernel launching, device memcpy, stream management, and event management are exposed from the device runtime.\n\nProgramming for the device runtime should be familiar to someone who already has experience with CUDA. Device runtime syntax and semantics are largely the same as that of the host API, with any exceptions detailed earlier in this document.\n\nWarning: Explicit synchronization with child kernels from a parent block (i.e. using cudaDeviceSynchronize() in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.1 Basics (CDP1) - The following example shows a ......This program may be built in a...",
    "content": "The following example shows a simple Hello World program incorporating dynamic parallelism:\n\ninclude <stdio.h> _global__ void childKernel() { printf(\"Hello \"); } _global__ void parentKernel() { // launch child childKernel  $\\leq \\leq \\leq 1$ $1 > > > ($  ; if (cudaSuccess  $! =$  cudaGetLastError()) { return; } // wait for child to complete if (cudaSuccess  $! =$  cudaDeviceSynchronize()) { return; } printf(\"World!\\n\"); } int main(int argc, char \\*argv[]) { // launch parent parentKernel  $\\leq \\leq \\leq 1$ $1 > > > ($  ; if (cudaSuccess  $! =$  cudaGetLastError()) { return 1; } // wait for parent to complete\n\nif (cudaSuccess  $! =$  cudaDeviceSynchronize()）{ return 2; } return 0; }\n\nThis program may be built in a single step from the command line as follows:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.1 Basics (CDP1) - mathfraks  nvcc  arch  equiv  ...",
    "content": "$\\mathfrak{s}$  nvcc - arch  $\\equiv$  sm_75 - rdc  $\\equiv$  true hello_world.cu - o hello - lcudadevrt"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.2 Performance (CDP1) - See Performance above for CDP2...",
    "content": "See Performance, above, for CDP2 version of document."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.2.1 Synchronization (CDP1) - See CUDA Dynamic Parallelism a......Warning Explicit synchronizati...",
    "content": "See CUDA Dynamic Parallelism, above, for CDP2 version of document.\n\nWarning: Explicit synchronization with child kernels from a parent block (such as using cudaDeviceSynchronize() in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.2.1 Synchronization (CDP1) - Synchronization by one thread ...",
    "content": "Synchronization by one thread may impact the performance of other threads in the same Thread Block, even when those other threads do not call cudaDeviceSynchronize() themselves. This impact will depend upon the underlying implementation. In general the implicit synchronization of child kernels done when a thread block ends is more efficient compared to calling cudaDeviceSynchronize() explicitly. It is therefore recommended to only call cudaDeviceSynchronize() if it is needed to synchronize with a child kernel before a thread block ends."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.2.2 Dynamic-parallelism-enabled Kernel Overhead (CDP1) - See Dynamic parallelism enable......System software which is activ...",
    "content": "# 12.6.3.2.2 Dynamic-parallelism-enabled Kernel Overhead (CDP1)\nSee Dynamic- parallelism- enabled Kernel Overhead, above, for CDP2 version of document.\n\nSystem software which is active when controlling dynamic launches may impose an overhead on any kernel which is running at the time, whether or not it invokes kernel launches of its own. This overhead arises from the device runtime's execution tracking and management software and may result in decreased performance for example, library calls when made from the device compared to from the host side. This overhead is, in general, incurred for applications that link against the device runtime library."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.3.1 Runtime (CDP1) - See Implementation Restriction......See Runtime above for CDP2 ver...",
    "content": "See Implementation Restrictions and Limitations, above, for CDP2 version of document.\n\nDynamic Parallelism guarantees all semantics described in this document, however, certain hardware and software resources are implementation- dependent and limit the scale, performance and other properties of a program which uses the device runtime.\n\n# 12.6.3.3.1 Runtime (CDP1)\nSee Runtime, above, for CDP2 version of document."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.3.1.1 Memory Footprint (CDP1) - See Memory Footprint above for......The device runtime system soft...",
    "content": "See Memory Footprint, above, for CDP2 version of document.\n\nThe device runtime system software reserves memory for various management purposes, in particular one reservation which is used for saving parent- grid state during synchronization, and a second reservation for tracking pending grid launches. Configuration controls are available to reduce the size of these reservations in exchange for certain launch limitations. See Configuration Options (CDP1), below, for details."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.3.1.1 Memory Footprint (CDP1) - The majority of reserved memor...",
    "content": "The majority of reserved memory is allocated as backing- store for parent kernel state, for use when synchronizing on a child launch. Conservatively, this memory must support storing of state for the maximum number of live threads possible on the device. This means that each parent generation at which cudaDeviceSynchronize() is callable may require up to 860MB of device memory, depending on the device configuration, which will be unavailable for program use even if it is not all consumed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.3.1.2 Nesting and Synchronization Depth (CDP1) - See CUDA Dynamic Parallelism a......Using the device runtime one k...",
    "content": "See CUDA Dynamic Parallelism, above, for CDP2 version of document.\n\nUsing the device runtime, one kernel may launch another kernel, and that kernel may launch another, and so on. Each subordinate launch is considered a new nesting level, and the total number of levels is the nesting depth of the program. The synchronization depth is defined as the deepest level at which the program will explicitly synchronize on a child launch. Typically this is one less than the nesting depth of the program, but if the program does not need to call cudaDeviceSynchronize() at all levels then the synchronization depth might be substantially different to the nesting depth."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.3.1.2 Nesting and Synchronization Depth (CDP1) - Warning Explicit synchronizati......The overall maximum nesting de...",
    "content": "Warning: Explicit synchronization with child kernels from a parent block (i.e. using cudaDeviceSynchronize() in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.\n\nThe overall maximum nesting depth is limited to 24, but practically speaking the real limit will be the amount of memory required by the system for each new level (see Memory Footprint (CDP1) above). Any launch which would result in a kernel at a deeper level than the maximum will fail. Note that this may also apply to cudaMemopyAsync(), which might itself generate a kernel launch. See Configuration Options (CDP1) for details."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.3.1.2 Nesting and Synchronization Depth (CDP1) - By default sufficient storage ......and specifying cudaLimitDevRun...",
    "content": "By default, sufficient storage is reserved for two levels of synchronization. This maximum synchronization depth (and hence reserved storage) may be controlled by calling cudaDeviceSetLimit()\n\nand specifying cudaLimitDevRuntimeSyncDepth. The number of levels to be supported must be configured before the top- level kernel is launched from the host, in order to guarantee successful execution of a nested program. Calling cudaDeviceSynchronize() at a depth greater than the specified maximum synchronization depth will return an error."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.3.1.2 Nesting and Synchronization Depth (CDP1) - An optimization is permitted w...",
    "content": "An optimization is permitted where the system detects that it need not reserve space for the parent's state in cases where the parent kernel never calls cudaDeviceSynchronize(). In this case, because explicit parent/child synchronization never occurs, the memory footprint required for a program will be much less than the conservative maximum. Such a program could specify a shallower maximum synchronization depth to avoid over- allocation of backing store."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.3.1.3 Pending Kernel Launches (CDP1) - See Pending Kernel Launches ab......The size of the fixed size lau...",
    "content": "# 12.6.3.3.1.3 Pending Kernel Launches (CDP1)\nSee Pending Kernel Launches, above, for CDP2 version of document.\n\nWhen a kernel is launched, all associated configuration and parameter data is tracked until the kernel completes. This data is stored within a system- managed launch pool.\n\nThe launch pool is divided into a fixed- size pool and a virtualized pool with lower performance. The device runtime system software will try to track launch data in the fixed- size pool first. The virtualized pool will be used to track new launches when the fixed- size pool is full.\n\nThe size of the fixed- size launch pool is configurable by calling cudaDeviceSetLimit() from the host and specifying cudaLimitDevRuntimePendingLaunchCount."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.3.1.4 Configuration Options (CDP1) - See Configuration Options abov......The following named limits may...",
    "content": "See Configuration Options, above, for CDP2 version of document.\n\nResource allocation for the device runtime system software is controlled via the cudaDeviceSetLimit() API from the host program. Limits must be set before any kernel is launched, and may not be changed while the GPU is actively running programs.\n\nWarning: Explicit synchronization with child kernels from a parent block (i.e. using cudaDeviceSynchronize() in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.\n\nThe following named limits may be set:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.3.1.4 Configuration Options (CDP1) - tabletrtdLimittdtdBehaviortdtr...",
    "content": "<table><tr><td>Limit</td><td>Behavior</td></tr><tr><td>cud-aLim-itDe-vRun-timeSync</td><td>Sets the maximum depth at which cudaDeviceSynchronize() may be called. Launches may be performed deeper than this, but explicit synchronization deeper than this limit will return the cudaErrorLaunchMaxDepthExceeded. The default maximum sync depth is 2.</td></tr><tr><td>cud-aLim-itDe-vRun-timePendCount</td><td>Controls the amount of memory set aside for buffering kernel launches which have not yet begun to execute, due either to unresolved dependencies or lack of execution resources. When the buffer is full, the device runtime system software will attempt to track new pending launches in a lower performance virtualized buffer."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.3.1.4 Configuration Options (CDP1) - If the virtualized buffer is a...",
    "content": " If the virtualized buffer is also pending Launch, it is when all available heap space is consumed, launches will not occur, and the thread&#x27;s data stack error will be set to cudaErrorLaunchPendingCountExceeded. The default pending launch count is 2048 launches.</td></tr><tr><td>cud-aLim-it-Stack-Size</td><td>Controls the stack size in bytes of each GPU thread. The CUDA driver automatically increases the per-thread stack size for each kernel launch as needed. This size isn&#x27;t reset back to the original value after each launch. To set the per-thread stack size to a different value, cudaDeviceSetLimit() can be called to set this limit. The stack will be immediately resized, and if necessary, the device will block until all preceding requested tasks are complete."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.3.1.4 Configuration Options (CDP1) - cudaDeviceGetLimit can be call...",
    "content": " cudaDeviceGetLimit() can be called to get the current per-thread stack size.</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.3.1.5 Memory Allocation and Lifetime (CDP1) - See Memory Allocation and Life......cudaMalloc and cudaFree have d...",
    "content": "See Memory Allocation and Lifetime, above, for CDP2 version of document.\n\ncudaMalloc() and cudaFree() have distinct semantics between the host and device environments. When invoked from the host, cudaMalloc() allocates a new region from unused device memory. When invoked from the device runtime, these functions map to device- side malloc() and free(). This implies that within the device environment, the total allocatable memory is limited to the device malloc() heap size, which may be smaller than the available unused device memory. Also, it is an error to invoke cudaFree() from the host program on a pointer which was allocated by cudaMalloc() on the device or vice- versa."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.3.1.5 Memory Allocation and Lifetime (CDP1) - tabletrtdtdtdcudaMalloc on Hos...",
    "content": "<table><tr><td></td><td>cudaMalloc() on Host</td><td>cudaMalloc() on Device</td></tr><tr><td>cudaFree() on Host</td><td>Supported</td><td>Not Supported</td></tr><tr><td>cudaFree() on Device</td><td>Not Supported</td><td>Supported</td></tr><tr><td>Allocation limit</td><td>Free device memory</td><td>cudaLimitMallocHeapSize</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "12.6.3.3.1.7 ECC Errors (CDP1) - See SM Id and Warp Id above fo......No notification of ECC errors ...",
    "content": "# 12.6.3.3.1.6 SM Id and Warp Id (CDP1)\nSee SM Id and Warp Id, above, for CDP2 version of document.\n\nNote that in PTX %smid and %warpid are defined as volatile values. The device runtime may reschedule thread blocks onto different SMs in order to more efficiently manage resources. As such, it is unsafe to rely upon %smid or %warpid remaining unchanged across the lifetime of a thread or thread block.\n\n# 12.6.3.3.1.7 ECC Errors (CDP1)\nSee ECC Errors, above, for CDP2 version of document.\n\nNo notification of ECC errors is available to code within a CUDA kernel. ECC errors are reported at the host side once the entire launch tree has completed. Any ECC errors which arise during execution of a nested program will either generate an exception or continue execution (depending upon error and configuration)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 13. Virtual Memory Management",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.1. Introduction - The Virtual Memory Management ...",
    "content": "The Virtual Memory Management APIs provide a way for the application to directly manage the unified virtual address space that CUDA provides to map physical memory to virtual addresses accessible by the GPU. Introduced in CUDA 10.2, these APIs additionally provide a new way to interop with other processes and graphics APIs like OpenGL and Vulkan, as well as provide newer memory attributes that a user can tune to fit their applications."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.1. Introduction - Historically memory allocation...",
    "content": "Historically, memory allocation calls (such as cudaMalloc()) in the CUDA programming model have returned a memory address that points to the GPU memory. The address thus obtained could be used with any CUDA API or inside a device kernel. However, the memory allocated could not be resized depending on the user's memory needs. In order to increase an allocation's size, the user had to explicitly allocate a larger buffer, copy data from the initial allocation, free it and then continue to keep track of the newer allocation's address. This often leads to lower performance and higher peak memory utilization for applications. Essentially, users had a malloc- like interface for allocating GPU memory, but did not have a corresponding realloc to complement it."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.1. Introduction - The Virtual Memory Management ...",
    "content": " The Virtual Memory Management APIs decouple the idea of an address and memory and allow the application to handle them separately. The APIs allow applications to map and unmap memory from a virtual address range as they see fit."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.1. Introduction - In the case of enabling peer d......The CUDA Virtual Memory Manage...",
    "content": "In the case of enabling peer device access to memory allocations by using cudaEnablePeerAccess, all past and future user allocations are mapped to the target peer device. This lead to users unwittingly paying runtime cost of mapping all cudaMalloc allocations to peer devices. However, in most situations applications communicate by sharing only a few allocations with another device and not all allocations are required to be mapped to all the devices. With Virtual Memory Management, applications can specifically choose certain allocations to be accessible from target devices.\n\nThe CUDA Virtual Memory Management APIs expose fine grained control to the user for managing the GPU memory in applications. It provides APIs that let users:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.1. Introduction - In order to allocate memory th......Note that the suite of APIs de...",
    "content": "- Place memory allocated on different devices into a contiguous VA range.- Perform interprocess communication for memory sharing using platform-specific mechanisms.- Opt into newer memory types on the devices that support them.\n\nIn order to allocate memory, the Virtual Memory Management programming model exposes the following functionality:\n\nAllocating physical memory. Reserving a VA range.\n\nMapping allocated memory to the VA range. Controlling access rights on the mapped range.\n\nNote that the suite of APIs described in this section require a system that supports UVA."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.2. Query for Support - Before attempting to use Virtu......int deviceSupportsVmm CUresult...",
    "content": "Before attempting to use Virtual Memory Management APIs, applications must ensure that the devices they want to use support CUDA Virtual Memory Management. The following code sample shows querying for Virtual Memory Management support:\n\nint deviceSupportsVmm; CUresult result  $=$  cuDeviceGetAttribute(&deviceSupportsVmm, CU_DEVICE_ATTRIBUTE_  $\\rightharpoonup$  VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED, device); if (deviceSupportsVmm  $! = \\Theta$  ){ // 'device' supports Virtual Memory Management }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.3. Allocating Physical Memory - The first step in memory alloc...",
    "content": "The first step in memory allocation using Virtual Memory Management APIs is to create a physical memory chunk that will provide a backing for the allocation. In order to allocate physical memory, applications must use the cuMemCreate API. The allocation created by this function does not have any device or host mappings. The function argument CUmemGenericAllocationHandle describes the properties of the memory to allocate such as the location of the allocation, if the allocation is going to be shared to another process (or other Graphics APIs), or the physical attributes of the memory to be allocated. Users must ensure the requested allocation's size must be aligned to appropriate granularity."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.3. Allocating Physical Memory - Information regarding an alloc...",
    "content": " Information regarding an allocation's granularity requirements can be queried using cuMemGetAllocationGranularity. The following code snippet shows allocating physical memory with cuMemCreate:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.3. Allocating Physical Memory - CUMemGenericAllocationHandle a...",
    "content": "CUMemGenericAllocationHandle allocatePhysicalMemory(int device, size_t size) { CUmemAllocationProp prop  $=$  {}; prop.type  $=$  CU_MEM_ALLOCATION_TYPEPINNED; prop.location_type  $=$  CU_MEM_LOCATION_TYPE_DEVICE; prop.location_id  $=$  device; cuMemGetAllocationGranularity(&granularity, &prop, CU_MEM_ALLOC_GRANULARITY MINIMUM); // Ensure size matches granularity requirements for the allocation size_t padded_size  $=$  ROUND_UP(size, granularity); // Allocate physical memory CUmemGenericAllocationHandle allocHandle; cuMemCreate(&allocHandle, padded_size, &prop, 0); return allocHandle; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.3. Allocating Physical Memory - The memory allocated by cuMemC...",
    "content": "The memory allocated by cuMemCreate is referenced by the CUmemGenericAllocationHandle it returns. This is a departure from the cudaMalloc- style of allocation, which returns a pointer to the GPU memory, which was directly accessible by CUDA kernel executing on the device. The memory allocated cannot be used for any operations other than querying properties using cuMemGetAllocationPropertiesFromHandle. In order to make this memory accessible, applications must map this memory into a VA range reserved by cuMemAddressReserve and provide suitable access rights to it. Applications must free the allocated memory using the cuMemRelease API."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.3.1. Shareable Memory Allocations - With cuMemCreate users now hav...",
    "content": "With cuMemCreate users now have the facility to indicate to CUDA, at allocation time, that they have earmarked a particular allocation for Inter process communication and graphics interop purposes. Applications can do this by setting CUmemAllocationProp::requestedHandleTypes to a platform- specific field. On Windows, when CUmemAllocationProp::requestedHandleTypes is set to CU_MEM_HANDLE_TYPE_WIN32 applications must also specify an LPSECURITYATTRIBUTES attribute in CUmemAllocationProp::win32HandleMetaData. This security attribute defines the scope of which exported allocations may be transferred to other processes."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.3.1. Shareable Memory Allocations - The CUDA Virtual Memory Manage......Users must ensure they query f...",
    "content": "The CUDA Virtual Memory Management API functions do not support the legacy interprocess communication functions with their memory. Instead, they expose a new mechanism for interprocess communication that uses OS- specific handles. Applications can obtain these OS- specific handles corresponding to the allocations by using cuMemExportToShareableHandle. The handles thus obtained can be transferred by using the usual OS native mechanisms for inter process communication. The recipient process should import the allocation by using cuMemImportFromShareableHandle.\n\nUsers must ensure they query for support of the requested handle type before attempting to export memory allocated with cuMemCreate. The following code snippet illustrates query for handle type support in a platform- specific way."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.3.1. Shareable Memory Allocations - int deviceSupportsIpcHandle if......The memMaplpcOrv sample can be...",
    "content": "int deviceSupportsIpcHandle; #if defined(_1inux__) cuDeviceGetAttribute(&deviceSupportsIpcHandle, CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_ - POsIX_FILE_DEscRIPTOR_SUPPORTED, device)); #else cuDeviceGetAttribute(&deviceSupportsIpcHandle, CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_ - WIN32_HANDLE_SUPPORTED, device)); #endif\n\nUsers should set the CUmemAllocationProp::requestedHandleTypes appropriately as shown below:\n\nif defined(_1inux__) prop.requestedHandleTypes = CU_MEM_HANDLE_TYPE_POSIX_FILE_DEscRIPTOR; #else prop.requestedHandleTypes = CU_MEM_HANDLE_TYPE_WIN32; prop.win32HandleMetaData = // Windows specific LPSECURITYATTRIBUTES attribute. #endif\n\nThe memMaplpcOrv sample can be used as an example for using IPC with Virtual Memory Management allocations."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.3.2. Memory Type - Before CUDA 102 applications h...",
    "content": "Before CUDA 10.2, applications had no user- controlled way of allocating any special type of memory that certain devices may support. With cuMemCreate, applications can additionally specify memory type requirements using the CUmemAllocationProp::allocFlags to opt into any specific memory features. Applications must also ensure that the requested memory type is supported on the device of allocation."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.3.2.1. Compressible Memory - Compressible memory can be use...",
    "content": "Compressible memory can be used to accelerate accesses to data with unstructured sparsity and other compressible data patterns. Compression can save DRAM bandwidth, L2 read bandwidth and L2 capacity depending on the data being operated on. Applications that want to allocate compressible memory on devices that support Compute Data Compression can do so by setting CUmemAllocationProp::allocFlags::compressionType to CU_MEM_ALLOCATION_COMP_GENERIC. Users must query if device supports Compute Data Compression by using CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED. The following code snippet illustrates querying compressible memory support cuDeviceGetAttribute."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.3.2.1. Compressible Memory - int compressionSupported   the......Due to various reasons such as...",
    "content": "int compressionSupported  $= \\theta$  . cuDeviceGetAttribute(&compressionSupported, CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_ SUPPORTED, device);\n\nOn devices that support Compute Data Compression, users must opt in at allocation time as shown below:\n\nprop.allocFlags.compressionType  $=$  CU_MEM_ALLOCATION_COMP_GENERIC;\n\nDue to various reasons such as limited HW resources, the allocation may not have compression attributes, the user is expected to query back the properties of the allocated memory using cuMemGe tAllocationPropertiesFromHandle and check for compression attribute."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.3.2.1. Compressible Memory - CUMemAllocationPropPrivate all...",
    "content": "CUMemAllocationPropPrivate allocationProp  $=$  {}; cuMemGetAllocationPropertiesFromHandle(&allocationProp, allocationHandle); if (allocationProp.allocFlags.compressionType  $= =$  CU_MEM_ALLOCATION_COMP_GENERIC) { // Obtained compressible memory allocation } }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.4. Reserving a Virtual Address Range - Since with Virtual Memory Mana......Applications can reserve a vir...",
    "content": "Since with Virtual Memory Management the notions of address and memory are distinct, applications must carve out an address range that can hold the memory allocations made by cuMemCreate. The address range reserved must be at least as large as the sum of the sizes of all the physical memory allocations the user plans to place in them.\n\nApplications can reserve a virtual address range by passing appropriate parameters to cuMemAd. dressReserve. The address range obtained will not have any device or host physical memory associated with it. The reserved virtual address range can be mapped to memory chunks belonging to any device in the system, thus providing the application a continuous VA range backed and mapped by"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.4. Reserving a Virtual Address Range - memory belonging to different ......cppCdeviceptr ptr  ptr holds t...",
    "content": "memory belonging to different devices. Applications are expected to return the virtual address range back to CUDA using cuMemAddressFree. Users must ensure that the entire VA range is unmapped before calling cuMemAddressFree. These functions are conceptually similar to mmap/munmap (on Linux) or VirtualAlloc/VirtualFree (on Windows) functions. The following code snippet illustrates the usage for the function:\n\n```cppCdeviceptr ptr; // `ptr` holds the returned start of virtual address range reserved. CUresult result = cuMemAddressReserve(&ptr, size, 0, 0, 0); // alignment = 0 for _default alignment```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.5. Virtual Aliasing Support - The Virtual Memory Management ......For example the following snip...",
    "content": "The Virtual Memory Management APIs provide a way to create multiple virtual memory mappings or \"proxies\" to the same allocation using multiple calls to cuMemMap with different virtual addresses, so- called virtual aliasing. Unless otherwise noted in the PTX ISA, writes to one proxy of the allocation are considered inconsistent and incoherent with any other proxy of the same memory until the writing device operation (grid launch, memcpy, memset, and so on) completes. Grids present on the GPU prior to a writing device operation but reading after the writing device operation completes are also considered to have inconsistent and incoherent proxies.\n\nFor example, the following snippet is considered undefined, assuming device pointers A and B are virtual aliases of the same memory allocation:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.5. Virtual Aliasing Support - cppglobal void foochar A char ......The following is defined behav...",
    "content": "```cpp__global__ void foo(char *A, char *B) {    *A = 0x1;    printf(\"%d\\n\", *B); // Undefined behavior! *B can take on either    // the previous value or some value in- between.}```\n\nThe following is defined behavior, assuming these two kernels are ordered monotonically (by streams or events)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.5. Virtual Aliasing Support - global void foo1char A A0x1...global void foo2char B  printf...",
    "content": "- -global__ void foo1(char \\*A) \\*A=0x1; } \n--global__ void foo2(char \\*B) { printf(\"%d\\n\", \\*B); // \\*B == \\*A == 0x1 assuming foo2 waits for foo1 // to complete before launching } cudaMempcyAsync(B, input, size, stream1); // Aliases are allowed at // operation boundaries foo1  $\\epsilon < < 1$  ,1,0,stream1  $\\geq \\geq \\geq$  (A); // allowing foo1 to access A. cudaEventRecord(event, stream1); cudaStreamWaitEvent(stream2, event); foo2  $\\epsilon < < 1$  ,1,0,stream2  $\\geq \\geq \\geq$  (B); cudaStreamWaitEvent(stream3, event); cudaMempcyAsync(output, B, size, stream3); // Both launches of foo2 and // cudaMempcy (which both // read) wait for foo1 (which writes) // to complete before proceeding"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.6. Mapping Memory - The allocated physical memory ...",
    "content": "The allocated physical memory and the carved out virtual address space from the previous two sections represent the memory and address distinction introduced by the Virtual Memory Management APIs. For the allocated memory to be useable, the user must first place the memory in the address space. The address range obtained from cuMemAddressReserve and the physical allocation obtained from cuMemCreate or cuMemImportFromShareableHandle must be associated with each other by using cuMemMap."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.6. Mapping Memory - Users can associate allocation...",
    "content": "Users can associate allocations from multiple devices to reside in contiguous virtual address ranges as long as they have carved out enough address space. In order to decouple the physical allocation and the address range, users must unmap the address of the mapping by using cuMemUnmap. Users can map and unmap memory to the same address range as many times as they want, as long as they ensure that they don't attempt to create mappings on VA range reservations that are already mapped. The following code snippet illustrates the usage for the function:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.6. Mapping Memory - cppCdeviceptr ptr  ptr address...",
    "content": "```cppCdeviceptr ptr; // `ptr`: address in the address range previously reserved by cuMemAddressReserve. // `allocHandler`: CUmemGenericAllocationHandle obtained by a previous call to `cuMemCreate`.CuResult result = cuMemMap(ptr, size, 0, allocHandle, 0);```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.7. Control Access Rights - The Virtual Memory Management ...",
    "content": "The Virtual Memory Management APIs enable applications to explicitly protect their VA ranges with access control mechanisms. Mapping the allocation to a region of the address range using cuMemMap does not make the address accessible, and would result in a program crash if accessed by a CUDA kernel. Users must specifically select access control using the cuMemSetAccess function, which allows or restricts access for specific devices to a mapped address range. The following code snippet illustrates the usage for the function:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.7. Control Access Rights - cppvoid setAccessOnDeviceint d...",
    "content": "```cppvoid setAccessOnDevice(int device, CUdeviceptr ptr, size_t size) {    CUmemAccessDesc accessDesc = {};    accessDesc.location.type = CU_MEM_LOCATION_TYPE_DEVICE;    accessDesc.location.id = device;    accessDesc.flags = CU_MEM_ACCESS_FLAGS_PROT_READWRITE;    // Make the address accessible    cuMemSetAccess(ptr, size, &accessDesc, 1);}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.7. Control Access Rights - The access control mechanism e...",
    "content": "The access control mechanism exposed with Virtual Memory Management allows users to be explicit about which allocations they want to share with other peer devices on the system. As specified earlier, cudaEnablePeerAccess forces all prior and future cudaMalloc'd allocations to be mapped to the target peer device. This can be convenient in many cases as user doesn't have to worry about tracking the mapping state of every allocation to every device in the system. But for users concerned with performance of their applications this approach has performance implications. With access control at allocation granularity Virtual Memory Management exposes a mechanism to have peer mappings with minimal overhead."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.7. Control Access Rights - The vectorAddMAP sample can be...",
    "content": "The vectorAddMAP sample can be used as an example for using the Virtual Memory Management APIs."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "13.7. Control Access Rights - The vectorAddMAP sample can be...",
    "content": "The vectorAddMAP sample can be used as an example for using the Virtual Memory Management APIs."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 14. Stream Ordered Memory Allocator",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.1. Introduction - Managing memory allocations us...",
    "content": "Managing memory allocations using cudaMalloc and cudaFree causes GPU to synchronize across all executing CUDA streams. The Stream Order Memory Allocator enables applications to order memory allocation and deallocation with other work launched into a CUDA stream such as kernel launches and asynchronous copies. This improves application memory use by taking advantage of stream- ordering semantics to reuse memory allocations. The allocator also allows applications to control the allocator's memory caching behavior. When set up with an appropriate release threshold, the caching behavior allows the allocator to avoid expensive calls into the OS when the application indicates it is willing to accept a bigger memory footprint."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.1. Introduction - The allocator also supports th...",
    "content": " The allocator also supports the easy and secure sharing of allocations between processes."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.1. Introduction - For many applications the Stre...",
    "content": "For many applications, the Stream Ordered Memory Allocator reduces the need for custom memory management abstractions, and makes it easier to create high- performance custom memory management for applications that need it. For applications and libraries that already have custom memory allocators, adopting the Stream Ordered Memory Allocator enables multiple libraries to share a common pool of memory managed by the driver, thus reducing excess memory consumption. Additionally, the driver can perform optimizations based on its awareness of the allocator and other stream management APIs. Finally, Nsight Compute and the Next- Gen CUDA debugger is aware of the allocator as part of their CUDA 11.3 toolkit support."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.2. Query for Support - The user can determine whether......continues on next page",
    "content": "The user can determine whether or not a device supports the stream ordered memory allocator by calling cudaDeviceAttribute() with the device attribute cudaDevAttrMemoryPoolIsSupported.\n\nStarting with CUDA 11.3, IPC memory pool support can be queried with the cudaDevAttrMemoryPoolSupportedHandleTypes device attribute. Previous drivers will return cudaErrorInvalidValue as those drivers are unaware of the attribute enum.\n\nint driverVersion = 0; int deviceSupportsMemoryPools = 0; int poolSupportedHandleTypes = 0; cudaDriverGetVersion(&driverVersion); if (driverVersion >= 11020) {\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.2. Query for Support - cudaDeviceGetAttributedeviceSu......Performing the driver version ...",
    "content": "cudaDeviceGetAttribute(&deviceSupportsMemoryPools, cudaDevAttrMemoryPoolsSupported, device); } if (deviceSupportsMemoryPools != 0) { // `device` supports the Stream Ordered Memory Allocator } if (driverVersion >= 11030) { cudaDeviceGetAttribute(&poolSupportedHandleTypes, cudaDevAttrMemoryPoolSupportedHandleTypes, device); } if (poolSupportedHandleTypes & cudaMemHandleTypePosixFileDescriptor) { // Pools on the specified device can be created with posix file descriptor- based IPC }\n\nPerforming the driver version check before the query avoids hitting a cudaErrorInvalidValue error on drivers where the attribute was not yet defined. One can use cudaGetLastError to clear the error instead of avoiding it."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.3. API Fundamentals (cudaMallocAsync and cudaFreeAsync) - The APIs cudaMallocAsync and c...",
    "content": "The APIs cudaMallocAsync and cudaFreeAsync form the core of the allocator. cudaMallocAsync returns an allocation and cudaFreeAsync frees an allocation. Both APIs accept stream arguments to define when the allocation will become and stop being available for use. The pointer value returned by cudaMallocAsync is determined synchronously and is available for constructing future work. It is important to note that cudaMallocAsync ignores the current device/context when determining where the allocation will reside. Instead, cudaMallocAsync determines the resident device based on the specified memory pool or the supplied stream. The simplest use pattern is when the memory is allocated, used, and freed back into the same stream."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.3. API Fundamentals (cudaMallocAsync and cudaFreeAsync) - void ptr sizet size  512 cudaM......When using an allocation in a ...",
    "content": "void *ptr; size_t size = 512; cudaMallocAsync(&ptr, size, cudaStreamPerThread); // do work using the allocation kernel<<<..., cudaStreamPerThread>>>-(ptr, ...); // An asynchronous free can be specified without synchronizing the cpu and CPU cudaFreeAsync(ptr, cudaStreamPerThread);\n\nWhen using an allocation in a stream other than the allocating stream, the user must guarantee that the access will happen after the allocation operation, otherwise the behavior is undefined. The user may make this guarantee either by synchronizing the allocating stream, or by using CUDA events to synchronize the producing and consuming streams."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.3. API Fundamentals (cudaMallocAsync and cudaFreeAsync) - cudaFreeAsync inserts a free o...",
    "content": "cudaFreeAsync() inserts a free operation into the stream. The user must guarantee that the free operation happens after the allocation operation and any use of the allocation. Also, any use of the allocation after the free operation starts results in undefined behavior. Events and/or stream synchronizing operations should be used to guarantee any access to the allocation on other streams is complete before the freeing stream begins the free operation."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.3. API Fundamentals (cudaMallocAsync and cudaFreeAsync) - cudaMallocAsyncptr size stream......cudaMallocptr size kernel stre...",
    "content": "cudaMallocAsync(&ptr, size, stream1); cudaEventRecord(event1, stream1); //stream2 must wait for the allocation to be ready before accessing cudaStreamWaitEvent(stream2, event1); kernel<<<..., stream2>>>ptr, ...); cudaEventRecord(event2, stream2); // stream3 must wait for stream2 to finish accessing the allocation before // freeing the allocation cudaStreamWaitEvent(stream3, event2); cudaFreeAsync(ptr, stream3);\n\nThe user can free allocations allocated with cudaMalloc() with cudaFreeAsync(). The user must make the same guarantees about accesses being complete before the free operation begins.\n\ncudaMalloc(&ptr, size); kernel<<<..., stream  $\\geq \\geq$  ptr, ...); cudaFreeAsync(ptr, stream);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.3. API Fundamentals (cudaMallocAsync and cudaFreeAsync) - The user can free memory alloc......cudaMallocAsyncptr size stream...",
    "content": "The user can free memory allocated with cudaMallocAsync with cudaFree(). When freeing such allocations through the cudaFree() API, the driver assumes that all accesses to the allocation are complete and performs no further synchronization. The user can use cudaStreamQuery / cudaS- treamSynchronize / cudaEventQuery / cudaEventSynchronize / cudaDeviceSynchronize to guarantee that the appropriate asynchronous work is complete and that the GPU will not try to access the allocation.\n\ncudaMallocAsync(&ptr, size, stream); kernel<<<..., stream  $\\geq \\geq$  ptr, ...); // synchronize is needed to avoid prematurely freeing the memory cudaStreamSynchronize(stream); cudaFree(ptr);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.4. Memory Pools and the cudaMemPool_t - Memory pools encapsulate virtu...",
    "content": "Memory pools encapsulate virtual address and physical memory resources that are allocated and managed according to the pools attributes and properties. The primary aspect of a memory pool is the kind and location of memory it manages."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.4. Memory Pools and the cudaMemPool_t - All calls to cudaMallocAsync u...",
    "content": "All calls to cudaMallocAsync use the resources of a memory pool. In the absence of a specified memory pool, cudaMallocAsync uses the current memory pool of the supplied stream's device. The current memory pool for a device may be set with cudaDeviceSetMempool and queried with cudaDeviceGetMempool. By default (in the absence of a cudaDeviceSetMempool call), the current memory pool is the default memory pool of a device. The API cudaMallocFromPoolAsync and c++ overloads of cudaMallocAsync allow a user to specify the pool to be used for an allocation without setting it as the current pool. The APIs cudaDeviceGetDefaultMempool and cudaMemPoolCreate give users handles to memory pools."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.4. Memory Pools and the cudaMemPool_t - Note The mempool current to a ......Note cudaMemPoolSetAttribute a...",
    "content": "Note: The mempool current to a device will be local to that device. So allocating without specifying a memory pool will always yield an allocation local to the stream's device.\n\nNote: cudaMemPoolSetAttribute and cudaMemPoolGetAttribute control the attributes of the"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.5. Default/Implicit Pools - 145 DefaultImplicit PoolsThe d...",
    "content": "# 14.5. Default/Implicit Pools\n14.5. Default/Implicit PoolsThe default memory pool of a device may be retrieved with the cudaDeviceGetDefaultMempool API. Allocations from the default memory pool of a device are non- migratable device allocation located on that device. These allocations will always be accessible from that device. The accessibility of the default memory pool may be modified with cudaMemPoolSetAccess and queried by cudaMemPool- GetAccess. Since the default pools do not need to be explicitly created, they are sometimes referred to as implicit pools. The default memory pool of a device does not support IPC."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.6. Explicit Pools - The API cudaMemPoolCreate crea......cudaMemPoolCreatememPool poolP...",
    "content": "# 14.6. Explicit Pools\nThe API cudaMemPoolCreate creates an explicit pool. Currently memory pools can only allocate device allocations. The device the allocations will be resident on must be designated in the properties structure. The primary use case for explicit pools is IPC capability.\n\n// create a pool similar to the implicit pool on device 0 int device  $= \\texttt{O}$  cudaMemPoolProps poolProps  $=$  {}; poolProps.allocType  $=$  cudaMemAllocationTypePinned; poolProps.location.id  $=$  device; poolProps.location.type  $=$  cudaMemLocationTypeDevice;\n\ncudaMemPoolCreate(&memPool, &poolProps));"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.7. Physical Page Caching Behavior - By default the allocator tries......The release threshold is the a...",
    "content": "By default, the allocator tries to minimize the physical memory owned by a pool. To minimize the OS calls to allocate and free physical memory, applications must configure a memory footprint for each pool. Applications can do this with the release threshold attribute (cudaMemPoolAttrReleaseThreshold).\n\nThe release threshold is the amount of memory in bytes a pool should hold onto before trying to release memory back to the OS. When more than the release threshold bytes of memory are held by the memory pool, the allocator will try to release memory back to the OS on the next call to stream, event or device synchronize. Setting the release threshold to UINT64_MAX will prevent the driver from attempting to shrink the pool after every synchronization."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.7. Physical Page Caching Behavior - Cuint64t setVal    UINT64MAX c......BytesToKeep parameter allows a...",
    "content": "Cuint64_t setVal  $=$  UINT64_MAX; cudaMemPoolSetAttribute(memPool, cudaMemPoolAttrReleaseThreshold, &setVal);\n\nApplications that set cudaMemPoolAttrReleaseThreshold high enough to effectively disable memory pool shrinking may wish to explicitly shrink a memory pool's memory footprint. cudaMemPoolTrimTo allows such applications to do so. When trimming a memory pool's footprint, the min\n\nBytesToKeep parameter allows an application to hold onto an amount of memory it expects to need in a subsequent phase of execution."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.7. Physical Page Caching Behavior - Cuint64t setVal    UINT64MAX c...",
    "content": "Cuint64_t setVal  $=$  UINT64_MAX; cudaMemPoolSetAttribute(memPool, cudaMemPoolAttrReleaseThreshold, &setVal); // application phase needing a lot of memory from the stream ordered allocator for  $(\\dot{1} = \\theta ;\\dot{1} < 1\\theta ;\\dot{1} + + )$  { for  $(j = \\theta ;j< 1\\theta ;j + + )$  { cudaMallocAsync(&ptrs[j], size[j], stream); } kernel<<<...,stream  $\\Rightarrow \\Rightarrow$  (ptrs,...); for  $(j = \\theta ;j< 1\\theta ;j + + )$  { cudaFreeAsync(ptrs[j], stream); } // Process does not need as much memory for the next phase. // Synchronize so that the trim operation will know that the allocations are no // longer in use."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.7. Physical Page Caching Behavior - cudaStreamSynchronizestream cu...",
    "content": " cudaStreamSynchronize(stream); cudaMemPoolTrimTo(mempool, 0); // Some other process/allocation mechanism can now use the physical memory // released by the trimming operation."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.8. Resource Usage Statistics - In CUDA 113 the pool attribute......The cudaMemPoolAttrMemHigh att...",
    "content": "In CUDA 11.3, the pool attributes cudaMemPoolAttrReservedMemCurrent, cudaMemPoolAttrReservedMemHigh, cudaMemPoolAttrUsedMemCurrent, and cudaMemPoolAttrUsedMemHigh were added to query the memory usage of a pool.\n\nQuerying the cudaMemPoolAttrReservedMemCurrent attribute of a pool reports the current total physical GPU memory consumed by the pool. Querying the cudaMemPoolAttrUsedMemCurrent of a pool returns the total size of all of the memory allocated from the pool and not available for reuse.\n\nThe cudaMemPoolAttr\\*MemHigh attributes are watermarks recording the max value achieved by the respective cudaMemPoolAttr\\*MemCurrent attribute since last reset. They can be reset to the current value by using the cudaMemPoolSetAttribute API."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.8. Resource Usage Statistics - sample helper functions for ge......cudaMemPoolGetAttributememPool...",
    "content": "// sample helper functions for getting the usage statistics in bulk struct usageStatistics {    cuuint64_t reserved;    cuuint64_t reservedHigh;    cuuint64_t used;    cuuint64_t usedHigh;};void getUsageStatistics(cudaMemoryPool_t memPool, struct usageStatistics *statistics) {    cudaMemPoolGetAttribute(memPool, cudaMemPoolAttrReservedMemCurrent, statistics- > reserved);    cudaMemPoolGetAttribute(memPool, cudaMemPoolAttrReservedMemHigh, statistics- > reservedHigh);}\n\n(continues on next page)\n\ncudaMemPoolGetAttribute(memPool, cudaMemPoolAttrUsedMemCurrent, statistics- >used); cudaMemPoolGetAttribute(memPool, cudaMemPoolAttrUsedMemHigh, statistics- > usedHigh); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.8. Resource Usage Statistics - resetting the waternarks will ...",
    "content": "// resetting the waternarks will make them take on the current value. void resetStatistics(cudaMemoryPool_t memPool) {    cuuint64_t value = 0;    cudaMemPoolSetAttribute(memPool, cudaMemPoolAttrReservedMemHigh, &value);    cudaMemPoolSetAttribute(memPool, cudaMemPoolAttrUsedMemHigh, &value);}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.9. Memory Reuse Policies - In order to service an allocat...",
    "content": "In order to service an allocation request, the driver attempts to reuse memory that was previously freed via cudaFreeAsync() before attempting to allocate more memory from the OS. For example, memory freed in a stream can immediately be reused for a subsequent allocation request in the same stream. Similarly, when a stream is synchronized with the CPU, the memory that was previously freed in that stream becomes available for reuse for an allocation in any stream."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.9. Memory Reuse Policies - The stream ordered allocator h...",
    "content": "The stream ordered allocator has a few controllable allocation policies. The pool attributes cudaMemPoolReuseFollowEventDependencies. cudaMemPoolReuseAllowOpportunistic, and cudaMemPoolReuseAllowInternalDependencies control these policies. Upgrading to a newer CUDA driver may change, enhance, augment and/or reorder the reuse policies."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.9.1. cudaMemPoolReuseFollowEventDependencies - Before allocating more physica......waiting on the event that capt...",
    "content": "# 14.9.1. cudaMemPoolReuseFollowEventDependencies\nBefore allocating more physical GPU memory, the allocator examines dependency information established by CUDA events and tries to allocate from memory freed in another stream.\n\ncudaMallocAsync(&ptr, size, originalStream); kernel<<<..., originalStream>>(ptr, ...); cudaFreeAsync(ptr, originalStream); cudaEventRecord(event, originalStream);\n\n// waiting on the event that captures the free in another stream // allows the allocator to reuse the memory to satisfy // a new allocation request in the other stream when // cudaMemPoolReuseFollowEventDependencies is enabled. cudaStreamWaitEvent(otherStream, event); cudaMallocAsync(&ptr2, size, otherStream);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.9.2. cudaMemPoolReuseAllowOpportunistic - According to the cudaMemPoolRe...",
    "content": "According to the cudaMemPoolReuseAllowOpportunistic policy, the allocator examines freed allocations to see if the free's stream order semantic has been met (such as the stream has passed the point of execution indicated by the free). When this is disabled, the allocator will still reuse memory made available when a stream is synchronized with the CPU. Disabling this policy does not stop the cudaMemPoolReuseFollowEventDependencies from applying."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.9.2. cudaMemPoolReuseAllowOpportunistic - cudaMallocAsyncptr size origin......after some time the kernel fin...",
    "content": "cudaMallocAsync(&ptr, size, originalStream); kernel  $\\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon$  originalStream  $\\geq \\geq$  (ptr, ...); cudaFreeAsync(ptr, originalStream);\n\n// after some time, the kernel finishes running wait(10);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.9.2. cudaMemPoolReuseAllowOpportunistic - When cudaMemPoolReuseAllowOppo...",
    "content": "// When cudaMemPoolReuseAllowOpportunistic is enabled this allocation request // can be fulfilled with the prior allocation based on the progress of originalStream. cudaMallocAsync(&ptr2, size, otherStream);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.9.3. cudaMemPoolReuseAllowInternalDependencies - Failing to allocate and map mo...",
    "content": "Failing to allocate and map more physical memory from the OS, the driver will look for memory whose availability depends on another stream's pending progress. If such memory is found, the driver will insert the required dependency into the allocating stream and reuse the memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.9.3. cudaMemPoolReuseAllowInternalDependencies - cudaMallocAsyncptr size origin...",
    "content": "cudaMallocAsync(&ptr, size, originalStream); kernel  $\\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\delta \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.9.3. cudaMemPoolReuseAllowInternalDependencies - epsilon epsilon epsilon epsilo...",
    "content": "epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\delta \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon$  originalStream  $\\geq \\geq$  (ptr, ..."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.9.3. cudaMemPoolReuseAllowInternalDependencies - cudaFreeAsyncptr originalStrea...",
    "content": "); cudaFreeAsync(ptr, originalStream);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.9.3. cudaMemPoolReuseAllowInternalDependencies - When cudaMemPoolReuseAllowInte...",
    "content": "// When cudaMemPoolReuseAllowInternalDependencies is enabled // and the driver fails to allocate more physical memory, the driver may // effectively perform a cudaStreamWaitEvent in the allocating stream // to make sure that future work in 'otherStream' happens after the work // in the original stream that would be allowed to access the original allocation. cudaMallocAsync(&ptr2, size, otherStream);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.9.4. Disabling Reuse Policies - While the controllable reuse p...",
    "content": "# 14.9.4. Disabling Reuse Policies\nWhile the controllable reuse policies improve memory reuse, users may want to disable them. Allowing opportunistic reuse (such as cudaMemPoolReuseAllowOpportunistic) introduces run to run variance in allocation patterns based on the interleaving of CPU and GPU execution. Internal dependency insertion (such as cudaMemPoolReuseAllowInternalDependencies) can serialize work in unexpected and potentially non- deterministic ways when the user would rather explicitly synchronize an event or stream on allocation failure."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.10. Device Accessibility for Multi-GPU Support - Just like allocation accessibi...",
    "content": "Just like allocation accessibility controlled through the virtual memory management APIs, memory pool allocation accessibility does not follow cudaDeviceEnablePeerAccess or cuCtxEnablePeerAccess. Instead, the API cudaMemPoolSetAccess modifies what devices can access allocations from a pool. By default, allocations are accessible from the device where the allocations are located. This access cannot be revoked. To enable access from other devices, the accessing device must be peer capable with the memory pool's device; check with cudaDeviceCanAccessPeer. If the peer capability is not checked, the set access may fail with cudaErrorInvalidDevice."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.10. Device Accessibility for Multi-GPU Support - If no allocations had been mad...",
    "content": " If no allocations had been made from the pool, the cudaMemPoolSetAccess call may succeed even when the devices are not peer capable; in this case, the next allocation from the pool will fail."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.10. Device Accessibility for Multi-GPU Support - It is worth noting that cudaMe...",
    "content": "It is worth noting that cudaMemPoolSetAccess affects all allocations from the memory pool, not just future ones. Also the accessibility reported by cudaMemPoolGetAccess applies to all allocations from the pool, not just future ones. It is recommended that the accessibility settings of a pool for a given GPU not be changed frequently; once a pool is made accessible from a given GPU, it should remain accessible from that GPU for the lifetime of the pool."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.10. Device Accessibility for Multi-GPU Support - snippet showing usage of cudaM...",
    "content": "// snippet showing usage of cudaMemPoolSetAccess: cudaError_t setAccessOnDevice(cudaMemPool_t memPool, int residentDevice, int accessingDevice) { cudaMemAccessDesc accessDesc = {}; accessDesc.location.type = cudaMemLocationTypeDevice; accessDesc.location.id = accessingDevice; accessDesc.flags = cudaMemAccessFlagsProtReadWrite; int canAccess = 0; cudaError_t error = cudaDeviceCanAccessPeer(&canAccess, accessingDevice, residentDevice); if (error != cudaSuccess) { return error; } else if (canAccess == 0) { return cudaErrorPeerAccessUnsupported; } // Make the address accessible return cudaMemPoolSetAccess(memPool, &accessDesc, 1);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.11. IPC Memory Pools - IPC capable memory pools allow......There are two phases to sharin...",
    "content": "# 14.11. IPC Memory Pools\nIPC capable memory pools allow easy, efficient and secure sharing of GPU memory between processes. CUDA's IPC memory pools provide the same security benefits as CUDA's virtual memory management APIs.\n\nThere are two phases to sharing memory between processes with memory pools. The processes first need to share access to the pool, then share specific allocations from that pool. The first phase establishes and enforces security. The second phase coordinates what virtual addresses are used in each process and when mappings need to be valid in the importing process."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.11.1. Creating and Sharing IPC Memory Pools - Sharing access to a pool invol...",
    "content": "Sharing access to a pool involves retrieving an OS native handle to the pool (with the cudaMemPoolExportToShareableHandle() API), transferring the handle to the importing process using the usual OS native IPC mechanisms, and creating an imported memory pool (with the cudaMemPoolImportFromShareableHandle() API). For cudaMemPoolExportToShareableHandle to succeed, the memory pool had to be created with the requested handle type specified in the pool properties structure. Please reference samples for the appropriate IPC mechanisms to transfer the OS native handle between processes. The rest of the procedure can be found in the following code snippets."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.11.1. Creating and Sharing IPC Memory Pools - in exporting process  create a......The handle must be sent to the...",
    "content": "// in exporting process // create an exportable IPC capable pool on device 0 cudaMemPoolProps poolProps = {}; poolProps allocType = cudaMemAllocationTypePinned; poolProps.location.id = 0; poolProps.location.type = cudaMemLocationTypeDevice;\n\n// Setting handleTypes to a non zero value will make the pool exportable (IPC capable) poolProps.handleTypes = CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR;\n\ncudaMemPoolCreate(&memPool, &poolProps));\n\n// FD based handles are integer types int fdHandle = 0;\n\n// Retrieve an OS native handle to the pool. // Note that a pointer to the handle memory is passed in here. cudaMemPoolExportToShareableHandle(&fdHandle, memPool, CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR, 0);\n\n// The handle must be sent to the importing process with the appropriate // OS specific APIs."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.11.1. Creating and Sharing IPC Memory Pools - in importing process int fdHan...",
    "content": "// in importing process int fdHandle; // The handle needs to be retrieved from the exporting process with the // appropriate OS specific APIs. // Create an imported pool from the shareable handle. // Note that the handle is passed by value here. cudaMemPoolImportFromShareableHandle(&importedMemPool, (void*)fdHandle, CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR, 0);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.11.2. Set Access in the Importing Process - Imported memory pools are init......If the imported memory pool be...",
    "content": "Imported memory pools are initially only accessible from their resident device. The imported memory pool does not inherit any accessibility set by the exporting process. The importing process needs to enable access (with cudaMemPoolSetAccess) from any GPU it plans to access the memory from.\n\nIf the imported memory pool belongs to a non- visible device in the importing process, the user must use the cudaMemPoolSetAccess API to enable access from the GPUs the allocations will be used on."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.11.3. Creating and Sharing Allocations from an Exported Pool - Once the pool has been shared ...",
    "content": "Once the pool has been shared, allocations made with cudaMallocAsync() from the pool in the exporting process can be shared with other processes that have imported the pool. Since the pool's security policy is established and verified at the pool level, the OS does not need extra bookkeeping to provide security for specific pool allocations; In other words, the opaque cudaMemPoolPtrExportData required to import a pool allocation may be sent to the importing process using any mechanism."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.11.3. Creating and Sharing Allocations from an Exported Pool - While allocations may be expor...",
    "content": "While allocations may be exported and even imported without synchronizing with the allocating stream in any way, the importing process must follow the same rules as the exporting process when accessing the allocation. Namely, access to the allocation must happen after the stream ordering of the allocation operation in the allocating stream. The two following code snippets show cudaMemPoolExportPointer() and cudaMemPoolImportPointer() sharing the allocation with an IPC event used to guarantee that the allocation isn't accessed in the importing process before the allocation is ready."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.11.3. Creating and Sharing Allocations from an Exported Pool - preparing an allocation in the...",
    "content": "// preparing an allocation in the exporting process cudaMemPoolPtrExportData exportData; cudaEvent_t readyIpcEvent; cudaIpcEventHandle_t readyIpcEventHandle; // ipc event for coordinating between processes // cudaEventInterprocess flag makes the event an ipc event // cudaEventDisableTiming is set for performance reasons cudaEventCreate( &readyIpcEvent, cudaEventDisableTiming | cudaEventInterprocess) // allocate from the exporting mem pool cudaMallocAsync(&ptr, size,exportMemPool, stream); // event for sharing when the allocation is ready. cudaEventRecord(readyIpcEvent, stream); cudaMemPoolExportPointer(&exportData, ptr); cudaIpcGetEventHandle(&readyIpcEventHandle, readyIpcEvent); // Share IPC event and pointer export data with the importing process using // any mechanism."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.11.3. Creating and Sharing Allocations from an Exported Pool - Here we copy the data into sha...",
    "content": " Here we copy the data into shared memory shmem- >ptrData = exportData; shmem- >readyIpcEventHandle = readyIpcEventHandle; // signal consumers data is ready"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.11.3. Creating and Sharing Allocations from an Exported Pool - Importing an allocation cudaMe......import the allocation The oper...",
    "content": "// Importing an allocation cudaMemPoolPtrExportData *importData = &shmem- >ptrData;\n\n(continues on next page)\n\n(continued from previous page)\n\ncudaEvent_t readyIpcEvent; cudaIpcEventHandle_t *readyIpcEventHandle = &shmem- >readyIpcEventHandle;\n\n// Need to retrieve the ipc event handle and the export data from the // exporting process using any mechanism. Here we are using shmem and just // need synchronization to make sure the shared memory is filled in.\n\ncudaIpcOpenEventHandle(&readyIpcEvent, readyIpcEventHandle);\n\n// import the allocation. The operation does not block on the allocation being ready. cudaMemPoolImportPointer(&ptr, importedMemPool, importData);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.11.3. Creating and Sharing Allocations from an Exported Pool - Wait for the prior stream oper...",
    "content": "// Wait for the prior stream operations in the allocating stream to complete before // using the allocation in the importing process. cudaStreamWaitEvent(stream, readyIpcEvent); kernel<<<..., stream>>>ptr, ...);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.11.3. Creating and Sharing Allocations from an Exported Pool - When freeing the allocation th......Last access in importing proce...",
    "content": "When freeing the allocation, the allocation needs to be freed in the importing process before it is freed in the exporting process. The following code snippet demonstrates the use of CUDA IPC events to provide the required synchronization between the cudaFreeAsync operations in both processes. Access to the allocation from the importing process is obviously restricted by the free operation in the importing process side. It is worth noting that cudaFree can be used to free the allocation in both processes and that other stream synchronization APIs may be used instead of CUDA IPC events.\n\n// The free must happen in importing process before the exporting process kernel<<<..., stream>>>ptr, ...);\n\n// Last access in importing process cudaFreeAsync(ptr, stream);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.11.3. Creating and Sharing Allocations from an Exported Pool - Access not allowed in the impo......The free in the importing proc...",
    "content": "// Access not allowed in the importing process after the free cudaIpcEventRecord(finishedIpcEvent, stream);\n\n// Exporting process // The exporting process needs to coordinate its free with the stream order // of the importing process's free. cudaStreamWaitEvent(stream, finishedIpcEvent); kernel<<<..., stream>>>ptrInExportingProcess, ...);\n\n// The free in the importing process doesn't stop the exporting process // from using the allocation. cudFreeAsync(ptrInExportingProcess, stream);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.11.4. IPC Export Pool Limitations - IPC pools currently do not sup...",
    "content": "IPC pools currently do not support releasing physical blocks back to the OS. As a result the cudaMemPoolTrimTo API acts as a no- op and the cudaMemPoolAttrReleaseThreshold effectively gets ignored. This behavior is controlled by the driver, not the runtime and may change in a future driver update."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.11.5. IPC Import Pool Limitations - Allocating from an import pool......The resource usage stat attrib...",
    "content": "# 14.11.5. IPC Import Pool Limitations\nAllocating from an import pool is not allowed; specifically, import pools cannot be set current and cannot be used in the cudaMallocFromPoolAsync API. As such, the allocation reuse policy attributes are meaningless for these pools.\n\nIPC pools currently do not support releasing physical blocks back to the OS. As a result the cudaMemPoolTrimTo API acts as a no- op and the cudaMemPoolAttrReleaseThreshold effectively gets ignored.\n\nThe resource usage stat attribute queries only reflect the allocations imported into the process and the associated physical memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.13. Addendums - 1412 Synchronization API Actio...",
    "content": "# 14.12. Synchronization API Actions\n14.12. Synchronization API ActionsOne of the optimizations that comes with the allocator being part of the CUDA driver is integration with the synchronize APIs. When the user requests that the CUDA driver synchronize, the driver waits for asynchronous work to complete. Before returning, the driver will determine what frees the synchronization guaranteed to be completed. These allocations are made available for allocation regardless of specified stream or disabled allocation policies. The driver also checks cudaMemPoolAttrReleaseThreshold here and releases any excess physical memory that it can.\n\n# 14.13. Addendums\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.13.2. CuPointerGetAttribute Query - 14131 cudaMemopyAsync Current ......Invoking cuPointerGetAttribute...",
    "content": "# 14.13.1. cudaMemopyAsync Current Context/Device Sensitivity\n14.13.1. cudaMemopyAsync Current Context/Device SensitivityIn the current CUDA driver, any async memcpy involving memory from cudaMallocAsync should be done using the specified stream's context as the calling thread's current context. This is not necessary for cudaMemopyReerAsync, as the device primary contexts specified in the API are referenced instead of the current context.\n\n# 14.13.2. CuPointerGetAttribute Query\nInvoking cuPointerGetAttribute on an allocation after invoking cudaFreeAsync on it results in undefined behavior. Specifically, it does not matter if an allocation is still accessible from a given stream: the behavior is still undefined."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "14.13.3. cuGraphAddMemsetNode - 14133 cuGraphAddMemsetNodecuGr...",
    "content": "14.13.3. cuGraphAddMemsetNodecuGraphAddMemsetNode does not work with memory allocated via the stream ordered allocator. However, memsets of the allocations can be stream captured."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 15. Graph Memory Nodes - 14134 Pointer AttributesThe cu...",
    "content": "# 14.13.4. Pointer Attributes\n14.13.4. Pointer AttributesThe cuPointerGetAttributes query works on stream ordered allocations. Since stream ordered allocations are not context associated, querying CU_POINTER_ATTRIBUTE_CONTEXT will succeed but return NULL in *Data. The attribute CU_POINTER_ATTRIBUTE_DEVICEORDINAL can be used to determine the location of the allocation: this can be useful when selecting a context for making p2h2p copies using cudaMemopyPeerAsync. The attribute CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE was added in CUDA 11.3 and can be useful for debugging and for confirming which pool an allocation comes from before doing IPC.\n\n# CUDA C++ Programming Guide, Release 12.1\n\n\n# Chapter 15. Graph Memory Nodes\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.1. Introduction - Graph memory nodes allow graph...",
    "content": "Graph memory nodes allow graphs to create and own memory allocations. Graph memory nodes have GPU ordered lifetime semantics, which dictate when memory is allowed to be accessed on the device. These GPU ordered lifetime semantics enable driver- managed memory reuse, and match those of the stream ordered allocation APIs cudaMallocAsync and cudaFreeAsync, which may be captured when creating a graph."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.1. Introduction - Graph allocations have fixed a......CUDA may reuse the same physic...",
    "content": "Graph allocations have fixed addresses over the life of a graph including repeated instantiations and launches. This allows the memory to be directly referenced by other operations within the graph without the need of a graph update, even when CUDA changes the backing physical memory. Within a graph, allocations whose graph ordered lifetimes do not overlap may use the same underlying physical memory.\n\nCUDA may reuse the same physical memory for allocations across multiple graphs, aliasing virtual address mappings according to the GPU ordered lifetime semantics. For example when different graphs are launched into the same stream, CUDA may virtually alias the same physical memory to satisfy the needs of allocations which have single- graph lifetimes."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.2. Support and Compatibility - Graph memory nodes require an ......int driverVersion   0  int dev...",
    "content": "Graph memory nodes require an 11.4 capable CUDA driver and support for the stream ordered allocator on the GPU. The following snippet shows how to check for support on a given device.\n\nint driverVersion  $= 0$  int deviceSupportsMemoryPools  $= 0$  int deviceSupportsMemoryNodes  $= 0$  cudaDriverGetVersion(&driverVersion); if (driverVersion  $> =$  11020){ // avoid invalid value error in cudaDeviceGetAttribute cudaDeviceGetAttribute(&deviceSupportsMemoryPools, cudaDevAttrMemoryPoolsSupported, device); } deviceSupportsMemoryNodes  $=$  (driverVersion  $> =$  11040) && (deviceSupportsMemoryPools  $! =$ $\\rightarrow \\theta)$  ."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.2. Support and Compatibility - Doing the attribute query insi...",
    "content": "Doing the attribute query inside the driver version check avoids an invalid value return code on 11.0 and 11.1 drivers. Be aware that the compute sanitizer emits warnings when it detects CUDA returning error codes, and a version check before reading the attribute will avoid this. Graph memory nodes are only supported on driver versions 11.4 and newer."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3. API Fundamentals - Graph memory nodes are graph n...",
    "content": "Graph memory nodes are graph nodes representing either memory allocation or free actions. As a shorthand, nodes that allocate memory are called allocation nodes. Likewise, nodes that free memory are called free nodes. Allocations created by allocation nodes are called graph allocations. CUDA assigns virtual addresses for the graph allocation at node creation time. While these virtual addresses are fixed for the lifetime of the allocation node, the allocation contents are not persistent past the freeing operation and may be overwritten by accesses referring to a different allocation."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3. API Fundamentals - Graph allocations are consider......Note Graph destruction does no...",
    "content": "Graph allocations are considered recreated every time a graph runs. A graph allocation's lifetime, which differs from the node's lifetime, begins when GPU execution reaches the allocating graph node and ends when one of the following occurs:\n\nGPU execution reaches the freeing graph node. GPU execution reaches the freeing cudaFreeAsync() stream call immediately upon the freeing call to cudaFree()\n\nNote: Graph destruction does not automatically free any live graph- allocated memory, even though it ends the lifetime of the allocation node. The allocation must subsequently be freed in another graph, or using cudaFreeAsync()/cudaFree()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3. API Fundamentals - Just like other graph nodes gr......Graph allocation lifetimes beg...",
    "content": "Just like other graph nodes, graph memory nodes are ordered within a graph by dependency edges. A program must guarantee that operations accessing graph memory:\n\nare ordered after the allocation node are ordered before the operation freeing the memory\n\nGraph allocation lifetimes begin and usually end according to GPU execution (as opposed to API invocation). GPU ordering is the order that work runs on the GPU as opposed to the order that the work is enqueued or described. Thus, graph allocations are considered 'GPU ordered.'"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3.1. Graph Node APIs - Graph memory nodes may be expl...",
    "content": "Graph memory nodes may be explicitly created with the memory node creation APIs, cudaGraphAddMemAllocNode and cudaGraphAddMemFreeNode. The address allocated by cudaGraphAddMemAllocNode is returned to the user in the dptr field of the passed CUDA_MEM_ALLOC_NODE_PARAMS structure. All operations using graph allocations inside the allocating graph must be ordered after the allocating node. Similarly, any free nodes must be ordered after all uses of the allocation within the graph. cudaGraphAddMemFreeNode creates free nodes."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3.1. Graph Node APIs - In the following figure there ......Fig 1 Kernel Nodes",
    "content": "In the following figure, there is an example graph with an alloc and a free node. Kernel nodes a, b, and c are ordered after the allocation node and before the free node such that the kernels can access the allocation. Kernel node e is not ordered after the alloc node and therefore cannot safely access the memory. Kernel node d is not ordered before the free node, therefore it cannot safely access the memory.\n\nThe following code snippet establishes the graph in this figure:\n\n// Create the graph - it starts out empty cudaGraphCreate(&graph, 0);\n\n(continues on next page)\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/ff4e920edfeeba77cfaed8b32d25a9588ea33b8a0dbd7eaad65996f832c183d9.jpg)  \nFig. 1: Kernel Nodes"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3.1. Graph Node APIs - parameters for a basic allocat...",
    "content": "// parameters for a basic allocation cudaMemAllocNodeParams params  $\\begin{array}{rl}{=}&{\\{\\}}\\end{array}$  params.poolProps.allocType  $=$  cudaMemAllocationTypePinned; params.poolProps.location.type  $=$  cudaMemLocationTypeDevice; // specify device 0 as the resident device params.poolProps.location.id  $= \\theta$  . params.bytesize  $=$  size;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3.1. Graph Node APIs - cudaGraphAddMemAllocNodeallocN...",
    "content": "cudaGraphAddMemAllocNode(&allocNode, graph, NULL, 0, &params); nodeParams- >kernelParams[0]  $=$  params.dptr; cudaGraphAddKernelNode(&a, graph, &allocNode, 1, &nodeParams); cudaGraphAddKernelNode(&b, graph, &a, 1, &nodeParams); cudaGraphAddKernelNode(&c, graph, &a, 1, &nodeParams); cudaGraphNode_t dependencies[2]; // kernel nodes b and c are using the graph allocation, so the freeing node must depend on them. Since the dependency of node b on node a establishes an indirect dependency, the free node does not need to explicitly depend on node a. dependencies[0]  $= b$  dependencies[1]  $= c$  cudaGraphAddMemFreeNode(&freeNode, graph, dependencies, 2, params.dptr); // free node does not depend on kernel node d, so it must not access the freed graph - - allocation."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3.1. Graph Node APIs - cudaGraphAddKernelNoded graph ...",
    "content": " cudaGraphAddKernelNode(&d, graph, &c, 1, &nodeParams);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3.1. Graph Node APIs - node e does not depend on the ...",
    "content": "// node e does not depend on the allocation node, so it must not access the - - allocation. This would be true even if the freeNode depended on kernel node e. cudaGraphAddKernelNode(&e, graph, NULL, 0, &nodeParams);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3.2. Stream Capture - Graph memory nodes can be crea......Ignoring kernel nodes d and e ...",
    "content": "Graph memory nodes can be created by capturing the corresponding stream ordered allocation and free calls cudaMallocAsync and cudaFreeAsync. In this case, the virtual addresses returned by the captured allocation API can be used by other operations inside the graph. Since the stream ordered dependencies will be captured into the graph, the ordering requirements of the stream ordered allocation APIs guarantee that the graph memory nodes will be properly ordered with respect to the captured stream operations (for correctly written stream code).\n\nIgnoring kernel nodes d and e, for clarity, the following code snippet shows how to use stream capture to create the graph from the previous figure:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3.2. Stream Capture - cudaMallocAsyncdptr size strea......End capture in the origin stre...",
    "content": "cudaMallocAsync(&dptr, size, stream1); kernel_A<<< ..., stream1 >>>(dptr, ...); // Fork into stream2 cudaEventRecord(event1, stream1); cudaStreamWaitEvent(stream2, event1); kernel_B<<< ..., stream1 >>>(dptr, ...); // event dependencies translated into graph dependencies, so the kernel node created by the capture of kernel C will depend on the allocation node created by capturing the cudaMallocAsync call. kernel_C<<< ..., stream2 >>>(dptr, ...);\n\n(continues on next page)\n\n(continued from previous page)\n\n// Join stream2 back to origin stream (stream1)  cudaEventRecord(event2, stream2);  cudaStreamWaitEvent(stream1, event2);\n\n// Free depends on all work accessing the memory.  cudaFreeAsync(dptr, stream1);\n\n// End capture in the origin stream  cudaStreamEndCapture(stream1, &graph);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3.3. Accessing and Freeing Graph Memory Outside of the Allocating Graph - Graph allocations do not have ...",
    "content": "Graph allocations do not have to be freed by the allocating graph. When a graph does not free an allocation, that allocation persists beyond the execution of the graph and can be accessed by subsequent CUDA operations. These allocations may be accessed in another graph or directly using a stream operation as long as the accessing operation is ordered after the allocation through CUDA events and other stream ordering mechanisms. An allocation may subsequently be freed by regular calls to cudaFree, cudaFreeAsync, or by the launch of another graph with a corresponding free node, or a subsequent launch of the allocating graph (if it was instantiated with the cudaGraphInstantiateFlagAutoFreeOnLaunch flag)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3.3. Accessing and Freeing Graph Memory Outside of the Allocating Graph - It is illegal to access memory...",
    "content": " It is illegal to access memory after it has been freed - the free operation must be ordered after all operations accessing the memory using graph dependencies, CUDA events, and other stream ordering mechanisms."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3.3. Accessing and Freeing Graph Memory Outside of the Allocating Graph - Note Because graph allocations...",
    "content": "Note: Because graph allocations may share underlying physical memory with each other, the Virtual Aliasing Support rules relating to consistency and coherency must be considered. Simply put, the free operation must be ordered after the full device operation (for example, compute kernel / memcpy) completes. Specifically, out of band synchronization - for example a handshake through memory as part of a compute kernel that accesses the graph- allocated memory - is not sufficient for providing ordering guarantees between the memory writes to graph memory and the free operation of that graph memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3.3. Accessing and Freeing Graph Memory Outside of the Allocating Graph - The following code snippets de...",
    "content": "The following code snippets demonstrate accessing graph allocations outside of the allocating graph with ordering properly established by: using a single stream, using events between streams, and using events baked into the allocating and freeing graph."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Ordering established by using a single stream: - void dptr  cudaGraphAddMemAllo......Contents of consumingfreeing g...",
    "content": "void *dptr;  cudaGraphAddMemAllocNode(&allocNode, allocGraph, NULL, 0, &params);  dptr = params.dptr;  cudaGraphInstantiate(&allocGraphExec, allocGraph, NULL, NULL, 0);  cudaGraphLaunch(allocGraphExec, stream);  kernel<<<, stream>>>(dptr, ...);  cudaFreeAsync(dptr, stream);\n\nOrdering established by recording and waiting on CUDA events:\n\nvoid \\*dptr;\n\n// Contents of allocating graph cudaGraphAddMemAllocNode(&allocNode, allocGraph, NULL, 0, &params); dptr = params.dptr;\n\n// Contents of consuming/freeing graph nodeParams- >kernelParams[0] = params.dptr; cudaGraphAddKernelNode(&a, graph, NULL, 0, &nodeParams); cudaGraphAddMemFreeNode(&freeNode, freeGraph, &a, 1, dptr);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Ordering established by using a single stream: - cudaGraphInstantiateallocGraph......it is now safe to launch the f...",
    "content": "cudaGraphInstantiate(&allocGraphExec, allocGraph, NULL, NULL, 0); cudaGraphInstantiate(&freeGraphExec, freeGraph, NULL, NULL, 0);\n\ncudaGraphLaunch(allocGraphExec, allocStream);\n\n// establish the dependency of stream2 on the allocation node // note: the dependency could also have been established with a stream synchronize operation cudaEventRecord(allocEvent, allocStream) cudaStreamWaitEvent(stream2, allocEvent);\n\nkernel< < stream2 >>> (dptr,\n\n// establish the dependency between the stream 3 and the allocation use cudaStreamRecordEvent(streamUseDoneEvent, stream2); cudaStreamWaitEvent(stream3, streamUseDoneEvent);\n\n// it is now safe to launch the freeing graph, which may also access the memory cudaGraphLaunch(freeGraphExec, stream3);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Ordering established by using graph external event nodes: - void dptr cudaEventt allocEven......Contents of allocating graph w...",
    "content": "void \\*dptr; cudaEvent_t allocEvent; // event indicating when the allocation will be ready for use. cudaEvent_t streamUseDoneEvent; // event indicating when the stream operations are done with the allocation.\n\n// Contents of allocating graph with event record node cudaGraphAddMemAllocNode(&allocNode, allocGraph, NULL, 0, &params); dptr = params.dptr; // note: this event record node depends on the alloc node cudaGraphAddEventRecordNode(&recordNode, allocGraph, &allocNode, 1, allocEvent); cudaGraphInstantiate(&allocGraphExec, allocGraph, NULL, NULL, 0);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Ordering established by using graph external event nodes: - contents of consumingfreeing g......continued from previous page",
    "content": "// contents of consuming/freeing graph with event wait nodes cudaGraphAddEventWaitNode(&streamUseDoneEventNode, waitAndFreeGraph, NULL, 0, streamUseDoneEvent); cudaGraphAddEventWaitNode(&allocReadyEventNode, waitAndFreeGraph, NULL, 0, allocEvent); nodeParams- >kernelParams[0] = params.dptr;\n\n// The allocReadyEventNode provides ordering with the alloc node for use in a consuming graph. cudaGraphAddKernelNode(&kernelNode, waitAndFreeGraph, &allocReadyEventNode, 1, & nodeParams);\n\n(continued from previous page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Ordering established by using graph external event nodes: - The free node has to be ordere......establish the dependency of st...",
    "content": "// The free node has to be ordered after both external and internal users. // Thus the node must depend on both the kernelNode and the // streamUseDoneEventNode. dependencies[0]  $=$  kernelNode; dependencies[1]  $=$  streamUseDoneEventNode; cudaGraphAddMemFreeNode(&freeNode, waitAndFreeGraph, &dependencies, 2, dptr); cudaGraphInstantiate(&waitAndFreeGraphExec, waitAndFreeGraph, NULL, NULL, 0);\n\ncudaGraphLaunch(allocGraphExec, allocStream);\n\n// establish the dependency of stream2 on the event node satisfies the ordering  $\\rightarrow$  requirement cudaStreamWaitEvent(stream2, allocEvent); kernel<< „ stream2 >>>(dptr, …); cudaStreamRecordEvent(streamUseDoneEvent, stream2);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Ordering established by using graph external event nodes: - the event wait node in the wai...",
    "content": "// the event wait node in the waitAndFreeGraphExec establishes the dependency on the  $\\rightarrow$  \"readyForFreeEvent\" that is needed to prevent the kernel running in stream two from accessing the allocation after the free node in execution order. cudaGraphLaunch(waitAndFreeGraphExec, stream3);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3.4. cudaGraphInstantiateFlagAutoFreeOnLaunch - Under normal circumstances CUD...",
    "content": "Under normal circumstances, CUDA will prevent a graph from being relaunched if it has unfreed memory allocations because multiple allocations at the same address will leak memory. Instantiating a graph with the cudaGraphInstantiateFlagAutoFreeOnLaunch flag allows the graph to be relaunched while it still has unfreed allocations. In this case, the launch automatically inserts an asynchronous free of the unfreed allocations."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3.4. cudaGraphInstantiateFlagAutoFreeOnLaunch - Auto free on launch is useful ...",
    "content": "Auto free on launch is useful for single- producer multiple- consumer algorithms. At each iteration, a producer graph creates several allocations, and, depending on runtime conditions, a varying set of consumers accesses those allocations. This type of variable execution sequence means that consumers cannot free the allocations because a subsequent consumer may require access. Auto free on launch means that the launch loop does not need to track the producer's allocations - instead, that information remains isolated to the producer's creation and destruction logic. In general, auto free on launch simplifies an algorithm which would otherwise need to free all the allocations owned by a graph before each relaunch."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3.4. cudaGraphInstantiateFlagAutoFreeOnLaunch - Note The cudaGraphInstantiateF...",
    "content": "Note: The cudaGraphInstantiateFlagAutoFreeOnLaunch flag does not change the behavior of graph destruction. The application must explicitly free the unfreed memory in order to avoid memory leaks, even for graphs instantiated with the flag. The following code shows the use of cudaGraphInstantiateFlagAutoFreeOnLaunch to simplify a single- producer / multiple- consumer algorithm."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3.4. cudaGraphInstantiateFlagAutoFreeOnLaunch - Create producer graph which al......continues on next page",
    "content": "// Create producer graph which allocates memory and populates it with data cudaStreamBeginCapture(cudaStreamPerThread, cudaStreamCaptureModeGlobal); cudaMallocAsync(&data1, blocks * threads, cudaStreamPerThread); cudaMallocAsync(&data2, blocks * threads, cudaStreamPerThread); produce<<blocks, threads, 0, cudaStreamPerThread>>>(data1, data2); cudaStreamEndCapture(cudaStreamPerThread, &graph); cudaGraphInstantiateWithFlags(&producer,\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3.4. cudaGraphInstantiateFlagAutoFreeOnLaunch - tabletrtdgraphcudaGraphInstant...",
    "content": "<table><tr><td>graph,cudaGraphInstantiateFlagAutoFreeOnLaunch);cudaGraphDestroy(graph);// Create first consumer graph by capturing an asynchronous library callcudaStreamBeginCapture(cudaStreamPerThread, cudaStreamCaptureModeGlobal);consumerFromLibrary(data1, cudaStreamPerThread);cudaStreamEndCapture(cudaStreamPerThread, &amp;amp;graph);cudaGraphInstantiateWithFlags(&amp;amp;consumer1, graph, 0); //regular instantiationcudaGraphDestroy(graph);// Create second consumer graphcudaStreamBeginCapture(cudaStreamPerThread, cudaStreamCaptureModeGlobal);consume2&amp;lt;&amp;lt;blocks, threads, 0, cudaStreamPerThread&amp;gt;&amp;gt;&amp;lt; (data2); cudaStreamEndCapture(cudaStreamPerThread, &amp;amp;graph);cudaGraphInstantiateWithFlags(&amp;amp;consumer2, graph, 0);cudaGraphDestroy(graph);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.3.4. cudaGraphInstantiateFlagAutoFreeOnLaunch - Launch in a loopbool launchCon...",
    "content": "// Launch in a loopbool launchConsumer2 = false;do {    cudaGraphLaunch(producer, myStream);    cudaGraphLaunch(consumer1, myStream);    if (launchConsumer2) {        cudaGraphLaunch(consumer2, myStream);    }} while (determineAction(&amp;amp;launchConsumer2));cudaFreeAsync(data1, myStream);cudaFreeAsync(data2, myStream);cudaGraphExecDestroy(producer);cudaGraphExecDestroy(consumer1);cudaGraphExecDestroy(consumer2);</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.4. Optimized Memory Reuse - CUDA reuses memory in two ways...Virtual and physical memory re...",
    "content": "CUDA reuses memory in two ways:\n\n- Virtual and physical memory reuse within a graph is based on virtual address assignment, like in the stream ordered allocator.- Physical memory reuse between graphs is done with virtual aliasing: different graphs can map the same physical memory to their unique virtual addresses."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.4.1. Address Reuse within a Graph - CUDA may reuse memory within a......The following figure shows add...",
    "content": "CUDA may reuse memory within a graph by assigning the same virtual address ranges to different allocations whose lifetimes do not overlap. Since virtual addresses may be reused, pointers to different allocations with disjoint lifetimes are not guaranteed to be unique.\n\nThe following figure shows adding a new allocation node (2) that can reuse the address freed by a dependent node (1)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.4.1. Address Reuse within a Graph - httpscdnmineruopenxlaborgcnres......Fig 2 Adding New Alloc Node 2T...",
    "content": "![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/9258412c1086d1681ae6604b4b9c5a6c011159d88894e43ac5532b5375c67d44.jpg)  \nFig. 2: Adding New Alloc Node 2The following figure shows adding a new alloc node (4). The new alloc node is not dependent on the free node (2) so cannot reuse the address from the associated alloc node (2). If the alloc node (2) used the address freed by free node (1), the new alloc node 3 would need a new address."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.4.2. Physical Memory Management and Sharing - CUDA is responsible for mappin......CUDA may update physical memor...",
    "content": "CUDA is responsible for mapping physical memory to the virtual address before the allocating node is reached in GPU order. As an optimization for memory footprint and mapping overhead, multiple graphs may use the same physical memory for distinct allocations if they will not run simultaneously; however, physical pages cannot be reused if they are bound to more than one executing graph at the same time, or to a graph allocation which remains unfreed.\n\nCUDA may update physical memory mappings at any time during graph instantiation, launch, or execution. CUDA may also introduce synchronization between future graph launches in order to prevent live graph allocations from referring to the same physical memory. As for any allocate- free- allocate"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.4.2. Physical Memory Management and Sharing - httpscdnmineruopenxlaborgcnres......The following figure shows gra...",
    "content": "![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/3c9319fffd5477a7552ff23b341d64ed900d5d4de95f0311d6aab1191bd8daf4.jpg)  \nFig. 3: Adding New Alloc Node 3\n\npattern, if a program accesses a pointer outside of an allocation's lifetime, the erroneous access may silently read or write live data owned by another allocation (even if the virtual address of the allocation is unique). Use of compute sanitizer tools can catch this error.\n\nThe following figure shows graphs sequentially launched in the same stream. In this example, each graph frees all the memory it allocates. Since the graphs in the same stream never run concurrently, CUDA can and should use the same physical memory to satisfy all the allocations."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.4.2. Physical Memory Management and Sharing - httpscdnmineruopenxlaborgcnres......Fig 4 Sequentially Launched Gr...",
    "content": "![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/4bf6e729c04eef22b080d9cba2249bf1d71c59f747f263adccd6cc98bbda2e84.jpg)  \nFig. 4: Sequentially Launched Graphs"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.5. Performance Considerations - When multiple graphs are launc......in general remapping of graph ...",
    "content": "When multiple graphs are launched into the same stream, CUDA attempts to allocate the same physical memory to them because the execution of these graphs cannot overlap. Physical mappings for a graph are retained between launches as an optimization to avoid the cost of remapping. If, at a later time, one of the graphs is launched such that its execution may overlap with the others (for example if it is launched into a different stream) then CUDA must perform some remapping because concurrent graphs require distinct memory to avoid data corruption.\n\nin general, remapping of graph memory in CUDA is likely caused by these operations:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.5. Performance Considerations - Remapping must happen in execu...",
    "content": "- Changing the stream into which a graph is launched- A trim operation on the graph memory pool, which explicitly frees unused memory (discussed in Physical Memory Footprint)- Relaunching a graph while an unfreed allocation from another graph is mapped to the same memory will cause a remap of memory before relaunch\n\nRemapping must happen in execution order, but after any previous execution of that graph is complete (otherwise memory that is still in use could be unmapped). Due to this ordering dependency, as well as because mapping operations are OS calls, mapping operations can be relatively expensive. Applications can avoid this cost by launching graphs containing allocation memory nodes consistently into the same stream."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.5.1. First Launch / cudaGraphUpload - Physical memory cannot be allo......Using different streams for gr...",
    "content": "# 15.5.1. First Launch / cudaGraphUpload\nPhysical memory cannot be allocated or mapped during graph instantiation because the stream in which the graph will execute is unknown. Mapping is done instead during graph launch. Calling cudaGraphUpload can separate out the cost of allocation from the launch by performing all mappings for that graph immediately and associating the graph with the upload stream. If the graph is then launched into the same stream, it will launch without any additional remapping.\n\nUsing different streams for graph upload and graph launch behaves similarly to switching streams, likely resulting in remap operations. In addition, unrelated memory pool management is permitted to pull memory from an idle stream, which could negate the impact of the uploads."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.6. Physical Memory Footprint - The pool management behavior o...",
    "content": "The pool- management behavior of asynchronous allocation means that destroying a graph which contains memory nodes (even if their allocations are free) will not immediately return physical memory to the OS for use by other processes. To explicitly release memory back to the OS, an application should use the cudaDeviceGraphMemTrim API."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.6. Physical Memory Footprint - cudaDeviceGraphMemTrim will un...",
    "content": "cudaDeviceGraphMemTrim will unmap and release any physical memory reserved by graph memory nodes that is not actively in use. Allocations that have not been freed and graphs that are scheduled or running are considered to be actively using the physical memory and will not be impacted. Use of the trim API will make physical memory available to other allocation APIs and other applications or processes, but will cause CUDA to reallocate and remap memory when the trimmed graphs are next launched. Note that cudaDeviceGraphMemTrim operates on a different pool from cudaMemPoolTrimTo(). The graph memory pool is not exposed to the steam ordered memory allocator. CUDA"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.6. Physical Memory Footprint - allows applications to query t...",
    "content": "allows applications to query their graph memory footprint through the cudaDeviceGetGraphMemAttribute API. Querying the attribute cudaGraphMemAttrReservedMemCurrent returns the amount of physical memory reserved by the driver for graph allocations in the current process. Querying cudaGraphMemAttrUsedMemCurrent returns the amount of physical memory currently mapped by at least one graph. Either of these attributes can be used to track when new physical memory is acquired by CUDA for the sake of an allocating graph. Both of these attributes are useful for examining how much memory is saved by the sharing mechanism."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.7. Peer Access - Graph allocations can be confi...",
    "content": "Graph allocations can be configured for access from multiple GPUs, in which case CUDA will map the allocations onto the peer GPUs as required. CUDA allows graph allocations requiring different mappings to reuse the same virtual address. When this occurs, the address range is mapped onto all GPUs required by the different allocations. This means an allocation may sometimes allow more peer access than was requested during its creation; however, relying on these extra mappings is still an error."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.7.1. Peer Access with Graph Node APIs - The cudaGraphAddMemAllocNode A...",
    "content": "The cudaGraphAddMemAllocNode API accepts mapping requests in the accessDescs array field of the node parameters structures. The poolProps.location embedded structure specifies the resident device for the allocation. Access from the allocating GPU is assumed to be needed, thus the application does not need to specify an entry for the resident device in the accessDescs array."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.7.1. Peer Access with Graph Node APIs - cudaMemAllocNodeParams params ...",
    "content": "cudaMemAllocNodeParams params  $\\begin{array}{rl}{=}&{\\{\\}}\\end{array}$  params.poolProps.allocType  $=$  cudaMemAllocationTypePinned; params.poolProps.location.type  $=$  cudaMemLocationTypeDevice; // specify device 1 as the resident device params.poolProps.location.id  $= 1$  . params.bytesize  $=$  size; // allocate an allocation resident on device 1 accessible from device 1 cudaGraphAddMemAllocNode(&allocNode, graph, NULL, 0, &params); accessDescs[2]; // boilerplate for the access descs (only Readwrite and Device access supported by  $\\hookrightarrow$  the add node api) accessDescs[0].flags  $=$  cudaMemAccessFlagsProteReadwrite; accessDescs[0].location.type  $=$  cudaMemLocationTypeDevice; accessDescs[1].flags  $=$  cudaMemAccessFlagsProteReadWrite; accessDescs[1].location."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.7.1. Peer Access with Graph Node APIs - type    cudaMemLocationTypeDev...",
    "content": "type  $=$  cudaMemLocationTypeDevice; // access being requested for device 0 & 2.  Device 1 access requirement left  $\\hookrightarrow$  implicit. accessDescs[0].location.id  $= 0$  accessDescs[1].location.id  $= 2$  // access request array has 2 entries. params.accessDescCount  $= 2$  . params.accessDescs  $=$  accessDescs;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.7.1. Peer Access with Graph Node APIs - continues on next page...allocate an allocation residen...",
    "content": "(continues on next page)\n\n// allocate an allocation resident on device 1 accessible from devices 0, 1 and 2. (0  $\\rightarrow \\& 2$  from the descriptors, 1 from it being the resident device). cudaGraphAddMemAllocNode(&allocNode, graph, NULL, 0, &params);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.7.2. Peer Access with Stream Capture - For stream capture the allocat......cudaMemPoolSetAccessmemPool ac...",
    "content": "For stream capture, the allocation node records the peer accessibility of the allocating pool at the time of the capture. Altering the peer accessibility of the allocating pool after a cudaMallocFromPoolAsync call is captured does not affect the mappings that the graph will make for the allocation.\n\n// boilerplate for the access descs (only Readwrite and Device access supported by  $\\hookleftarrow$  the add node api) accessDesc.flags  $=$  cudaMemAccessFlagsProtReadWrite; accessDesc.location.type  $=$  cudaMemLocationTypeDevice; accessDesc.location.id  $=$  1;\n\n// let memPool be resident and accessible on device 0\n\ncudaStreamBeginCapture(stream); cudaMallocAsync(&dptr1, size, memPool, stream); cudaStreamEndCapture(stream, &graph1);\n\ncudaMemPoolSetAccess(memPool, &accessDesc, 1);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "15.7.2. Peer Access with Stream Capture - cudaStreamBeginCapturestream c......The graph node allocating dptr...",
    "content": "cudaStreamBeginCapture(stream); cudaMallocAsync(&dptr2, size, memPool, stream); cudaStreamEndCapture(stream, &graph2);\n\n//The graph node allocating dptr1 would only have the device 0 accessibility even  $\\hookleftarrow$  though memPool now has device 1 accessibility. //The graph node allocating dptr2 will have device 0 and device 1 accessibility,  $\\hookleftarrow$  since that was the pool accessibility at the time of the cudaMallocAsync call."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 16. Mathematical Functions - The reference manual lists alo......This section provides accuracy...",
    "content": "The reference manual lists, along with their description, all the functions of the  $\\mathtt{C / C + + }$  standard library mathematical functions that are supported in device code, as well as all intrinsic functions (that are only supported in device code).\n\nThis section provides accuracy information for some of these functions when applicable. It uses ULP for quantification. For further information on the definition of the Unit in the Last Place (ULP), please see Jean- Michel Muller's paper On the definition of ulp(x), RR- 5504, LIP RR- 2005- 09, INRIA, LIP. 2005, pp.16 at https://hal.inria.fr/inria- 00070503/document."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 16. Mathematical Functions - Mathematical functions support...",
    "content": "Mathematical functions supported in device code do not set the global error variable, nor report any floating- point exceptions to indicate errors; thus, if error diagnostic mechanisms are required, the user should implement additional screening for inputs and outputs of the functions. The user is responsible for the validity of pointer arguments. The user must not pass uninitialized parameters to the Mathematical functions as this may result in undefined behavior: functions are inlined in the user program and thus are subject to compiler optimizations."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "16.1. Standard Functions - The functions from this sectio......The error bounds are generated...",
    "content": "The functions from this section can be used in both host and device code.\n\nThis section specifies the error bounds of each function when executed on the device and also when executed on the host in the case where the host does not supply the function.\n\nThe error bounds are generated from extensive but not exhaustive tests, so they are not guaranteed bounds."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - Addition and multiplication ar......Table 1 Table 7 SinglePrecisio...",
    "content": "Addition and multiplication are IEEE- compliant, so have a maximum error of 0.5 ulp.\n\nThe recommended way to round a single- precision floating- point operand to an integer, with the result being a single- precision floating- point number is r1ntf(), not roundf(). The reason is that roundf() maps to a 4- instruction sequence on the device, whereas rintf() maps to a single instruction. truncf(), ceilf(), and floorf() each map to a single instruction as well.\n\nTable 1: Table 7. Single-Precision Mathematical Standard Library Functions with Maximum ULP Error. The maximum error is stated as the absolute value of the difference in ulps between a correctly rounded single-precision result and the result returned by the CUDA library function."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - tabletrtdFunctiontdtdMaximum u...",
    "content": "<table><tr><td>Function</td><td>Maximum ulp error</td></tr><tr><td>x+y</td><td>0 (IEEE-754 round-to-nearest-even)</td></tr><tr><td>x*y</td><td>0 (IEEE-754 round-to-nearest-even)</td></tr><tr><td>x/y</td><td>0 for compute capability □ 2 when compiled with -prec-div=true2 (full range), otherwise</td></tr><tr><td>1/x</td><td>0 for compute capability □ 2 when compiled with -prec-div=true1 (full range), otherwise</td></tr><tr><td>rsqrtf(x)1/sqrtf(x)</td><td>2 (full range)Applies to 1/sqrtf(x) only when it is converted to rsqrtf(x) by the compiler.</td></tr><tr><td>sqrtf(x)</td><td>0 when compiled with -prec-sqrt=trueOtherwise 1 for compute capability □ 5."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - 2 and 3 for older architecture...",
    "content": "2 and 3 for older architectures</td></tr><tr><td>cbrtf(x)</td><td>1 (full range)</td></tr><tr><td>rcbrtf(x)</td><td>1 (full range)</td></tr><tr><td>hypotf(x,y)</td><td>3 (full range)</td></tr><tr><td>rhypotf(x,y)</td><td>2 (full range)</td></tr><tr><td>norm3df(x,y,z)</td><td>3 (full range)</td></tr><tr><td>rnorm3df(x,y,z)</td><td>2 (full range)</td></tr><tr><td>norm4df(x,y,z,t)</td><td>3 (full range)</td></tr><tr><td>rnorm4df(x,y,z,t)</td><td>2 (full range)</td></tr><tr><td>normf(dim,arr)</td><td>An error bound cannot be provided because a fast algorithm is used with accuracy loss due to round-off.</td></tr><tr><td>rnormf(dim,arr)</td><td>An error bound cannot be provided because a fast algorithm is used with accuracy loss due to round-off."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - tdtrtrtdexpfxtdtd2 full ranget...",
    "content": "</td></tr><tr><td>expf(x)</td><td>2 (full range)</td></tr><tr><td>exp2f(x)</td><td>2 (full range)</td></tr><tr><td>exp10f(x)</td><td>2 (full range)</td></tr><tr><td>expm1f(x)</td><td>1 (full range)</td></tr><tr><td>logf(x)</td><td>1 (full range)</td></tr><tr><td>log2f(x)</td><td>1 (full range)</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - continues on next page...Table 1continued from previous...",
    "content": "continues on next page\n\nTable 1-continued from previous page"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - tabletrtdFunctiontdtdMaximum u...",
    "content": "<table><tr><td>Function</td><td>Maximum ulp error</td></tr><tr><td>log10f(x)</td><td>2 (full range)</td></tr><tr><td>log1pf(x)</td><td>1 (full range)</td></tr><tr><td>sinf(x)</td><td>2 (full range)</td></tr><tr><td>cosf(x)</td><td>2 (full range)</td></tr><tr><td>tanf(x)</td><td>4 (full range)</td></tr><tr><td>sincosf(x, sptr, cptr)</td><td>2 (full range)</td></tr><tr><td>sinpif(x)</td><td>2 (full range)</td></tr><tr><td>cospif(x)</td><td>2 (full range)</td></tr><tr><td>sincospif(x, sptr, cptr)</td><td>2 (full range)</td></tr><tr><td>asinf(x)</td><td>2 (full range)</td></tr><tr><td>acosf(x)</td><td>2 (full range)</td></tr><tr><td>atanf(x)</td><td>2 (full range)</td></tr><tr><td>atan2f(y, x)</td><td>3 (full range)</td></tr><tr><td>sinhf(x)</td><td>3 (full range)</td></tr><tr><td>coshf(x)</td"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - td2 full rangetdtrtrtdtanhfxtd...",
    "content": "><td>2 (full range)</td></tr><tr><td>tanhf(x)</td><td>2 (full range)</td></tr><tr><td>asinhf(x)</td><td>3 (full range)</td></tr><tr><td>acoshf(x)</td><td>4 (full range)</td></tr><tr><td>atanhf(x)</td><td>3 (full range)</td></tr><tr><td>powf(x, y)</td><td>4 (full range)</td></tr><tr><td>erff(x)</td><td>2 (full range)</td></tr><tr><td>erfcf(x)</td><td>4 (full range)</td></tr><tr><td>erfinvf(x)</td><td>2 (full range)</td></tr><tr><td>erfcinvf(x)</td><td>4 (full range)</td></tr><tr><td>erfcxf(x)</td><td>4 (full range)</td></tr><tr><td>normcdf(x)</td><td>5 (full range)</td></tr><tr><td>normcdfinvf(x)</td><td>5 (full range)</td></tr><tr><td>lgammaf(x)</td><td>6 (outside interval -10."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - 001  2264 larger insidetdtrtrt...",
    "content": "001 ... -2.264; larger inside)</td></tr><tr><td>tgammaf(x)</td><td>5 (full range)</td></tr><tr><td>fmaf(x, y, z)</td><td>0 (full range)</td></tr><tr><td>frexpf(x, exp)</td><td>0 (full range)</td></tr><tr><td>ldexpf(x, exp)</td><td>0 (full range)</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - continues on next page...Table 1continued from previous...",
    "content": "continues on next page\n\nTable 1-continued from previous page"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - tabletrtdFunctiontdtdMaximum u...",
    "content": "<table><tr><td>Function</td><td>Maximum ulp error</td></tr><tr><td>scalbnf(x,n)</td><td>O (full range)</td></tr><tr><td>scalblnf(x,1)</td><td>O (full range)</td></tr><tr><td>logbf(x)</td><td>O (full range)</td></tr><tr><td>ilogbf(x)</td><td>O (full range)</td></tr><tr><td>j0f(x)</td><td>9 for |x| &amp;lt; 8otherwise, the maximum absolute error is 2.2 x 10-6</td></tr><tr><td>j1f(x)</td><td>9 for |x| &amp;lt; 8otherwise, the maximum absolute error is 2.2 x 10-6</td></tr><tr><td>jnf(n,x)</td><td>For n = 128, the maximum absolute error is 2.2 x 10-6</td></tr><tr><td>y0f(x)</td><td>9 for |x| &amp;lt; 8otherwise, the maximum absolute error is 2.2 x 10-6</td></tr><tr><td>y1f(x)</td><td>9 for |x| &amp;lt; 8otherwise, the maximum absolute error is 2."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - 2 x 106tdtrtrtdynfnxtdtdceil2 ...",
    "content": "2 x 10-6</td></tr><tr><td>ynf(n,x)</td><td>ceil(2 + 2.5n) for |x| &amp;lt; notherwise, the maximum absolute error is 2."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - 2 x 106tdtrtrtdcylbesseli0fxtd...",
    "content": "2 x 10-6</td></tr><tr><td>cyl_bessel_i0f(x)</td><td>6 (full range)</td></tr><tr><td>cyl_bessel_itf(x)</td><td>6 (full range)</td></tr><tr><td>fmodf(x,y)</td><td>O (full range)</td></tr><tr><td>remainderf(x,y)</td><td>O (full range)</td></tr><tr><td>remquof(x,y,iptr)</td><td>O (full range)</td></tr><tr><td>modff(x,iptr)</td><td>O (full range)</td></tr><tr><td>fdimf(x,y)</td><td>O (full range)</td></tr><tr><td>truncf(x)</td><td>O (full range)</td></tr><tr><td>roundf(x)</td><td>O (full range)</td></tr><tr><td>rintf(x)</td><td>O (full range)</td></tr><tr><td>nearbyintf(x)</td><td>O (full range)</td></tr><tr><td>ceilf(x)</td><td>O (full range)</td></tr><tr><td>floorf(x)</td><td>O (full range)</td></tr><tr><td>lrintf(x)</td><td>O (full range)</td></tr><tr><td>lroundf(x)</td><td>O (full range)</t"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - dtrtable",
    "content": "d></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - continues on next page...tabletrtdFunctiontdtdMaximum u...",
    "content": "continues on next page\n\nTable 1-continued from previous page\n\n<table><tr><td>Function</td><td>Maximum ulp error</td></tr><tr><td>llrintf(x)</td><td>O (full range)</td></tr><tr><td>llroundf(x)</td><td>O (full range)</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Double-Precision Floating-Point Functions - The recommended way to round a......Table 2 Table 8 DoublePrecisio...",
    "content": "The recommended way to round a double- precision floating- point operand to an integer, with the result being a double- precision floating- point number is rint(), not round(). The reason is that round() maps to a 5- instruction sequence on the device, whereas rint() maps to a single instruction. trunc(), ceil(), and floor() each map to a single instruction as well.\n\nTable 2: Table 8. Double-Precision Mathematical Standard Library Functions with Maximum ULP Error. The maximum error is stated as the absolute value of the difference in ulps between a correctly rounded double-precision result and the result returned by the CUDA library function."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Double-Precision Floating-Point Functions - tabletrtdFunctiontdtdMaximum u...",
    "content": "<table><tr><td>Function</td><td>Maximum ulp error</td></tr><tr><td>x+y</td><td>O (IEEE-754 round-to-nearest-even)</td></tr><tr><td>x*y</td><td>O (IEEE-754 round-to-nearest-even)</td></tr><tr><td>x/y</td><td>O (IEEE-754 round-to-nearest-even)</td></tr><tr><td>1/x</td><td>O (IEEE-754 round-to-nearest-even)</td></tr><tr><td>sqrt(x)</td><td>O (IEEE-754 round-to-nearest-even)</td></tr><tr><td>rsqrt(x)</td><td>1 (full range)</td></tr><tr><td>cbrt(x)</td><td>1 (full range)</td></tr><tr><td>rcbrt(x)</td><td>1 (full range)</td></tr><tr><td>hypot(x,y)</td><td>2 (full range)</td></tr><tr><td>rhypot(x,y)</td><td>1 (full range)</td></tr><tr><td>norm3d(x,y,z)</td><td>2 (full range)</td></tr><tr><td>rnorm3d(x,y,z)</td><td>1 (full range)</td></tr><tr><td>norm4d(x,y,z,t)</td><td>2 (full range)</td></tr><tr"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Double-Precision Floating-Point Functions - tdrnorm4dxyzttdtd1 full ranget...",
    "content": "><td>rnorm4d(x,y,z,t)</td><td>1 (full range)</td></tr><tr><td>norm(dim,arr)</td><td>An error bound cannot be provided because a fast algorithm is used with accuracy loss due to round-off."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Double-Precision Floating-Point Functions - tdtrtrtdrnormdimarrtdtdAn erro...",
    "content": "</td></tr><tr><td>rnorm(dim,arr)</td><td>An error bound cannot be provided because a fast algorithm is used with accuracy loss due to round-off.</td></tr><tr><td>exp(x)</td><td>1 (full range)</td></tr><tr><td>exp2(x)</td><td>1 (full range)</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Double-Precision Floating-Point Functions - continues on next page...Table 2continued from previous...",
    "content": "continues on next page\n\nTable 2-continued from previous page"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Double-Precision Floating-Point Functions - tabletrtdFunctiontdtdMaximum u...",
    "content": "<table><tr><td>Function</td><td>Maximum ulp error</td></tr><tr><td>exp10(x)</td><td>1 (full range)</td></tr><tr><td>expm1(x)</td><td>1 (full range)</td></tr><tr><td>log(x)</td><td>1 (full range)</td></tr><tr><td>log2(x)</td><td>1 (full range)</td></tr><tr><td>log10(x)</td><td>1 (full range)</td></tr><tr><td>log1p(x)</td><td>1 (full range)</td></tr><tr><td>sin(x)</td><td>2 (full range)</td></tr><tr><td>cos(x)</td><td>2 (full range)</td></tr><tr><td>tan(x)</td><td>2 (full range)</td></tr><tr><td>sincos(x, sptr, cptr)</td><td>2 (full range)</td></tr><tr><td>sinpi(x)</td><td>2 (full range)</td></tr><tr><td>cospi(x)</td><td>2 (full range)</td></tr><tr><td>sincospi(x, sptr, cptr)</td><td>2 (full range)</td></tr><tr><td>asin(x)</td><td>2 (full range)</td></tr><tr><td>acos(x)</td><td>2 (full range"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Double-Precision Floating-Point Functions - tdtrtrtdatanxtdtd2 full ranget...",
    "content": ")</td></tr><tr><td>atan(x)</td><td>2 (full range)</td></tr><tr><td>atan2(y, x)</td><td>2 (full range)</td></tr><tr><td>sinh(x)</td><td>2 (full range)</td></tr><tr><td>cosh(x)</td><td>1 (full range)</td></tr><tr><td>tanh(x)</td><td>1 (full range)</td></tr><tr><td>asinh(x)</td><td>2 (full range)</td></tr><tr><td>acosh(x)</td><td>2 (full range)</td></tr><tr><td>atanh(x)</td><td>2 (full range)</td></tr><tr><td>pow(x, y)</td><td>2 (full range)</td></tr><tr><td>erf(x)</td><td>2 (full range)</td></tr><tr><td>erfc(x)</td><td>5 (full range)</td></tr><tr><td>erfinv(x)</td><td>5 (full range)</td></tr><tr><td>erfcinv(x)</td><td>6 (full range)</td></tr><tr><td>erfcx(x)</td><td>4 (full range)</td></tr><tr><td>normcdf(x)</td><td>5 (full range)</td></tr><tr><td>normcdfinv(x)</td><td>8 (full range)</td></t"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Double-Precision Floating-Point Functions - rtable",
    "content": "r></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Double-Precision Floating-Point Functions - continues on next page...Table 2continued from previous...",
    "content": "continues on next page\n\nTable 2-continued from previous page"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Double-Precision Floating-Point Functions - tabletrtdFunctiontdtdMaximum u...",
    "content": "<table><tr><td>Function</td><td>Maximum ulp error</td></tr><tr><td>lgamma(x)</td><td>4 (outside interval -11.0001 ... -2.2637; larger in-side)</td></tr><tr><td>tgamma(x)</td><td>10 (full range)</td></tr><tr><td>fma(x,y,z)</td><td>0 (IEEE-754 round-to-nearest-even)</td></tr><tr><td>frexp(x,exp)</td><td>0 (full range)</td></tr><tr><td>ldexp(x,exp)</td><td>0 (full range)</td></tr><tr><td>scalbn(x,n)</td><td>0 (full range)</td></tr><tr><td>scalbln(x,l)</td><td>0 (full range)</td></tr><tr><td>logb(x)</td><td>0 (full range)</td></tr><tr><td>ilogb(x)</td><td>0 (full range)</td></tr><tr><td>jθ(x)</td><td>7 for |x| &amp;lt; 8otherwise, the maximum absolute error is 5 x 10-12</td></tr><tr><td>j1(x)</td><td>7 for |x| &amp;lt; 8"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Double-Precision Floating-Point Functions - otherwise the maximum absolute...",
    "content": "otherwise, the maximum absolute error is 5 x 10-12</td></tr><tr><td>jn(n,x)</td><td>For n = 128, the maximum absolute error is 5 x 10-12</td></tr><tr><td>yθ(x)</td><td>7 for |x| &amp;lt; 8otherwise, the maximum absolute error is 5 x 10-12</td></tr><tr><td>y1(x)</td><td>7 for |x| &amp;lt; 8otherwise, the maximum absolute error is 5 x 10-12</td></tr><tr><td>yn(n,x)</td><td>For |x| &amp;gt; 1."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Double-Precision Floating-Point Functions - 5n the maximum absolute error ...",
    "content": "5n, the maximum absolute error is 5 x 10-12</td></tr><tr><td>cyl_bessel_iθ(x)</td><td>6 (full range)</td></tr><tr><td>cyl_bessel_it(x)</td><td>6 (full range)</td></tr><tr><td>fmod(x,y)</td><td>0 (full range)</td></tr><tr><td>remainder(x,y)</td><td>0 (full range)</td></tr><tr><td>remquo(x,y,iptr)</td><td>0 (full range)</td></tr><tr><td>modf(x,iptr)</td><td>0 (full range)</td></tr><tr><td>fdim(x,y)</td><td>0 (full range)</td></tr><tr><td>trunc(x)</td><td>0 (full range)</td></tr><tr><td>round(x)</td><td>0 (full range)</td></tr><tr><td>rint(x)</td><td>0 (full range)</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Double-Precision Floating-Point Functions - continues on next page...tabletrtdFunctiontdtdMaximum u...",
    "content": "continues on next page\n\nTable 2-continued from previous page\n\n<table><tr><td>Function</td><td>Maximum ulp error</td></tr><tr><td>nearbyint(x)</td><td>O (full range)</td></tr><tr><td>ceil(x)</td><td>O (full range)</td></tr><tr><td>floor(x)</td><td>O (full range)</td></tr><tr><td>lrint(x)</td><td>O (full range)</td></tr><tr><td>lround(x)</td><td>O (full range)</td></tr><tr><td>llrint(x)</td><td>O (full range)</td></tr><tr><td>llround(x)</td><td>O (full range)</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "16.2. Intrinsic Functions - The functions from this sectio...",
    "content": "The functions from this section can only be used in device code."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "16.2. Intrinsic Functions - Among these functions are the ...",
    "content": "Among these functions are the less accurate, but faster versions of some of the functions of Standard Functions. They have the same name prefixed with __. (such as __sinf(x)). They are faster as they map to fewer native instructions. The compiler has an option (- - use_fast_math) that forces each function in Table 9 to compile to its intrinsic counterpart. In addition to reducing the accuracy of the affected functions, it may also cause some differences in special case handling. A more robust approach is to selectively replace mathematical function calls by calls to intrinsic functions only where it is merited by the performance gains and where changed properties such as reduced accuracy and different special case handling can be tolerated."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "16.2. Intrinsic Functions - Table 3 Table 9 Functions Affe......tabletrtdOperatorFunctiontdtdD...",
    "content": "Table 3: Table 9. Functions Affected by -use_fast_math\n\n<table><tr><td>Operator/Function</td><td>Device Function</td></tr><tr><td>x/y</td><td>__fdividef(x,y)</td></tr><tr><td>sinf(x)</td><td>__sinf(x)</td></tr><tr><td>cosf(x)</td><td>__cosf(x)</td></tr><tr><td>tanf(x)</td><td>__tanf(x)</td></tr><tr><td>sincosf(x,sptr,cptr)</td><td>__sincosf(x,sptr,cptr)</td></tr><tr><td>logf(x)</td><td>__logf(x)</td></tr><tr><td>log2f(x)</td><td>__log2f(x)</td></tr><tr><td>log10f(x)</td><td>__log10f(x)</td></tr><tr><td>expf(x)</td><td>__expf(x)</td></tr><tr><td>exp10f(x)</td><td>__exp10f(x)</td></tr><tr><td>powf(x,y)</td><td>__powf(x,y)</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - faddrn rz ru rd and fmulrn rz ......Functions suffixed with rd ope...",
    "content": "__fadd_[rn, rz, ru, rd]( and __fmul_[rn, rz, ru, rd]( map to addition and multiplication operations that the compiler never merges into FMADs. By contrast, additions and multiplications generated from the \" and  $^{\\circ} + ^{\\circ}$  operators will frequently be combined into FMADs.\n\nFunctions suffixed with _rn operate using the round to nearest even rounding mode.\n\nFunctions suffixed with _rz operate using the round towards zero rounding mode.\n\nFunctions suffixed with _ru operate using the round up (to positive infinity) rounding mode.\n\nFunctions suffixed with _rd operate using the round down (to negative infinity) rounding mode."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - The accuracy of floating point...",
    "content": "The accuracy of floating- point division varies depending on whether the code is compiled with - prec- div  $\\equiv$  false or - prec- div  $\\equiv$  true. When the code is compiled with - prec- div  $\\equiv$  false, both the regular division / operator and __fdividef  $(x,y)$  have the same accuracy, but for  $2^{126}< |y|<$ $2^{128}$  , - - fdividef  $(x,y)$  delivers a result of zero, whereas the / operator delivers the correct result to within the accuracy stated in Table 10. Also, for  $2^{126}< |y|< 2^{128}$  , if  $\\times$  is infinity, - - fdividef  $(x,$  y) delivers a NaN (as a result of multiplying infinity by zero), while the / operator returns infinity."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - On the other hand the  operato...",
    "content": " On the other hand, the / operator is IEEE- compliant when the code is compiled with - prec- div  $\\equiv$  true or without any - prec- div option at all since its default value is true."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - Table 4 Table 10 SinglePrecisi...",
    "content": "Table 4: Table 10. Single-Precision Floating-Point Intrinsic Functions. (Supported by the CUDA Runtime Library with Respective Error Bounds)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - tabletrtdFunctiontdtdError bou...",
    "content": "<table><tr><td>Function</td><td>Error bounds</td></tr><tr><td>__fadd_[rn, rz, ru, rd](x,y)</td><td>IEEE-compliant.</td></tr><tr><td>__fsub_[rn, rz, ru, rd](x,y)</td><td>IEEE-compliant.</td></tr><tr><td>__fmul_[rn, rz, ru, rd](x,y)</td><td>IEEE-compliant.</td></tr><tr><td>__fmaf_[rn, rz, ru, rd](x,y,z)</td><td>IEEE-compliant.</td></tr><tr><td>__frcp_[rn, rz, ru, rd](x)</td><td>IEEE-compliant.</td></tr><tr><td>__fsqrt_[rn, rz, ru, rd](x)</td><td>IEEE-compliant.</td></tr><tr><td>__frsqrt_rn(x)</td><td>IEEE-compliant.</td></tr><tr><td>__fdiv_[rn, rz, ru, rd](x,y)</td><td>IEEE-compliant.</td></tr><tr><td>__fdividef(x,y)</td><td>For |y| in [2-126, 2126], the maximum ulp error is 2.</td></tr><tr><td>__expf(x)</td><td>The maximum ulp error is 2 + floor(abs(1.16 * x))."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - tdtrtrtdexp10fxtdtdThe maximum...",
    "content": "</td></tr><tr><td>__exp10f(x)</td><td>The maximum ulp error is 2+ floor(abs(2.95 * x)).</td></tr><tr><td>__logf(x)</td><td>For x in [0.5, 2], the maximum absolute error is 2-21.41, otherwise, the maximum ulp error is 3.</td></tr><tr><td>__log2f(x)</td><td>For x in [0.5, 2], the maximum absolute error is 2-24, otherwise, the maximum ulp error is 2.</td></tr><tr><td>__log10f(x)</td><td>For x in [0.5, 2], the maximum absolute error is 2-24, otherwise, the maximum ulp error is 3.</td></tr><tr><td>__sinf(x)</td><td>For x in [-0, 0], the maximum absolute error is 2-21.41, and larger otherwise.</td></tr><tr><td>__cosf(x)</td><td>For x in [-0, 0], the maximum absolute error is 2-21.19, and larger otherwise.</td></tr><tr><td>__sincosf(x, sptr, cptr)</td><td>Same as __sinf(x) and __cosf(x)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Single-Precision Floating-Point Functions - tdtrtrtdtanfxtdtdDerived from ...",
    "content": "</td></tr><tr><td>__tanf(x)</td><td>Derived from its implementation as __sinf(x) * (1/__cosf(x)).</td></tr><tr><td>__powf(x, y)</td><td>Derived from its implementation as exp2f(y * __log2f(x)).</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Double-Precision Floating-Point Functions - daddrn and dmulrn map to addit......Table 5 Table 11 DoublePrecisi...",
    "content": "__dadd_rn() and __dmul_rn() map to addition and multiplication operations that the compiler never merges into FMADs. By contrast, additions and multiplications generated from the '*' and '+' operators will frequently be combined into FMADs.\n\nTable 5: Table 11. Double-Precision Floating-Point Intrinsic Functions. (Supported by the CUDA Runtime Library with Respective Error Bounds)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Double-Precision Floating-Point Functions - tabletrtdFunctiontdtdError bou......Requires compute capability am...",
    "content": "<table><tr><td>Function</td><td>Error bounds</td></tr><tr><td>__dadd__[rn,rz,ru,rd](x,y)</td><td>IEEE-compliant.</td></tr><tr><td>__dsub__[rn,rz,ru,rd](x,y)</td><td>IEEE-compliant.</td></tr><tr><td>__dmul__[rn,rz,ru,rd](x,y)</td><td>IEEE-compliant.</td></tr><tr><td>__fma__[rn,rz,ru,rd](x,y,z)</td><td>IEEE-compliant.</td></tr><tr><td>__ddiv__[rn,rz,ru,rd](x,y)(x,y)</td><td>IEEE-compliant.\nRequires compute capability &amp;gt; 2.</td></tr><tr><td>__drcp__[rn,rz,ru,rd](x)</td><td>IEEE-compliant.\nRequires compute capability &amp;gt; 2.</td></tr><tr><td>__dsqrt__[rn,rz,ru,rd](x)</td><td>IEEE-compliant.\nRequires compute capability &amp;gt; 2.</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "CUDA C++ Programming Guide, Release 12.1",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 17. C++ Language Support - As described in Compilation wi...",
    "content": "As described in Compilation with NVCC, CUDA source files compiled with nvcc can include a mix of host code and device code. The CUDA front- end compiler aims to emulate the host compiler behavior with respect to  $\\mathtt{C + + }$  input code. The input source code is processed according to the  $\\mathtt{C + + }$  ISO/IEC 14882:2003,  $\\mathtt{C + + }$  ISO/IEC 14882:2011,  $\\mathtt{C + + }$  ISO/IEC 14882:2014 or  $\\mathtt{C + + }$  ISO/IEC 14882:2017 specifications, and the CUDA front- end compiler aims to emulate any host compiler divergences from the ISO specification. In addition, the supported language is extended with CUDA- specific constructs described in this document?, and is subject to the restrictions described below."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 17. C++ Language Support - mathttC   11  Language Feature...",
    "content": "$\\mathtt{C + + 11}$  Language Features,  $\\mathtt{C + + 14}$  Language Features and  $\\mathtt{C + + 17}$  Language Features provide support matrices for the  $\\mathtt{C + + 11}$ $\\mathtt{C + + 14}$ $\\mathtt{C + + 17}$  and  $\\mathtt{C + + 20}$  features, respectively. Restrictions lists the language restrictions. Polymorphic Function Wrappers and Extended Lambdas describe additional features. Code Samples gives code samples."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.1. C++11 Language Features - The following table lists new ......Table 1 Table 12  mathttC   11...",
    "content": "The following table lists new language features that have been accepted into the  $\\mathtt{C + + 11}$  standard. The \"Proposal\" column provides a link to the ISO  $\\mathtt{C + + }$  committee proposal that describes the feature, while the \"Available in nvcc (device code)\" column indicates the first version of nvcc that contains an implementation of this feature (if it has been implemented) for device code.\n\nTable 1: Table 12.  $\\mathtt{C + + 11}$  Language Features"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.1. C++11 Language Features - tabletrtdLanguage FeaturetdtdC......Table 1continued from previous...",
    "content": "<table><tr><td>Language Feature</td><td>C++11 Proposal</td><td>Available in</td></tr><tr><td>Rvalue references</td><td>N2118</td><td>7.0</td></tr><tr><td>Rvalue references for *this</td><td>N2439</td><td>7.0</td></tr><tr><td>Initialization of class objects by rvalues</td><td>N1610</td><td>7.0</td></tr><tr><td>Non-static data member initializers</td><td>N2756</td><td>7.0</td></tr><tr><td>Variadic templates</td><td>N2242</td><td>7.0</td></tr><tr><td>Extending variadic template template parameters</td><td>N2555</td><td>7.0</td></tr><tr><td>Initializer lists</td><td>N2672</td><td>7.0</td></tr><tr><td>Static assertions</td><td>N1720</td><td>7.0</td></tr><tr><td>auto-typed variables</td><td>N1984</td><td>7.0</td></tr></table>\n\nTable 1-continued from previous page"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.1. C++11 Language Features - tabletrtdLanguage FeaturetdtdC...",
    "content": "<table><tr><td>Language Feature</td><td>C++11 Proposal</td><td>Available in</td></tr><tr><td>Multi-declarator auto</td><td>N1737</td><td>7.0</td></tr><tr><td>Removal of auto as a storage-class specifier</td><td>N2546</td><td>7.0</td></tr><tr><td>New function declarator syntax</td><td>N2541</td><td>7.0</td></tr><tr><td>Lambda expressions</td><td>N2927</td><td>7.0</td></tr><tr><td>Declared type of an expression</td><td>N2343</td><td>7.0</td></tr><tr><td>Incomplete-return types</td><td>N3276</td><td>7.0</td></tr><tr><td>Right angle brackets</td><td>N1757</td><td>7.0</td></tr><tr><td>Default template arguments for function templates</td><td>DR226</td><td>7.0</td></tr><tr><td>Solving the SFINAE problem for expressions</td><td>DR339</td><td>7."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.1. C++11 Language Features - 0tdtrtrtdAlias templatestdtdN2...",
    "content": "0</td></tr><tr><td>Alias templates</td><td>N2258</td><td>7.0</td></tr><tr><td>Extern templates</td><td>N1987</td><td>7.0</td></tr><tr><td>Null pointer constant</td><td>N2431</td><td>7.0</td></tr><tr><td>Strongly-typed enums</td><td>N2347</td><td>7.0</td></tr><tr><td>Forward declarations for enums</td><td>N2764 DR1206</td><td>7.0</td></tr><tr><td>Standardized attribute syntax</td><td>N2761</td><td>7.0</td></tr><tr><td>Generalized constant expressions</td><td>N2235</td><td>7.0</td></tr><tr><td>Alignment support</td><td>N2341</td><td>7.0</td></tr><tr><td>Conditionally-support behavior</td><td>N1627</td><td>7.0</td></tr><tr><td>Changing undefined behavior into diagnosable errors</td><td>N1727</td><td>7.0</td></tr><tr><td>Delegating constructors</td><td>N1986</td><td>7."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.1. C++11 Language Features - 0tdtrtrtdInheriting constructo...",
    "content": "0</td></tr><tr><td>Inheriting constructors</td><td>N2540</td><td>7.0</td></tr><tr><td>Explicit conversion operators</td><td>N2437</td><td>7.0</td></tr><tr><td>New character types</td><td>N2249</td><td>7.0</td></tr><tr><td>Unicode string literals</td><td>N2442</td><td>7.0</td></tr><tr><td>Raw string literals</td><td>N2442</td><td>7.0</td></tr><tr><td>Universal character names in literals</td><td>N2170</td><td>7.0</td></tr><tr><td>User-defined literals</td><td>N2765</td><td>7.0</td></tr><tr><td>Standard Layout Types</td><td>N2342</td><td>7.0</td></tr><tr><td>Defaulted functions</td><td>N2346</td><td>7.0</td></tr><tr><td>Deleted functions</td><td>N2346</td><td>7.0</td></tr><tr><td>Extended friend declarations</td><td>N1791</td><td>7."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.1. C++11 Language Features - 0tdtrtrtdExtending sizeoftdtdN...",
    "content": "0</td></tr><tr><td>Extending sizeof</td><td>N2253 DR850</td><td>7.0</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.1. C++11 Language Features - Table 1continued from previous...",
    "content": "Table 1-continued from previous page"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.1. C++11 Language Features - tabletrtdLanguage FeaturetdtdC...",
    "content": "<table><tr><td>Language Feature</td><td>C++11 Proposal</td><td>Available in</td></tr><tr><td>Inline namespaces</td><td>N2535</td><td>7.0</td></tr><tr><td>Unrestricted unions</td><td>N2544</td><td>7.0</td></tr><tr><td>Local and unnamed types as template arguments</td><td>N2657</td><td>7.0</td></tr><tr><td>Range-based for</td><td>N2930</td><td>7.0</td></tr><tr><td>Explicit virtual overrides</td><td>N2928 N3206 N3272</td><td>7.0</td></tr><tr><td>Minimal support for garbage collection and reachability-based leak detection</td><td>N2670</td><td>N/A (see Res</td></tr><tr><td>Allowing move constructors to throw [noexcept]</td><td>N3050</td><td>7.0</td></tr><tr><td>Defining move special member functions</td><td>N3053</td><td>7."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.1. C++11 Language Features - 0tdtrtrtdConcurrencytdtdtdtdtd...",
    "content": "0</td></tr><tr><td>Concurrency</td><td></td><td></td></tr><tr><td>Sequence points</td><td>N2239</td><td></td></tr><tr><td>Atomic operations</td><td>N2427</td><td></td></tr><tr><td>Strong Compare and Exchange</td><td>N2748</td><td></td></tr><tr><td>Bidirectional Fences</td><td>N2752</td><td></td></tr><tr><td>Memory model</td><td>N2429</td><td></td></tr><tr><td>Data-dependency ordering: atomics and memory model</td><td>N2664</td><td></td></tr><tr><td>Propagating exceptions</td><td>N2179</td><td></td></tr><tr><td>Allow atomics use in signal handlers</td><td>N2547</td><td></td></tr><tr><td>Thread-local storage</td><td>N2659</td><td></td></tr><tr><td>Dynamic initialization and destruction with concurrency</td><td>N2660</td><td></td></tr><tr><td>C99 Features in C++11</td><td></td><td></td></tr><"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.1. C++11 Language Features - trtdfunc predefined identifier...",
    "content": "tr><td>__func__ predefined identifier</td><td>N2340</td><td>7."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.1. C++11 Language Features - 0tdtrtrtdC99 preprocessortdtdN...",
    "content": "0</td></tr><tr><td>C99 preprocessor</td><td>N1653</td><td>7.0</td></tr><tr><td>long long</td><td>N1811</td><td>7.0</td></tr><tr><td>Extended integral types</td><td>N1988</td><td></td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.2. C++14 Language Features - The following table lists new ......Table 2 Table 13  mathttC   14...",
    "content": "The following table lists new language features that have been accepted into the C++14 standard.\n\nTable 2: Table 13.  $\\mathtt{C + + 14}$  Language Features"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.2. C++14 Language Features - tabletrtdLanguage FeaturetdtdC...",
    "content": "<table><tr><td>Language Feature</td><td>C++14 Proposal</td><td>Available in nvcc (device code)</td></tr><tr><td>Tweak to certain C++ contextual conversions</td><td>N3323</td><td>9.0</td></tr><tr><td>Binary literals</td><td>N3472</td><td>9.0</td></tr><tr><td>Functions with deduced return type</td><td>N3638</td><td>9.0</td></tr><tr><td>Generalized lambda capture (init-capture)</td><td>N3648</td><td>9.0</td></tr><tr><td>Generic (polymorphic) lambda expressions</td><td>N3649</td><td>9.0</td></tr><tr><td>Variable templates</td><td>N3651</td><td>9.0</td></tr><tr><td>Relaxing requirements on constexpr functions</td><td>N3652</td><td>9.0</td></tr><tr><td>Member initializers and aggregates</td><td>N3653</td><td>9."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.2. C++14 Language Features - 0tdtrtrtdClarifying memory all...",
    "content": "0</td></tr><tr><td>Clarifying memory allocation</td><td>N3664</td><td></td></tr><tr><td>Sized deallocation</td><td>N3778</td><td></td></tr><tr><td>[[deprecated]] attribute</td><td>N3760</td><td>9.0</td></tr><tr><td>Single-quotation-mark as a digit separator</td><td>N3781</td><td>9.0</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.1. Host Compiler Extensions - All  mathttC   17  language fe......Host compiler specific languag...",
    "content": "All  $\\mathtt{C + + 17}$  language features are supported in nvcc version 11.0 and later, subject to restrictions described here.\n\n# 17.4. C++20 Language Features\nAll  $\\mathtt{C + + 20}$  language features are supported in nvcc version 12.0 and later, subject to restrictions described here.\n\n# 17.5. Restrictions\n\n# 17.5.1. Host Compiler Extensions\nHost compiler specific language extensions are not supported in device code.  - - Complex types are only supported in host code.  - - int128 type is supported in device code when compiled in conjunction with a host compiler that supports it."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.1. Host Compiler Extensions - float128 type is only supporte...",
    "content": "float128 type is only supported in host code on 64- bit x86 Linux platforms. A constant expression of __float128 type may be processed by the compiler in a floating point representation with lower precision.\n\n# 17.5.2. Preprocessor Symbols"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.2.1 CUDA_ARCH__ - 1 The type signature of the fo......2 If a global function templat...",
    "content": "1. The type signature of the following entities shall not depend on whether __CUDA_ARCH__ is defined or not, or on a particular value of __CUDA_ARCH__:\n\n- global__ functions and function templates- device__ and __constant__ variables- textures and surfaces\n\nExample:\n\nif !defined(__CUDA_ARCH__)  typedef int mytype;  #else  typedef double mytype;  #endif  __device__ mytype xxx; // error: xxx's type depends on __CUDA_ARCH__  __global__ void foo(mytype in, // error: foo's type depends on __CUDA_ARCH__ mytype *ptr)  {      *ptr = in;  }\n\n2. If a __global__ function template is instantiated and launched from the host, then the function template must be instantiated with the same template arguments irrespective of whether __CUDA_ARCH__ is defined and regardless of the value of __CUDA_ARCH__."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.2.1 CUDA_ARCH__ - Example",
    "content": "Example:\n\n__device__ int result;  template <typename T>  __global__ void kern(T in)  {      result = in;  }  __host__ __device__ void foo(void)  {      #if !defined(__CUDA_ARCH__)          kern<<<1,1>>>(1); // error: \"kern<int>\" instantiation only          // when __CUDA_ARCH__ is undefined!      #endif  }  int main(void)  {      foo();\n\n(continues on next page)\n\ncudaDeviceSynchronize(); return 0; }\n\n3. In separate compilation mode, the presence or absence of a definition of a function or variable with external linkage shall not depend on whether  $\\text{__CUDA\\_ARCH\\_\\_}$  is defined or on a particular value of  $\\text{__CUDA\\_ARCH\\_\\_}$  Page 279, 14.\n\nExample:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.2.1 CUDA_ARCH__ - if definedCUDAARCH void foovoi......For example if an ah contains",
    "content": "if !defined(__CUDA_ARCH__) void foo(void) {} // error: The definition of foo() // is only present when  $\\text{__CUDA\\_ARCH\\_\\_}$  // is undefined #endif\n\n4. In separate compilation,  $\\text{__CUDA\\_ARCH\\_\\_}$  must not be used in headers such that different objects could contain different behavior. Or, it must be guaranteed that all objects will compile for the same compute_arch. If a weak function or template function is defined in a header and its behavior depends on  $\\text{__CUDA\\_ARCH\\_\\_}$ , then the instances of that function in the objects could conflict if the objects are compiled for different compute arch.\n\nFor example, if an a.h contains:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.2.1 CUDA_ARCH__ - templatetypename T  textdevice......At link time only one version ...",
    "content": "template<typename T>  $\\text{__device\\_}$  T\\* getptr(void) { #if  $\\text{__CUDA\\_ARCH\\_\\_}$ $= = 200$  return NULL; /\\* no address \\*/ #else  $\\text{__shared\\_\\_}$  T arr[256]; return arr; #endif }\n\nThen if a . cu and b . cu both include a . h and instantiate getptr for the same type, and b . cu expects a non- NULL address, and compile with:\n\nnvcc - arch=compute_20 - dc a . cu  nvcc - arch=compute_30 - dc b . cu  nvcc - arch=sm_30 a . o b . o\n\nAt link time only one version of the getptr is used, so the behavior would depend on which version is chosen. To avoid this, either a . cu and b . cu must be compiled for the same compute arch, or  $\\text{__CUDA\\_ARCH\\_\\_}$  should not be used in the shared header function."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.2.1 CUDA_ARCH__ - The compiler does not guarante...",
    "content": "The compiler does not guarantee that a diagnostic will be generated for the unsupported uses of  $\\text{__CUDA\\_ARCH\\_\\_}$  described above."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.3. Qualifiers",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.3.1 Device Memory Space Specifiers - The device shared managed and ......A device constant managed or s...",
    "content": "The __device__, __shared__, __managed__ and __constant__ memory space specifiers are not allowed on:\n\nclass, struct, and union data members, formal parameters, non- extern variable declarations within a function that executes on the host.\n\nThe __device__, __constant__ and __managed__ memory space specifiers are not allowed on variable declarations that are neither extern nor static within a function that executes on the device.\n\nA __device__, __constant__, __managed__ or __shared__ variable definition cannot have a class type with a non- empty constructor or a non- empty destructor. A constructor for a class type is considered empty at a point in the translation unit, if it is either a trivial constructor or it satisfies all of the following conditions:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.3.1 Device Memory Space Specifiers - The constructor function has b......A destructor for a class is co...",
    "content": "The constructor function has been defined. The constructor function has no parameters, the initializer list is empty and the function body is an empty compound statement. Its class has no virtual functions, no virtual base classes and no non- static data member initializers. The default constructors of all base classes of its class can be considered empty. For all the nonstatic data members of its class that are of class type (or array thereof), the default constructors can be considered empty.\n\nA destructor for a class is considered empty at a point in the translation unit, if it is either a trivial destructor or it satisfies all of the following conditions:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.3.1 Device Memory Space Specifiers - The destructor function has be......When compiling in the whole pr...",
    "content": "The destructor function has been defined. The destructor function body is an empty compound statement. Its class has no virtual functions and no virtual base classes. The destructors of all base classes of its class can be considered empty. For all the nonstatic data members of its class that are of class type (or array thereof), the destructor can be considered empty.\n\nWhen compiling in the whole program compilation mode (see the nvcc user manual for a description of this mode), __device__, __shared__, __managed__ and __constant__ variables cannot be defined as external using the extern keyword. The only exception is for dynamically allocated __shared__ variables as described in index.html#__shared__."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.3.1 Device Memory Space Specifiers - When compiling in the separate...",
    "content": "When compiling in the separate compilation mode (see the nvcc user manual for a description of this mode), __device__, __shared__, __managed__ and __constant__ variables can be defined as external using the extern keyword. nvlink will generate an error when it cannot find a definition for an external variable (unless it is a dynamically allocated __shared__ variable)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.3.2 Managed__ Memory Space Specifier - Variables marked with the mana...",
    "content": "Variables marked with the __managed__ memory space specifier (\"managed\" variables) have the following restrictions:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.3.2 Managed__ Memory Space Specifier - The address of a managed varia...",
    "content": "The address of a managed variable is not a constant expression. A managed variable shall not have a const qualified type. A managed variable shall not have a reference type. The address or value of a managed variable shall not be used when the CUDA runtime may not be in a valid state, including the following cases: In static/dynamic initialization or destruction of an object with static or thread local storage duration. In code that executes after exit() has been called (for example, a function marked with gcc's \"__attribute___.((destructor)\"). In code that executes when CUDA runtime may not be initialized (for example, a function marked with gcc's \"_attribute__((constructor)\"). A managed variable cannot be used as an unparenthesized id- expression argument to a de. cltype() expression."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.3.2 Managed__ Memory Space Specifier - Managed variables have the sam...",
    "content": " Managed variables have the same coherence and consistency behavior as specified for dynamically allocated managed memory. When a CUDA program containing managed variables is run on an execution platform with multiple GPUs, the variables are allocated only once, and not per GPU. A managed variable declaration without the extern linkage is not allowed within a function that executes on the host. A managed variable declaration without the extern or static linkage is not allowed within a function that executes on the device."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.3.2 Managed__ Memory Space Specifier - Here are examples of legal and......continued from previous page",
    "content": "Here are examples of legal and illegal uses of managed variables:\n\ndevice__ _managed__ int xxx = 10; // OK int \\*ptr = &xxx; // error: use of managed variable struct S1_t { int field; S1_t(void) : field(xxx) { }; }; struct S2_t { \\~S2_t(void) { xxx = 10; } }; S1_t temp1; // error: use of managed variable // (xxx) in dynamic initialization S2_t temp2; // error: use of managed variable // (xxx) in the destructor of // object with static storage // duration device__ _managed__ const int yyyy = 10; // error: const qualified type (continues on next page)\n\n(continued from previous page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.3.2 Managed__ Memory Space Specifier - device managed int zzz  xxx  e...",
    "content": "device__ _managed__ int &zzz = xxx; // error: reference type  template <int *addr> struct s3_t { };  S3_t<&xxx> temp; // error: address of managed  // variable(xxx) not a  // constant expression  global__ void kern(int *ptr)  {      assert(ptr == &xxx); // OK      xxx = 20; // OK  }  int main(void)  {      int *ptr = &xxx; // OK      kern<<<1,1>>>(ptr);      cudaDeviceSynchronize();      xxx++; // OK      decltype(xxx) qqq; // error: managed variable(xxx) used      // as unparenthesized argument to      // decltype  decltype((xxx)) zzz = yyy; // OK  }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.3.3 Volatile Qualifier - The compiler is free to optimi......These optimizations can be dis...",
    "content": "# 17.5.3.3 Volatile Qualifier\nThe compiler is free to optimize reads and writes to global or shared memory (for example, by caching global reads into registers or L1 cache) as long as it respects the memory ordering semantics of memory fence functions (Memory Fence Functions) and memory visibility semantics of synchronization functions (Synchronization Functions).\n\nThese optimizations can be disabled using the volatile keyword: If a variable located in global or shared memory is declared as volatile, the compiler assumes that its value can be changed or used at any time by another thread and therefore any reference to this variable compiles to an actual memory read or write instruction."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.5. Operators - Dereferencing a pointer either......The address obtained by taking...",
    "content": "# 17.5.4. Pointers\nDereferencing a pointer either to global or shared memory in code that is executed on the host, or to host memory in code that is executed on the device results in an undefined behavior, most often in a segmentation fault and application termination.\n\nThe address obtained by taking the address of a __device__, __shared__ or __constant__ variable can only be used in device code. The address of a __device__ or __constant__ variable obtained through cudaGetSymbolAddress() as described in Device Memory can only be used in host code.\n\n# 17.5.5. Operators\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.6. Run Time Type Information (RTTI) - constant variables can only be......typeid operator stdtypeinfo dy...",
    "content": "# 17.5.5.1 Assignment Operator\nconstant__ variables can only be assigned from the host code through runtime functions (Device Memory); they cannot be assigned from the device code. shared__ variables cannot have an initialization as part of their declaration. It is not allowed to assign values to any of the built- in variables defined in Built- in Variables.\n\n# 17.5.5.2 Address Operator\nIt is not allowed to take the address of any of the built- in variables defined in Built- in Variables.\n\n# 17.5.6. Run Time Type Information (RTTI)\nThe following RTTI- related features are supported in host code, but not in device code.\n\n- typeid operator- std::type_info- dynamic_cast operator"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.8. Standard Library - Exception handling is only sup......Standard libraries are only su...",
    "content": "Exception handling is only supported in host code, but not in device code. Exception specification is not supported for __global__ functions.\n\n# 17.5.8. Standard Library\nStandard libraries are only supported in host code, but not in device code, unless specified otherwise."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.9. Namespace Reservations - Unless an exception is otherwi......continues on next page",
    "content": "Unless an exception is otherwise noted, it is undefined behavior to add any declarations or definitions to cuda::, nv::, cooperative_groups:: or any namespace nested within.\n\nExamples:\n\nnamespace cuda {    // Bad: class declaration added to namespace cuda    struct foo{};    // Bad: function definition added to namespace cuda}\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.9. Namespace Reservations - cudaStreamt makestream     cud...",
    "content": "cudaStream_t make_stream() {    cudaStream_t s;    cudaStreamCreate(&s);    return s;} // namespace cudanamespace cuda {    namespace utils {        // Bad: function definition added to namespace nested within cuda        cudaStream_t make_stream() {            cudaStream_t s;            cudaStreamCreate(&s);            return s;        }    } // namespace utils} // namespace cudanamespace cuda {    // Okay: namespace cuda may be used nested within a non- reserved namespace    cudaStream_t make_stream() {        cudaStream_t s;        cudaStreamCreate(&s);        return s;    }} // namespace cuda} // namespace utils// Bad: Equivalent to adding symbols to namespace cuda at global scope using namespace utils;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.10.1 External Linkage - A call within some device code...",
    "content": "\n\n# 17.5.10.1 External Linkage\nA call within some device code of a function declared with the extern qualifier is only allowed if the function is defined within the same compilation unit as the device code, i.e., a single file or several files linked together with relocatable device code and mvlink."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.10.2 Implicitly-declared and explicitly-defaulted functions - Let F denote a function that i......class Derived  public Base  in...",
    "content": "Let F denote a function that is either implicitly- declared or is explicitly- defaulted on its first declaration The execution space specifiers (__host___. _device__) for F are the union of the execution space specifiers of all the functions that invoke it (note that a __global__ caller will be treated as a __device__ caller for this analysis). For example:\n\nclass Base {    int x;    public:    __host__ __device__ Base(void) : x(10) {}\n\n(continues on next page)\n\n}; class Derived : public Base { int y; }; class Other: public Base { int z; }; __device__ void foo(void) { Derived D1; Other D2; } __host__ void bar(void) { Other D3; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.10.2 Implicitly-declared and explicitly-defaulted functions - Here the implicitly declared c......For example",
    "content": "Here, the implicitly- declared constructor function \"Derived::Derived\" will be treated as a __device__ function, since it is invoked only from the __device__ function \"foo\". The implicitly- declared constructor function \"Other::Other\" will be treated as a __host__ __device__ function, since it is invoked both from a __device__ function \"foo\" and a __host__ function \"bar\".\n\nIn addition, if F is a virtual destructor, then the execution spaces of each virtual destructor D overridden by F are added to the set of execution spaces for F, if D is either not implicitly defined or is explicitly defaulted on a declaration other than its first declaration.\n\nFor example:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.10.2 Implicitly-declared and explicitly-defaulted functions - cppstruct Base1  virtual host ...",
    "content": "```cppstruct Base1 { virtual __host__ __device__ __Base1() {} };struct Derived1 : Base1 {}; // implicitly- declared virtual destructor// ~Derived1 has __host__ __device__// execution space specifiersstruct Base2 { virtual __device__ ~Base2(); };__device__ Base2::~Base2() = default;struct Derived2 : Base2 {}; // implicitly- declared virtual destructor// ~Derived2 has __device__ execution// space specifiers```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.10.3 Function Parameters - global function parameters are......firstcu struct S   device void...",
    "content": "__global__ function parameters are passed to the device via constant memory and are limited to 32,764 bytes starting with Volta, and 4 KB on older architectures.\n\n__global__ functions cannot have a variable number of arguments.\n\n__global__ function parameters cannot be pass- by- reference.\n\nIn separate compilation mode, if a __device__ or __global__ function is ODR- used in a particular translation unit, then the parameter and return types of the function must be complete in that translation unit.\n\nExample:\n\n//first.cu: struct S; - - device- void foo(S); // error: type 'S' is incomplete - - device- auto \\*ptr  $=$  foo; int main() {} //second.cu: struct S { int x; }; - - device- void foo(S) {}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.10.3 Function Parameters - compiler invocation nvcc  stds...",
    "content": "//compiler invocation \\\\(nvcc - std\\)\\scriptstyle{\\mathbb{C}++}\\(14 - rdc\\)=\\(true first.cu second.cu - o first nvlink error - : Prototype doesn't match for '_Z3foo1s' in '/tmp / tmpxft_00005c8c_ - 00000000 - 18_second.o', first defined in '/tmp / tmpxft_00005c8c_00000000 - 18_second.o' nvlink fatal : merge_elf failed"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.10.3.1 __global__ Function Argument Processing - When a global function is laun...",
    "content": "# 17.5.10.3.1 __global__ Function Argument Processing\nWhen a __global__ function is launched from device code, each argument must be trivially copyable and trivially destructible.\n\nWhen a __global__ function is launched from host code, each argument type is allowed to be non- trivially copyable or non- trivially- destructible, but the processing for such types does not follow the standard C++ model, as described below. User code must ensure that this workflow does not affect program correctness. The workflow diverges from standard C++ in two areas:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "1. Memopy instead of copy constructor invocation - When lowering a global functio......Example",
    "content": "When lowering a __global__ function launch from host code, the compiler generates stub functions that copy the parameters one or more times by value, before eventually using memcpy to copy the arguments to the __global__ function's parameter memory on the device. This occurs even if an argument was non- trivially- copyable, and therefore may break programs where the copy constructor has side effects.\n\nExample:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "1. Memopy instead of copy constructor invocation - include cassert struct S  int ......Example",
    "content": "include <cassert> struct S { int x; int \\*ptr; - - host- - - device- - S() {} - - host- - - - device- - S(const S &) { ptr  $=$  &x; } }; - - global- void foo(S in) { // this assert may fail, because the compiler // generated code will memcpy the contents of \"in\" // from host to kernel parameter memory, so the // \"in.ptr\" is not initialized to \"&in.x\" because // the copy constructor is skipped. assert(in.ptr  $= =$  &in.x); } int main() { S tmp;\n\nfoo<<1,1>>>tmp); cudaDeviceSynchronize(); }\n\nExample:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "1. Memopy instead of copy constructor invocation - include cassert managed int co...",
    "content": "include <cassert> _managed_ int counter; struct S1 { S1() {} S1(const S1 &) { ++counter; } }; _global__ void foo(S1) { /* this assertion may fail, because the compiler generates stub functions on the host for a kernel launch, and they may copy the argument by value more than once. */ assert(counter == 1); } int main() { S1 V; foo<<1,1>>>V); cudaDeviceSynchronize(); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "2. Destructor may be invoked before the  $\\therefore$  global_ function has finished - Kernel launches are asynchrono......struct S  int ptr S  ptr...",
    "content": "Kernel launches are asynchronous with host execution. As a result, if a  $\\_$ global_ function argument has a non- trivial destructor, the destructor may execute in host code even before the  $\\_$ global_ function has finished execution. This may break programs where the destructor has side effects.\n\nExample:\n\nstruct S { int \\*ptr; S() : ptr(nulptr) {} S(const S &) { cudaMallocManaged(&ptr, sizeof(int)); } \\~S() { cudaFree(ptr); } }; _global_ void foo(S in) { //error: This store may write to memory that has already been // freed (see below). \\*(in.ptr) = 4; } int main() { S V;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "2. Destructor may be invoked before the  $\\therefore$  global_ function has finished - The object V is first copied b...",
    "content": "/* The object 'V' is first copied by value to a compiler- generated * stub function that does the kernel launch, and the stub function * bitwise copies the contents of the argument to kernel parameter * memory; * However, CPU kernel execution is asynchronous with host * execution; * As a result, S::~S() will execute when the stub function returns, releasing * allocated memory, even though the kernel may not have finished execution. */foo<<1,1>>>(V);cudaDeviceSynchronize();}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.10.3.3 Link Compatibility across Toolkit Revisions - Developers must use the 121 To......When linking device objects if...",
    "content": "# 17.5.10.3.2 Toolkit and Driver Compatibility\nDevelopers must use the 12.1 Toolkit and r530 driver or higher to compile, launch, and debug kernels that accept parameters larger than 4KB. If such kernels are launched on older drivers, CUDA will issue the error CUDA_ERROR_NOT_SUPPORTED.\n\n# 17.5.10.3.3 Link Compatibility across Toolkit Revisions\nWhen linking device objects, if at least one device object contains a kernel with a parameter larger than 4KB, the developer must recompile all objects from their respective device sources with the 12.1 toolkit or higher before linking them together. Failure to do so will result in a linker error."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.10.4 Static Variables within Function - Variable memory space specifie......Examples of legal and illegal ...",
    "content": "Variable memory space specifiers are allowed in the declaration of a static variable V within the immediate or nested block scope of a function F where:\n\n- F is a \n--global \n-- or \n--device \n--only function.- F is a \n--host \n-- \n--device \n-- function and \n--CUDA \n- ARCH \n-- is defined<sup>17</sup>.\n\nIf no explicit memory space specifier is present in the declaration of V, an implicit \n--device \n-- specifier is assumed during device compilation.\n\nV has the same initialization restrictions as a variable with the same memory space specifiers declared in namespace scope for example a \n--device \n-- variable cannot have a 'non- empty' constructor (see Device Memory Space Specifiers).\n\nExamples of legal and illegal uses of function- scope static variables are shown below."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.10.4 Static Variables within Function - struct S1t     int xstruct S2t......httpscdnmineruopenxlaborgcnres...",
    "content": "struct S1_t {    int x;};struct S2_t {    int x;\n\n(continues on next page)\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/4252e82e7154f1dfcc12e25c462c853abdb269032988c2bea72fd0b1d84291de.jpg)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.10.6 Function Recursion - The address of a global functi......global functions do not suppor...",
    "content": "The address of a __global__ function taken in host code cannot be used in device code (e.g. to launch the kernel). Similarly, the address of a __global__ function taken in device code<sup>18</sup> cannot be used in host code.\n\nIt is not allowed to take the address of a __device__ function in host code.\n\n# 17.5.10.6 Function Recursion\n__global__ functions do not support recursion."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.11.2 Function Members - A global function or function ......Static member functions cannot...",
    "content": "# 17.5.10.7 Friend Functions\nA __global__ function or function template cannot be defined in a friend declaration.\n\nExample:\n\nstruct S1_t { friend __global__ void foo1(void); // OK: not a definition template<typename T> friend __global__ void foo2(void); // OK: not a definition friend __global__ void foo3(void) {} // error: definition in friend declaration template<typename T> friend __global__ void foo4(void) {} // error: definition in friend declaration };\n\n# 17.5.10.8 Operator Function\nAn operator function cannot be a __global__ function.\n\n# 17.5.11. Classes\n\n\n# 17.5.11.1 Data Members\nStatic data members are not supported except for those that are also const- qualified (see Const- qualified variables).\n\n# 17.5.11.2 Function Members\nStatic member functions cannot be  $\\_$ global  $\\_$ functions."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.11.3 Virtual Functions - When a function in a derived c......Example",
    "content": "When a function in a derived class overrides a virtual function in a base class, the execution space specifiers (i.e.,  $\\_$ host  $\\_$ ,  $\\_$ device  $\\_$ ) on the overridden and overriding functions must match.\n\nIt is not allowed to pass as an argument to a  $\\_$ global  $\\_$ function an object of a class with virtual functions.\n\nIf an object is created in host code, invoking a virtual function for that object in device code has undefined behavior.\n\nIf an object is created in device code, invoking a virtual function for that object in host code has undefined behavior.\n\nSee Windows- Specific for additional constraints when using the Microsoft host compiler.\n\nExample:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.11.3 Virtual Functions - struct S1  virtual   host   de...",
    "content": "struct S1 { virtual  $\\_$ host  $\\_$ device  $\\_$ void foo() {} };  $\\_$ managed  $\\_$  S1 *ptr1, *ptr2;  $\\_$ managed  $\\_$ align  $\\_$ 16 char buf1[128];  $\\_$ global  $\\_$ void kern() { ptr1- >foo(); // error: virtual function call on a object // created in host code. ptr2 = new(buf1) S1(); } int main(void) { void *buf; cudaMallocManaged(&buf, sizeof(S1), cudaMemAttachGlobal); ptr1 = new(buf) S1(); kern  $< < 1$ $1 > > 2$  cudaDeviceChronize(); ptr2- >foo(); // error: virtual function call on an object // created in device code. }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.11.5 Anonymous Unions - It is not allowed to pass as a......Member variables of a namespac...",
    "content": "It is not allowed to pass as an argument to a  $\\_$ global  $\\_$ function an object of a class derived from virtual base classes.\n\nSee Windows- Specific for additional constraints when using the Microsoft host compiler.\n\n# 17.5.11.5 Anonymous Unions\nMember variables of a namespace scope anonymous union cannot be referenced in a __global__ or __device__ function."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.11.6 Windows-Specific - The CUDA compiler follows the ......Let C denote T or a class type...",
    "content": "The CUDA compiler follows the IA64 ABI for class layout, while the Microsoft host compiler does not. Let T denote a pointer to member type, or a class type that satisfies any of the following conditions:\n\nT has virtual functions.  $\\triangleright$  T has a virtual base class.  $\\triangleright$  T has multiple inheritance with more than one direct or indirect empty base class.  $\\triangleright$  All direct and indirect base classes B of T are empty and the type of the first field F of T uses B in its definition, such that B is laid out at offset O in the definition of F.\n\nLet C denote T or a class type that has T as a field type or as a base class type. The CUDA compiler may compute the class layout and size differently than the Microsoft host compiler for the type C."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.11.6 Windows-Specific - As long as the type C is used ......Accessing an object of type C ...",
    "content": "As long as the type C is used exclusively in host or device code, the program should work correctly.\n\nPassing an object of type C between host and device code has undefined behavior, for example, as an argument to a __global__ function or through cudememcpy\\* () calls.\n\nAccessing an object of type C or any subobject in device code, or invoking a member function in device code, has undefined behavior if the object is created in host code.\n\nAccessing an object of type C or any subobject in host code, or invoking a member function in host code, has undefined behavior if the object is created in device code19."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.12. Templates - A type or template cannot be u......continues on next page",
    "content": "A type or template cannot be used in the type, non- type or template template argument of a __global__ function template instantiation or a __device__/__constant__ variable instantiation if either:\n\nThe type or template is defined within a __host__ or __host__ __device__. The type or template is a class member with private or protected access and its parent class is not defined within a __device__ or __global__ function. The type is unnamed. The type is compounded from any of the types above.\n\nExample:\n\ntemplate <typename T> global__ void myKernel(void) {} class myClass { private:\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.12. Templates - struct innert   public static ...",
    "content": "struct inner_t { }; public: static void launch(void) { // error: inner_t is used in template argument // but it is private myKernel<inner_t  $\\geq \\leq \\leq \\leq 1$  ,1>>>(); } }; // C++14 only template <typename T> __device__ T d1; template <typename T1, typename T2> __device__ T1 d2; void fn() { struct S1_t {}; // error (C++14 only): S1_t is local to the function fn d1<S1_t> = {}; auto lam1 = [] {}; // error (C++14 only): a closure type cannot be used for // instantiating a variable template d2<int, decltype(lam1)> = 10; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.13. Trigraphs and Digraphs - Trigraphs are not supported on...",
    "content": "Trigraphs are not supported on any platform. Digraphs are not supported on Windows."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.14. Const-qualified variables - Let V denote a namespace scope......Example",
    "content": "Let 'V' denote a namespace scope variable or a class static member variable that has const qualified type and does not have execution space annotations (for example, __device__, __constant__, __shared__). V is considered to be a host code variable.\n\nThe value of V may be directly used in device code, if\n\n- V has been initialized with a constant expression before the point of use,- the type of V is not volatile-qualified, and- it has one of the following types:  \n- built-in floating point type except when the Microsoft compiler is used as the host compiler,  \n- built-in integral type.\n\nDevice source code cannot contain a reference to V or take the address of V.\n\nExample:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.14. Const-qualified variables - const int  times times times  ...",
    "content": "const int  $\\times \\times \\times = 10$  struct S1_t { static const int  $\\texttt{yyy} = 20;$  }; extern const int  $zzz$  const float www  $= 5.0$  . - - device_- void foo(void) { int local1  $[xxx]$  // OK int local2[S1_t::yyy]; // OK int val1  $=$  xxx; // OK int val2  $=$  S1_t::yyy; // OK int val3  $=$  zzz; // error: zzz not initialized with constant // expression at the point of use. const int &val3  $=$  xxx; // error: reference to host variable const int \\*val4  $=$  &xxx; // error: address of host variable const float val5  $=$  www; // OK except when the Microsoft compiler is used as // the host compiler. } const int  $zzz = 20$"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.15. Long Double - The use of long double type is...",
    "content": "The use of long double type is not supported in device code."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.16. Deprecation Annotation - nvcc supports the use of depre...",
    "content": "nvcc supports the use of deprecated attribute when using gcc, clang, x1c, icc or pgcc host compilers, and the use of deprecated declspec when using the cl.exe host compiler. It also supports the [[deprecated]] standard attribute when the  $\\mathtt{C + 14}$  dialect has been enabled. The CUDA frontend compiler will generate a deprecation diagnostic for a reference to a deprecated entity from within the body of a  $\\_ \\text{device\\_}$ ,  $\\_ \\text{global\\_}$  or  $\\_ \\text{host\\_}$ ,  $\\_ \\text{device\\_}$  function when  $\\_ \\text{CUDA\\_ARCH\\_}$  is defined (i.e., during device compilation phase). Other references to deprecated entities will be handled by the host compiler, e.g., a reference from within a  $\\_ \\text{host\\_}$  function."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.16. Deprecation Annotation - The CUDA frontend compiler doe...",
    "content": "The CUDA frontend compiler does not support the #pragma gcc diagnostic or #pragma warning mechanisms supported by various host compilers. Therefore, deprecation diagnostics generated by the CUDA frontend compiler are not affected by these pragmas, but diagnostics generated by the host compiler will be affected. To suppress the warning for device code, user can use NVIDIA specific pragma #pragmanv_diag_suppress. The nvcc flag - Wno- deprecated- declarations can be used to suppress all deprecation warnings, and the flag - Werror=deprecated- declarations can be used to turn deprecation warnings into errors."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.17. Noreturn Annotation - nvcc supports the use of noret......The attributedeclspec can be u...",
    "content": "nvcc supports the use of noreturn attribute when using gcc, clang, x1c, icc or pgcc host compilers, and the use of noreturn declspec when using the cl.exe host compiler. It also supports the [[noreturn]] standard attribute when the  $\\mathtt{C + + 11}$  dialect has been enabled.\n\nThe attribute/declspec can be used in both host and device code."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.18. [[likely]] / [[unlikely]] Standard Attributes - These attributes are accepted ......device int fooint x  if i  10 ...",
    "content": "These attributes are accepted in all configurations that support the  $\\mathtt{C + + }$  standard attribute syntax. The attributes can be used to hint to the device compiler optimizer whether a statement is more or less likely to be executed compared to any alternative path that does not include the statement.\n\nExample:\n\n__device__ int foo(int x) { if (i < 10) [[likely]] { // the 'if' block will likely be entered return 4; } if (i < 20) [[unlikely]] { // the 'if' block will not likely be entered return 1; } return 0; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.18. [[likely]] / [[unlikely]] Standard Attributes - If these attributes are used i...",
    "content": "If these attributes are used in host code when __CUDA_ARCH__ is undefined, then they will be present in the code parsed by the host compiler, which may generate a warning if the attributes are not supported. For example, clang 11 host compiler will generate an 'unknown attribute' warning."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.19. const and pure GNU Attributes - These attributes are supported......Example",
    "content": "These attributes are supported for both host and device functions, when using a language dialect and host compiler that also supports these attributes e.g. with  $\\mathtt{g + + }$  host compiler.\n\nFor a device function annotated with the pure attribute, the device code optimizer assumes that the function does not change any mutable state visible to caller functions (e.g. memory).\n\nFor a device function annotated with the const attribute, the device code optimizer assumes that the function does not access or change any mutable state visible to caller functions (e.g. memory).\n\nExample:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.19. const and pure GNU Attributes - attributeconst device int geti......return sum",
    "content": "__attribute__((const)) __device__ int get(int in); __device__ int doit(int in) { int sum = 0; //because 'get' is marked with 'const' attribute //device code optimizer can recognize that the //second call to get() can be commoned out. sum = get(in);\n\n(continues on next page)\n\nsum  $+ =$  get(in);\n\nreturn sum; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.20. Intel Host Compiler Specific - 17520 Intel Host Compiler Spec...",
    "content": "# 17.5.20. Intel Host Compiler Specific\n17.5.20. Intel Host Compiler SpecificThe CUDA frontend compiler parser does not recognize some of the intrinsic functions supported by the Intel compiler (e.g. icc). When using the Intel compiler as a host compiler, nvcc will therefore enable the macro __INTEL_COMPILER_USE_INTRINSIC_PROTOCOLS during preprocessing. This macro enables explicit declarations of the Intel compiler intrinsic functions in the associated header files, allowing nvcc to support use of such functions in host code<sup>20</sup>."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21. C++11 Features - 17521 C11 Features mathbbC   1...",
    "content": "17.5.21. C++11 Features $\\mathbb{C} + + 11$  features that are enabled by default by the host compiler are also supported by nvcc, subject to the restrictions described in this document. In addition, invoking nvcc with - std=c++11 flag turns on all  $\\mathbb{C} + + 11$  features and also invokes the host preprocessor, compiler and linker with the corresponding  $\\mathbb{C} + + 11$  dialect option<sup>21</sup>."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.1 Lambda Expressions - The execution space specifiers......Examples of lambda expressions...",
    "content": "The execution space specifiers for all member functions22 of the closure class associated with a lambda expression are derived by the compiler as follows. As described in the  $\\mathbb{C} + + 11$  standard, the compiler creates a closure type in the smallest block scope, class scope or namespace scope that contains the lambda expression. The innermost function scope enclosing the closure type is computed, and the corresponding function's execution space specifiers are assigned to the closure class member functions. If there is no enclosing function scope, the execution space specifier is __host_.\n\nExamples of lambda expressions and computed execution space specifiers are shown below (in comments)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.1 Lambda Expressions - auto globalVar      return 0  ......device void f4int fp    return...",
    "content": "auto globalVar  $=$  [] { return 0; }; // _host_ void f1(void) { auto  $\\texttt{l1} = \\texttt{[]}$  {return 1; }; // _host_ } - - device_- void f2(void) { auto  $\\texttt{l2} = \\texttt{[]}$  {return 2; }; // _device_ } - - host_- - device_- void f3(void) { auto  $\\texttt{l3} = \\texttt{[]}$  {return 3; }; // _host_- - device_- (continues on next page)\n\n} _device__ void f4(int (\\*fp)() = [] { return 4; } /* _host_ \\*/ { } _global__ void f5(void) { auto_15 = [] { return 5; }; // _device__ } _device__ void f6(void) { struct S1_t { static void helper(int (\\*fp)() = [] {return 6; } /* _device__ \\*/ { } }; } }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.1 Lambda Expressions - The closure type of a lambda e......Example",
    "content": "The closure type of a lambda expression cannot be used in the type or non- type argument of a _global__ function template instantiation, unless the lambda is defined within a _device__ or _global__ function.\n\nExample:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.1 Lambda Expressions - template typename T global voi...",
    "content": "template <typename T> _global__ void foo(T in) { }; template <typename T> struct S1_t { }; void bar(void) { auto temp1 = [] { }; foo  $\\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon$  (temp1); // error: lambda closure type used in // template type argument foo  $\\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.1 Lambda Expressions - epsilon epsilon epsilon epsilo...",
    "content": " \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\delta \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\epsilon \\delta \\epsilon$  (S1_t<decltype(temp1)>()); "
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.1 Lambda Expressions - error lambda closure type used...",
    "content": "// error: lambda closure type used in // template type argument }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.2 std:initializer_list - By default the CUDA compiler w......continued from previous page",
    "content": "By default, the CUDA compiler will implicitly consider the member functions of std::initializer_list to have __host__ __device__ execution space specifiers, and therefore they can be invoked directly from device code. The nvcc flag - - no- host- device- initializer- list will disable this behavior; member functions of std::initializer_list will then be considered as __host__ functions and will not be directly invokable from device code.\n\nExample:\n\n```cpp#include <initializer_list>__device__ int foo(std::initializer_list<int> in);__device__ void bar(void){    foo({4,5,6}); // (a) initializer_list containing only}```\n\n(continued from previous page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.2 std:initializer_list - tabletrtd constant expressions...This form may have better perf...",
    "content": "<table><tr><td>// constant expressions.\nint i = 4;\nfoo(i,5,6);   // (b) initializer list with at least one\n    // non-constant element.\n    // This form may have better performance than (a).</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.3 Rvalue references - By default the CUDA compiler w...",
    "content": "By default, the CUDA compiler will implicitly consider std::move and std::forward function templates to have __host__ - - device__ execution space specifiers, and therefore they can be invoked directly from device code. The nvcc flag - - no- host- device- move- forward will disable this behavior; std::move and std::forward will then be considered as __host__ functions and will not be directly invokable from device code."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.4 Constexpr functions and function templates - By default a constexpr functio...",
    "content": "# 17.5.21.4 Constexpr functions and function templates\nBy default, a constexpr function cannot be called from a function with incompatible execution space<sup>23</sup>. The experimental nvcc flag - - expt- relaxed- constexpr removes this restriction<sup>24</sup>. When this flag is specified, host code can invoke a __device__ constexpr function and device code can invoke a __host__ constexpr function. nvcc will define the macro __CUDACC_RELAXED_CONFIGEXPR__ when - - expt- relaxed- constexpr has been specified. Note that a function template instantiation may not be a constexpr function even if the corresponding template is marked with the keyword const- expr (C++11 Standard Section [dcl.constexpr_p6])."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.5 Constexpr variables - Let V denote a namespace scope......Example",
    "content": "Let 'V' denote a namespace scope variable or a class static member variable that has been marked constexpr and that does not have execution space annotations (e.g., __device__, __constant__, __shared__). V is considered to be a host code variable.\n\nIf V is of scalar type<sup>25</sup> other than long double and the type is not volatile- qualified, the value of V can be directly used in device code. In addition, if V is of a non- scalar type then scalar elements of V can be used inside a constexpr __device__ or __host__ __device__ function, if the call to the function is a constant expression<sup>26</sup>. Device source code cannot contain a reference to V or take the address of V.\n\nExample:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.5 Constexpr variables - constexpr int xxx  18 constexp......device int fooint idx     int ...",
    "content": "constexpr int xxx = 18; constexpr int yy = xxx + 4; struct S1_t { static constexpr int qqq = 100; }; constexpr int host_arr[] = {1, 2, 3}; constexpr __device__ int get(int idx) { return host_arr[idx]; }\n\n- _device__ int foo(int idx) {    int v1 = xxx + yyy + S1_t::qqq; // OK    const int &v2 = xxx; // error: reference to host constexpr    const int *v3 = &xxx; // variable    const int &v4 = S1_t::qqq; // error: reference to host constexpr    const int *v5 = &S1_t::qqq; // variable    v1 += get(2); // OK: 'get(2)' is a constant    v1 += get(idx); // expression    v1 += host_arr[2]; // expression    return v1;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.6 Inline namespaces - For an input CUDA translation ......The compiler generated code co...",
    "content": "For an input CUDA translation unit, the CUDA compiler may invoke the host compiler for compiling the host code within the translation unit. In the code passed to the host compiler, the CUDA compiler will inject additional compiler generated code, if the input CUDA translation unit contained a definition of any of the following entities:\n\n- _global__ function or function template instantiation- \n--device__,- \n--constant__- \n- variables with surface or texture type\n\nThe compiler generated code contains a reference to the defined entity. If the entity is defined within an inline namespace and another entity of the same name and type signature is defined in an enclosing namespace, this reference may be considered ambiguous by the host compiler and host compilation will fail."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.6 Inline namespaces - This limitation can be avoided......cppdevice int Gvarinline names...",
    "content": "This limitation can be avoided by using unique names for such entities defined within an inline namespace.\n\nExample:\n\n```cpp__device__ int Gvar;inline namespace N1 {    __device__int Gvar;}// <-- CUDA compiler inserts a reference to \"Gvar\" at this point in the// translation unit. This reference will be considered ambiguous by the// host compiler and compilation will fail.```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - cppinline namespace N1     nam......cppdeviceint Gvarnamespace N2 ...",
    "content": "```cppinline namespace N1 {    namespace N2 {```\n\n(continues on next page)\n\n```cpp__device__int Gvar;}}namespace N2 {    __device__int Gvar;}// <__CUDA compiler inserts reference to \":N2::Gvar\" at this point in// the translation unit. This reference will be considered ambiguous by// the host compiler and compilation will fail.```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.7 thread_local - The following entities cannot ......The threadlocal storage specif...",
    "content": "# 17.5.21.6.1 Inline unnamed namespaces\nThe following entities cannot be declared in namespace scope within an inline unnamed namespace:\n\n```cpp- __managed__,- __device__,- __shared__ and __constant__ variables- __global__ function and function templates- variables with surface or texture type```\n\nExample:\n\n```cppinline namespace {    namespace N2 {        template <typename T>        __global__ void foo(void); // error        __global__ void bar(void) { } // error        template <>        __global__ void foo<int>(void) { } // error        __device__int x1b; // error        __constant__ int x2b; // error        __shared__ int x3b; // error        texture<int> q2; // error        surface<int> s2; // error    }};```\n\n# 17.5.21.7 thread_local\nThe thread_local storage specifier is not allowed in device code."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.8 global__ functions and function templates - If the closure type associated......Example",
    "content": "If the closure type associated with a lambda expression is used in a template argument of a __global__ function template instantiation, the lambda expression must either be defined in the immediate or nested block scope of a __device__ or __global__ function, or must be an extended lambda.\n\nExample:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.8 global__ functions and function templates - template typename T global voi...",
    "content": "template <typename T> global__ void kernel(T in) {} _device__ void foo_device(void) { // All kernel instantiations in this function // are valid, since the lambdas are defined inside // a __device__ function."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.8 global__ functions and function templates - kernel  scriptstyle epsilon   ...",
    "content": " kernel  $\\scriptstyle \\epsilon < < 1,1 > > > ([]$  __device__{}); kernel  $\\scriptstyle \\epsilon < < 1,1 > > > ([]$  __host__ __device__{} ); kernel  $\\scriptstyle \\epsilon < < 1,1 > > > ([]$  {} ); } auto lam1 = [] {}; auto lam2 = [] __host__ __device__ {}; void foo_host(void) { // OK: instantiated with closure type of an extended __device__ lambda kernel  $\\scriptstyle \\epsilon < < 1,1 > > > ([]$  __device__{}); // OK: instantiated with closure type of an extended __host__ __device__ // lambda kernel  $\\scriptstyle \\epsilon < < 1,1 > > > ([]$  __host__ __device__{} ); // error: unsupported: instantiated with closure type of a lambda // that is not an extended lambda kernel  $\\scriptstyle \\epsilon < < 1,1 > > > ([]$  {} ); // error: unsupported: instantiated with closure type of a lambda"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.8 global__ functions and function templates - that is not an extended lambda...",
    "content": " // that is not an extended lambda kernel  $\\scriptstyle \\epsilon < < 1,1 > > > ([]$  lam1); // error: unsupported: instantiated with closure type of a lambda // that is not an extended lambda kernel  $\\scriptstyle \\epsilon < < 1,1 > > > ([]$  lam2); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.8 global__ functions and function templates - A global function or function ......Example",
    "content": "A __global__ function or function template cannot be declared as constexpr.A __global__ function or function template cannot have a parameter of type std::initializer_list or va_list.A __global__ function cannot have a parameter of rvalue reference type.A variadic __global__ function template has the following restrictions:  - Only a single pack parameter is allowed.\n\n- The pack parameter must be listed last in the template parameter list.\n\nExample:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.8 global__ functions and function templates - ok template template typename ...",
    "content": "// ok template <template <typename...> class Wrapper, typename... Pack> global__ void foo1(Wrapper<Pack...>); // error: pack parameter is not last in parameter list template <typename... Pack, template <typename...> class Wrapper> global__ void foo2(Wrapper<Pack...>); // error: multiple parameter packs template <typename... Pack1, int...Pack2, template<typename...> class Wrapper1, template<int...> class Wrapper2> global__ void foo3(Wrapper1<Pack1. ..>, Wrapper2<Pack2. ..>);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.9 _managed_and_shared_variables - cppmanagedandsharedvariables",
    "content": "```cpp__managed_and_shared_variables```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.10 Defaulted functions - Execution space specifiers on ......Example",
    "content": "Execution space specifiers on a function that is explicitly- defaulted on its first declaration are ignored by the CUDA compiler. Instead, the CUDA compiler will infer the execution space specifiers as described in Implicitly- declared and explicitly- defaulted functions.\n\nExecution space specifiers are not ignored if the function is explicitly- defaulted, but not on its first declaration.\n\nExample:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.21.10 Defaulted functions - struct S1   warning host annot......host function S2S2 S2 s2",
    "content": "struct S1 { // warning: _host__ annotation is ignored on a function that // is explicitly- defaulted on its first declaration _host__ S1() = default; }; _device__ void foo1() { //note: _device__ execution space is derived for S1::S1 // based on implicit call from within _device__ function // foo1 S1 s1; } struct S2 { _host__ S2(); }; //note: S2::S2 is not defaulted on its first declaration, and // its execution space is fixed to _host__ based on its // first declaration. S2::S2() = default; _device__ void foo2() { // error: call from _device__ function 'foo2' to\n\n(continues on next page)\n\n// - host__ function 'S2::S2' S2 s2;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.22. C++14 Features - mathttC   14  features enabled...",
    "content": "$\\mathtt{C + + 14}$  features enabled by default by the host compiler are also supported by nvcc. Passing nvcc - std  $= \\mathbb{C} + + 14$  flag turns on all  $\\mathtt{C + + 14}$  features and also invokes the host preprocessor, compiler and linker with the corresponding  $\\mathtt{C + + 14}$  dialect option27. This section describes the restrictions on the supported  $\\mathtt{C + + 14}$  features."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.22.1 Functions with deduced return type - A global function cannot have ......Examples",
    "content": "A __global__ function cannot have a deduced return type.\n\nIf a __device__ function has deduced return type, the CUDA frontend compiler will change the function declaration to have a void return type, before invoking the host compiler. This may cause issues for introspecting the deduced return type of the __device__ function in host code. Thus, the CUDA compiler will issue compile- time errors for referencing such deduced return type outside device function bodies, except if the reference is absent when __CUDA_ARCH__ is undefined.\n\nExamples:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.22.1 Functions with deduced return type - device auto fn1int x  return x......error referenced outside devic...",
    "content": "device__ auto fn1(int x) { return x; } _device__ decltype(auto) fn2(int x) { return x; } _device__ void device_fn1() { // OK int (\\*p1)(int) = fn1; } // error: referenced outside device function bodies decltype(fn1(10)) g1; void host_fn1() { // error: referenced outside device function bodies int (\\*p1)(int) = fn1; struct S_local_t { // error: referenced outside device function bodies decltype(fn2(10)) m1; S_local_t() : m1(10) {} }; }\n\n(continued from previous page)\n\n// error: referenced outside device function bodies  template <typename T = decltype(fn2)>  void host_fn2() { }  template<typename T> struct S1_t { };  // error: referenced outside device function bodies  struct S1_derived_t : S1_t < decltype(fn1)> { };"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.22.2 Variable templates - A device  constant variable te......error a device variable templa...",
    "content": "# 17.5.22.2 Variable templates\nA __device__ / __constant__ variable template cannot have a const qualified type when using the Microsoft host compiler.\n\nExamples:\n\n// error: a __device__ variable template cannot  // have a const qualified type on Windows  template <typename T>  __device__ const T d1(2);  int *const x = nullptr;  // error: a __device__ variable template cannot  // have a const qualified type on Windows  template <typename T>  __device__ T *const d2(x);  // OK  template <typename T>  __device__ const T *d3;  __device__ void fn() {      int t1 = d1 < int>;      int *const t2 = d2 < int>;      const int *t3 = d3 < int>;  }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.23. C++17 Features - mathttC   17  features enabled...",
    "content": "$\\mathtt{C + + 17}$  features enabled by default by the host compiler are also supported by nvcc. Passing nvcc - std  $= \\mathbb{C} + + 17$  flag turns on all  $\\mathtt{C + + 17}$  features and also invokes the host preprocessor, compiler and linker with the corresponding  $\\mathtt{C + + 17}$  dialect option28. This section describes the restrictions on the supported  $\\mathtt{C + + 17}$  features."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.23.1 Inline Variable - A namespace scope inline varia......When using  mathttg     host c...",
    "content": "# 17.5.23.1 Inline Variable\nA namespace scope inline variable declared with __device__ or __constant__ or __managed__ memory space specifier must have internal linkage, if the code is compiled with nvcc in whole program compilation mode.Examples:\n\nExamples:\n\ninline __device__ int xxx; //error when compiled with nvcc in //whole program compilation mode. //ok when compiled with nvcc in //separate compilation mode. inline __shared__ int yyy0; // ok. static inline __device__ int yyy; // ok: internal linkage namespace { inline __device__ int zzz; // ok: internal linkage }\n\nWhen using  $\\mathtt{g + + }$  host compiler, an inline variable declared with __managed__ memory space specifier may not be visible to the debugger."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.24.1 Module support - A structured binding cannot be......Modules are not supported in C...",
    "content": "# 17.5.23.2 Structured Binding\nA structured binding cannot be declared with a variable memory space specifier.\n\nExample:\n\nstruct S { int x; int y; }; __device__ auto [a1, b1] = S{4,5}; // error\n\n# 17.5.24. C++20 Features\n$c + + 20$  features enabled by default by the host compiler are also supported by nvcc. Passing nvcc - std  $= c + + 20$  flag turns on all  $c + + 20$  features and also invokes the host preprocessor, compiler and linker with the corresponding  $c + + 20$  dialect option29. This section describes the restrictions on the supported  $c + + 20$  features.\n\n# 17.5.24.1 Module support\nModules are not supported in CUDA C++, in either host or device code. Uses of the module, export and import keywords are diagnosed as errors."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.24.3 Three-way comparison operator - 175242 Coroutine supportCorout......The three way comparison opera...",
    "content": "# 17.5.24.2 Coroutine support\n17.5.24.2 Coroutine supportCoroutines are not supported in device code. Uses of the co_await, co_yield and co_return keywords in the scope of a device function are diagnosed as error during device compilation.\n\n# 17.5.24.3 Three-way comparison operator\nThe three- way comparison operator is supported in both host and device code, but some uses implicitly rely on functionality from the Standard Template Library provided by the host implementation. Uses of those operators may require specifying the flag: - - expt- relaxed- constexpr to silence warnings and the functionality requires that the host implementation satisfies the requirements of device code."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.24.4 Consteval functions - includecompare struct S  int x...",
    "content": "include<compare> struct S { int x, y, z; auto operator  $\\epsilon = >$  const S& rhs) const  $=$  default; - - host- - - device- - bool operator  $\\epsilon = >$  (int rhs) const { return false; } }; - - host- - - device- - bool f(S a, S b) { if (a  $\\epsilon = >$  1) // ok, calls a user- defined host- device overload return true; return a  $< b$  ; // call to an implicitly- declared function and requires // a device- compatible std::strong_ordering implementation }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.5.24.4 Consteval functions - Ordinarily cross execution spa...",
    "content": "# 17.5.24.4 Consteval functions\nOrdinarily, cross execution space calls are not allowed, and cause a compiler diagnostic (warning or error). This restriction does not apply when the called function is declared with the consteval specifier. Thus, a __device__ or __global__ function can call a __host__ consteval function, and a __host__ function can call a __device__ consteval function."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - namespace N1  consteval host f......continues on next page",
    "content": "# Example:\nnamespace N1 { //consteval host function consteval int hcallee() { return 10; } - - device- - int dfunc() { return hcallee(); /* OK */ } - - global- - void gfunc() { (void)hcallee(); /* OK */ } - - host- - - device- - int hdfunc() { return hcallee(); /* OK */ } int hfunc() { return hcallee(); /* OK */ } } // namespace N1 namespace N2 { //consteval device function consteval __device__ int dcallee() { return 10; } - - device- - int dfunc() { return dcallee(); /* OK */ } - - global- - void gfunc() { (void)dcallee(); /* OK */ } - - host- - - device- - int hdfunc() { return dcallee(); /* OK */ }\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.6. Polymorphic Function Wrappers - A polymorphic function wrapper......Example",
    "content": "A polymorphic function wrapper class template nvstd: : function is provided in the nvfunctional header. Instances of this class template can be used to store, copy and invoke any callable target, e.g., lambda expressions. nvstd: : function can be used in both host and device code.\n\nExample:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.6. Polymorphic Function Wrappers - include nvfunctional   device ...",
    "content": "include <nvfunctional> - - device- int foo_d() { return 1; } - - host- - - device- int foo_hd () { return 2; } - - host- - int foo_h() { return 3; } - - global- void kernel(int \\*result) { nvstd::function<int  $()>$  fn1  $=$  foo_d; nvstd::function<int  $()>$  fn2  $=$  foo_hd; nvstd::function<int  $()>$  fn3  $=$  []() { return 10; }; \\*result  $=$  fn1()  $^+$  fn2()  $^+$  fn3(); } - - host- - - device- void hostdevice_func(int \\*result) { nvstd::function<int  $()>$  fn1  $=$  foo_hd; nvstd::function<int  $()>$  fn2  $=$  []() { return 10; }; \\*result  $=$  fn1()  $^+$  fn2(); } - - host- - void host_func(int \\*result) { nvstd::function<int  $()>$  fn1  $=$  foo_h; nvstd::function<int  $()>$  fn2  $=$  foo_hd; nvstd::function<int  $()>$  fn3  $=$  []() { return 10; }; \\*result  $=$  fn"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.6. Polymorphic Function Wrappers - 1    fn2    fn3",
    "content": "1()  $^+$  fn2()  $^+$  fn3(); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.6. Polymorphic Function Wrappers - Instances of nvstd  function i......include nvfunctional",
    "content": "Instances of nvstd: : function in host code cannot be initialized with the address of a __device- - function or with a functor whose operator() is a __device- - function. Instances of nvstd: : function in device code cannot be initialized with the address of a __host- - function or with a functor whose operator() is a __host- - function.\n\nnvstd: : function instances cannot be passed from host code to device code (and vice versa) at run time. nvstd: : function cannot be used in the parameter type of a __global- - function, if the __global- - function is launched from host code.\n\nExample:\n\ninclude <nvfunctional>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.6. Polymorphic Function Wrappers - device int food  return 1  hos......nvstdfunction is defined in th...",
    "content": "device int foo_d() { return 1; } _host int foo_h() { return 3; } auto lam_h = [] { return 0; }; global void k(void) // error: initialized with address of _host function nvstd::function<int()> fn1 = foo_h; // error: initialized with address of functor with // _host operator() function nvstd::function<int()> fn2 = lam_h; } global void kern(nvstd::function<int()> f1) {} void foo(void) // error: initialized with address of _device function nvstd::function<int()> fn1 = foo_d; auto lam_d = [=] _device_ { return 1; }; // error: initialized with address of functor with // _device operator() function nvstd::function<int()> fn2 = lam_d; // error: passing nvstd::function from host to device kern<<<1,1>>> (fn2); }\n\nnvstd::function is defined in the nvfunctional header as follows:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.6. Polymorphic Function Wrappers - namespace nvstd  template clas...",
    "content": "namespace nvstd { template <class RetType, class ..._ArgTypes> class function<_RetType(_ArgTypes...)> { public: // constructors _device_- _host_- function() noexcept; _device_- _host_- function(nullptr_t) noexcept; _device_- _host_- function(const function &); _device_- _host_- function(function &&); template<class _F> _device_- _host_- function(_F); // destructor _device_- _host_- ~function(); // assignment operators _device_- _host_- function& operator=(const function&); _device_- _host_- function& operator=(function&&); _device_- _host_- function& operator=(nullptr_t); _device_- _host_- function& operator=( _F&&); // swap _device_- _host_- void swap(function&) noexcept;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.6. Polymorphic Function Wrappers - function capacity device host ...",
    "content": "// function capacity __device__ _host__ explicit operator bool() const noexcept; // function invocation __device__ _RetType operator()(_ArgTypes...) const; }; // null pointer comparisons template <class _R, class... _ArgTypes> __device__ _host__ bool operator==(const function<_R(_ArgTypes...)&, nullptr_t) noexcept; template <class _R, class... _ArgTypes> __device__ _host__ bool operator==(nullptr_t, const function<_R(_ArgTypes...)&) noexcept; template <class _R, class... _ArgTypes> __device__ _host__ bool operator!(const function<_R(_ArgTypes...)&, nullptr_t) noexcept; template <class _R, class... _ArgTypes> __device__ _host__ bool operator!(nullptr_t, const function<_R(_ArgTypes...)&) noexcept; // specialized algorithms template <class _R, class..."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.6. Polymorphic Function Wrappers - ArgTypes device host void swap...",
    "content": " _ArgTypes> __device__ _host__ void swap(function<_R(_ArgTypes...)&, function<_R(_ArgTypes...)&); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7. Extended Lambdas - The nvcc flag    extended lamb......An extended device lambda is a...",
    "content": "The nvcc flag ' - - extended- lambda' allows explicit execution space annotations in a lambda expression<sup>30</sup>. The execution space annotations should be present after the 'lambda- introducer' and before the optional 'lambda- declarator'. nvcc will define the macro __CUDACC_EXTENDED_LAMBDA__ when the ' - - extended- lambda' flag has been specified.\n\nAn 'extended __device__ lambda' is a lambda expression that is annotated explicitly with ' - - device__', and is defined within the immediate or nested block scope of a __host__ or __host__ - - device__ function."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7. Extended Lambdas - An extended host device lambda......Example",
    "content": "An 'extended __host__ __device__ lambda' is a lambda expression that is annotated explicitly with both __host__ and __device__, and is defined within the immediate or nested block scope of a __host__ or __host__ - - device__ function.\n\nAn 'extended lambda' denotes either an extended __device__ lambda or an extended __host__ - - device__ lambda. Extended lambdas can be used in the type arguments of __global__ function template instantiation.\n\nIf the execution space annotations are not explicitly specified, they are computed based on the scopes enclosing the closure class associated with the lambda, as described in the section on C++11 support.\n\nThe execution space annotations are applied to all methods of the closure class associated with the lambda.\n\nExample:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7. Extended Lambdas - void foohostvoid   not an exte...",
    "content": "void foo_host(void) { // not an extended lambda: no explicit execution space annotations auto lam1  $\\begin{array}{rl}{=}&{\\left[\\begin{array}{llll}\\end{array}\\right]\\quad\\{\\begin{array}{llll}\\end{array}\\}}\\end{array}$  // extended _device__ lambda auto lam2  $\\begin{array}{rl}{=}&{\\left[\\begin{array}{llll}\\end{array}\\right]\\quad\\underline{\\phantom{1}}}\\end{array}$  _device_ { }; // extended _host__ _device__ lambda auto lam3  $\\begin{array}{rl}{=}&{\\left[\\begin{array}{llll}\\end{array}\\right]\\quad\\underline{\\phantom{1}}}\\end{array}$  _host__ _device_ { }; // not an extended lambda: explicitly annotated with only '_ host__' auto lam4  $\\begin{array}{rl}{=}&{\\left[\\begin{array}{llll}\\end{array}\\right]\\quad\\underline{\\phantom{1}}}\\end{array}$  _host_ { }; } _host__ _device__ void foo_host_dev"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7. Extended Lambdas - icevoid   not an extended lamb...",
    "content": "ice(void) { // not an extended lambda: no explicit execution space annotations auto lam1  $\\begin{array}{rl}{=}&{\\left[\\begin{array}{llll}\\end{array}\\right]\\quad\\{\\begin{array}{llll}\\end{array}\\}}\\end{array}$  // extended _device__ lambda auto lam2  $\\begin{array}{rl}{=}&{\\left[\\begin{array}{llll}\\end{array}\\right]\\ \\underline{\\phantom{1}}}\\end{array}$  _device_ { }; // extended _host__ _device__ lambda auto lam3  $\\begin{array}{rl}{=}&{\\left[\\begin{array}{llll}\\end{array}\\right]\\quad\\underline{\\phantom{1}}}\\end{array}$  _host__ _device_ { }; // not an extended lambda: explicitly annotated with only '_ host__' auto lam4  $\\begin {array}{rl}{=}&{\\left[\\begin{array}{llll}\\end{array}\\right]\\quad\\underline{\\phantom{1}}}\\end{array}$  _host_ { }; } _device__ void foo_device(void) { // none of th"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7. Extended Lambdas - e lambdas within this function...",
    "content": "e lambdas within this function are extended lambdas, // because the enclosing function is not a _host_ or _host__ _device_ // function."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7. Extended Lambdas - auto lam1  beginarrayrlleftbeg...",
    "content": " auto lam1  $\\begin{array}{rl}{=}&{\\left[\\begin{array}{llll}\\end{array}\\right]\\quad\\{\\begin{array}{llll}\\end{array}\\}}\\end{array}$  auto lam2  $\\begin{array}{rl}{=}&{\\left[\\begin{array}{llll}\\end{array}\\right]\\quad\\underline{\\phantom{1}}}\\end{array}$  _device_ { }; auto lam3  $\\begin{array}{rl}{=}&{\\left[\\begin{array}{llll}\\end{array}\\right]\\quad\\underline{\\phantom{1}}}\\end{array}$  _host__ _device_ { }; auto lam4  $\\begin{array}{rl}{=}&{\\left[\\begin{array}{llll}\\end{array}\\right]\\quad\\underline{\\phantom{1}}}\\end{array}$  _host_ { }; } // lam1 and lam2 are not extended lambdas because they are not defined // within a _host__ or _host__ _device__ function."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7. Extended Lambdas - auto lam1  beginarrayrlleftbeg...",
    "content": " auto lam1  $\\begin{array}{rl}{=}&{\\left[\\begin{array}{llll}\\end{array}\\right]\\quad\\{\\begin{array}{llll}\\end{array}\\}}\\end{array}$  auto lam2  $\\begin{array}{rl}{=}&{\\left[\\begin{array}{llll}\\end{array}\\right]\\quad\\underline{\\phantom{1}}}\\end{array}$  _host__ _device_ { };"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.1. Extended Lambda Type Traits - The compiler provides type tra......Example",
    "content": "The compiler provides type traits to detect closure types for extended lambdas at compile time: _nv_is_extended_device_lambda_closure_type(type): If 'type' is the closure class created for an extended _device_ lambda, then the trait is true, otherwise it is false. _nv_is_extended_host_device_lambda_closure_type(type): If 'type' is the closure class created for an extended _host_ _device_ lambda, then the trait is true, otherwise it is false. These traits can be used in all compilation modes, irrespective of whether lambdas or extended lambdas are enabled<sup>3</sup>.\n\nExample:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.1. Extended Lambda Type Traits - define ISDLAMBDAX nvisextended...",
    "content": "define IS_D_LAMBDA(X) _nv_is_extended_device_lambda_closure_type(X) #define IS_HD_LAMBDA(X) _nv_is_extended_host_device_lambda_closure_type(X) auto lam0 \\(\\begin{array}{rl}{\\Theta}&{=}\\end{array}\\) [] _host__ _device_ { }; void foo(void) { auto lam1 \\(\\begin{array}{rl}{=}&{\\left[\\begin{array}{lll}\\end{array}\\right]\\begin{array}{l}{\\left\\{\\begin{array}{l}{\\left\\{\\begin{array}{l}{\\left\\{\\begin{array}{l}{\\left\\{\\begin{array}{l}{\\left\\{\\begin{array}{l}{\\left\\{\\begin{array}{l}{\\left\\{\\begin{array}{l}{\\left\\{\\begin{array}{l}{\\left\\{\\begin{array}{l}{\\left\\{\\begin{array}{l}{\\left\\left\\{\\begin{array}{l}{\\left\\left\\{\\begin{array}{l}{\\left\\left\\{\\begin{array}{l}{\\left\\left\\{\\begin{array}{l}{\\left\\left\\{\\begin{array}{l}{\\left\\left\\{\\begin{array}{l}{\\left\\left\\{\\begin{array}{l}{\\left\\left\\{\\begin{array"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.1. Extended Lambda Type Traits - lleftleftleftbeginarraylleftle...",
    "content": "}{l}{\\left\\left\\left\\{\\begin{array}{l}{\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\left\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\right\\left\\right\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.1. Extended Lambda Type Traits - rightleftrightleftrightleftrig...",
    "content": "\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\left\\right\\left\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\le"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.1. Extended Lambda Type Traits - ftrightleftrightleftrightleftr...",
    "content": "ft\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\l"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.1. Extended Lambda Type Traits - eftrightrightleftrightrightlef...",
    "content": "eft\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\righ"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.1. Extended Lambda Type Traits - tleftrightleftrightleftrightle...",
    "content": "t\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\right\\left\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\right\\left\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\left\\right\\right\\left\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\r"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.1. Extended Lambda Type Traits - ightleftrightrightleftrightrig...",
    "content": "ight\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\left\\right\\right\\left\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\left\\right\\right\\left\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\left\\right\\right\\left\\right\\right\\left\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.1. Extended Lambda Type Traits - rightleftrightrightleftrightri...",
    "content": "\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\left\\right\\right\\left\\right\\right\\left\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\left\\right\\right\\left\\right\\right\\left\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\left\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\le"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.1. Extended Lambda Type Traits - ftrightrightleftrightrightleft...",
    "content": "ft\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\left\\right\\left\\right\\right\\left\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\right\\left\\right\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\righ"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.1. Extended Lambda Type Traits - trightleftrightrightleftrightr...",
    "content": "t\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\left\\right\\right\\left\\left\\right\\right\\left\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\right\\right\\left\\left\\right\\right\\left\\left\\right\\right\\left\\left\\right\\right\\left\\left\\right\\right\\left\\left\\right\\right\\left\\left\\right\\right\\left\\left\\right\\right\\left\\left\\right\\right\\left\\left\\right\\right\\left\\left\\right\\right\\left\\left\\right\\right\\left\\left\\right\\right\\left\\left\\left\\right\\right\\left\\left\\right\\right\\left\\left\\right\\right\\left\\left\\right\\right\\left\\left\\right\\right\\l"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.1. Extended Lambda Type Traits - eftleftrightrightleftleftright...",
    "content": "eft\\left\\right\\right\\left\\left\\right\\right\\left\\left\\right\\right\\left\\left\\right\\right\\left\\left\\right\\right\\left\\left\\right\\right\\left\\left\\right\\right\\left\\right\\left\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\right\\left\\right\\left\\right\\left\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\rig"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.1. Extended Lambda Type Traits - htleftrightleftrightleftrightl...",
    "content": "ht\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\left\\right\\right\\left\\righ"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.1. Extended Lambda Type Traits - tleftrightleftrightleftrightle...",
    "content": "t\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.1. Extended Lambda Type Traits - leftrightleftleftrightrightlef...",
    "content": "\\left\\right\\left\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.1. Extended Lambda Type Traits - leftrightleftrightleftrightlef...",
    "content": "left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right\\left\\right."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.1. Extended Lambda Type Traits - rightrightrightrightrightright...",
    "content": "\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\right.\\]"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.2. Extended Lambda Restrictions - The CUDA compiler will replace......By definition the extended lam...",
    "content": "The CUDA compiler will replace an extended lambda expression with an instance of a placeholder type defined in namespace scope, before invoking the host compiler. The template argument of the placeholder type requires taking the address of a function enclosing the original extended lambda expression. This is required for the correct execution of any  $\\_$ function template whose template argument involves the closure type of an extended lambda. The enclosing function is computed as follows.\n\nBy definition, the extended lambda is present within the immediate or nested block scope of a  $\\_$ host_ or  $\\_$ host_  $\\_$ device_ function. If this function is not the operator() of a lambda"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.2. Extended Lambda Restrictions - expression then it is consider......void foovoid   enclosing funct...",
    "content": "expression, then it is considered the enclosing function for the extended lambda. Otherwise, the extended lambda is defined within the immediate or nested block scope of the operator () of one or more enclosing lambda expressions. If the outermost such lambda expression is defined in the immediate or nested block scope of a function F, then F is the computed enclosing function, else the enclosing function does not exist.\n\nExample:\n\nvoid foo(void) { // enclosing function for lam1 is \"foo\" auto lam1  $\\equiv$  [] device_ { }; auto lam2  $\\equiv$  [] { auto lam3  $\\equiv$  [] { // enclosing function for lam4 is \"foo\" auto lam4  $\\equiv$  [] _host_- - device_ { }; }; }; } auto lam6  $\\equiv$  [] { // enclosing function for lam7 does not exist auto lam7  $\\equiv$  [] _host_- - device_ { }; };"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.2. Extended Lambda Restrictions - Here are the restrictions on e......3 If an extended lambda is def...",
    "content": "Here are the restrictions on extended lambdas:\n\n1. An extended lambda cannot be defined inside another extended lambda expression.\n\nExample:\n\nvoid foo(void) { auto lam1  $\\equiv$  [] _host_- - device_- // error: extended lambda defined within another extended lambda auto lam2  $\\equiv$  [] _host_- - device_ { }; }; }\n\n2. An extended lambda cannot be defined inside a generic lambda expression.\n\nExample:\n\nvoid foo(void) { auto lam1  $\\equiv$  [] (auto) { // error: extended lambda defined within a generic lambda auto lam2  $\\equiv$  [] _host_- - device_ { }; }; }\n\n3. If an extended lambda is defined within the immediate or nested block scope of one or more nested lambda expression, the outermost such lambda expression must be defined inside the immediate or nested block scope of a function."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.2. Extended Lambda Restrictions - Example",
    "content": "Example:\n\nauto lam1  $\\equiv$  [] { // error: outer enclosing lambda is not defined within a // non- lambda- operator() function. auto lam2  $\\equiv$  [] _host_- - device_ { }; };\n\n4. The enclosing function for the extended lambda must be named and its address can be taken. If the enclosing function is a class member, then the following conditions must be satisfied:\n\nAll classes enclosing the member function must have a name. The member function must not have private or protected access within its parent class. All enclosing classes must not have private or protected access within their respective parent classes.\n\nExample:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.2. Extended Lambda Restrictions - void foovoid   OK auto lam1  e...",
    "content": "void foo(void) { // OK auto lam1  $\\equiv$  [] __device_ { return 0; }; { // OK auto lam2  $\\equiv$  [] __device_ { return 0; }; // OK auto lam3  $\\equiv$  [] __device_ _host_ { return 0; }; } } struct S1_t { S1_t(void) { // Error: cannot take address of enclosing function auto lam4  $\\equiv$  [] __device_ { return 0; }; } }; class C2_t { void foo(void) { // Error: enclosing function has private access in parent class auto temp1  $\\equiv$  [] __device_ { return 10; }; } struct S2_t { void foo(void) { // Error: enclosing class S2_t has private access in its // parent class auto temp1  $\\equiv$  [] __device_ { return 10; }; } }; };"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.2. Extended Lambda Restrictions - 5 It must be possible to take ......template typename struct A  ty...",
    "content": "5. It must be possible to take the address of the enclosing routine unambiguously, at the point where the extended lambda has been defined. This may not be feasible in some cases e.g. when a class typedef shadows a template type argument of the same name.\n\nExample:\n\ntemplate <typename> struct A { typedef void Bar; void test(); }; template<> struct A<void> {}; template <typename Bar> void A<Bar>::test() {"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.2. Extended Lambda Restrictions - In code sent to host compiler ......void foovoid  struct Slt  void...",
    "content": "/\\* In code sent to host compiler, nvcc will inject an address expression here, of the form: (void (A< Bar> ::\\*)(void))(&A::test)) However, the class typedef 'Bar' (to void) shadows the template argument 'Bar', causing the address expression in A<int>::test to actually refer to: (void (A< void> ::\\*)(void))(&A::test)) .which doesn't take the address of the enclosing routine 'A<int>::test' correctly. \\*/ auto lam1  $\\equiv$  [] _host_- - device_- { return 4; }; } int main() { A<int> xxx; xxx.test(); }\n\n6. An extended lambda cannot be defined in a class that is local to a function.\n\nExample:\n\nvoid foo(void) { struct Sl_t { void bar(void) { // Error: bar is member of a class that is local to a function. auto lam4  $\\equiv$  [] _host_- - device_- { return 0; }; } }; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.2. Extended Lambda Restrictions - 7 The enclosing function for a......void foovoid   Error host  dev...",
    "content": "7. The enclosing function for an extended lambda cannot have deduced return type.\n\nExample:\n\nauto foo(void) { // Error: the return type of foo is deduced. auto lam1  $\\equiv$  [] _host_- - device_- { return 0; }; }\n\n8. _host_- - device_ extended lambdas cannot be generic lambdas.\n\nExample:\n\nvoid foo(void) { // Error: _host_- - device_ extended lambdas cannot be // generic lambdas. auto lam1  $\\equiv$  [] _host_- - device_- (auto i) { return i; }; // Error: _host_- - device_ extended lambdas cannot be // generic lambdas. auto lam2  $\\equiv$  [] _host_- - device_- (auto ...i) { return sizeof...(i); }; }; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.2. Extended Lambda Restrictions - 9 If the enclosing function is......The template must have at most...",
    "content": "9. If the enclosing function is an instantiation of a function template or a member function template, and/or the function is a member of a class template, the template(s) must satisfy the following constraints:\n\nThe template must have at most one variadic parameter, and it must be listed last in the template parameter list. The template parameters must be named. The template instantiation argument types cannot involve types that are either local to a function (except for closure types for extended lambdas), or are private or protected class members."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - template typename T global voi...",
    "content": "template <typename T> global void kern(T in) { in(); } template <typename... T> struct foo {}; template <template <typename...> class T, typename... P1, typename... P2> void bar1(const T<P1. .>, const T<P2. .>) { // Error: enclosing function has multiple parameter packs auto laml  $\\begin{array}{rl}{=}&{\\left[\\begin{array}{lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll}\\end{array}\\right]}\\end{array}$  device_ {return 10; } } template <template <typename...> class T, typename... P1, typename T2> void bar2(const T:P1. .>, T2) { // Error: for enclosing function, the // parameter pack is not last in the template parameter list."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - auto laml  beginarrayrlleftbeg...",
    "content": " auto laml  $\\begin{array}{rl}{=}&{\\left[\\begin{array}{lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll}\\end{array}\\right]}\\end{array}$  device_ {return 1o; }; } template <typename T, T> void bar3(void) { // Error: for enclosing function, the second template // parameter is not named. auto laml  $\\begin{array}{rl}{=}&{\\left[\\begin{array}{lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll}\\end{array}\\right]}\\end{array}$  auto char, int, float> f1; foo<char, int> f2; bar1(f1, f2); bar2(f1, 10); bar3<int, 10>(); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - template typename T global voi......kern  epsilon  epsilon  1 1   ...",
    "content": "template <typename T> global void kern(T in) { in(); } template <typename T> void bar4(void) { auto laml  $\\begin{array}{rl}{=}&{\\left[\\begin{array}{llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll}\\end{array}\\right]}\\end{array}$\n\nkern  $\\epsilon < \\epsilon < 1$ $1 > > >$  (lam1); struct C1_t { struct S1_t { }; friend int main(void); }; int main() { struct S1_t { }; // Error: enclosing function for device lambda in bar4 // is instantiated with a type local to main. bar4<S1_t>(); // Error: enclosing function for device lambda in bar4 // is instantiated with a type that is a private member // of a class. bar4<C1_t::S1_t>(); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - 10 With Visual Studio host com......12 An extended lambda has the ...",
    "content": "10. With Visual Studio host compilers, the enclosing function must have external linkage. The restriction is present because this host compiler does not support using the address of non-extem linkage functions as template arguments, which is needed by the CUDA compiler transformations to support extended lambdas.\n\n11. With Visual Studio host compilers, an extended lambda shall not be defined within the body of an 'if-constexpr' block.\n\n12. An extended lambda has the following restrictions on captured variables:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - In the code sent to the host c...",
    "content": "In the code sent to the host compiler, the variable may be passed by value to a sequence of helper functions before being used to direct- initialize the field of the class type used to represent the closure type for the extended lambda<sup>32</sup>.- A variable can only be captured by value.- A variable of array type cannot be captured if the number of array dimensions is greater than 7. - For a variable of array type, in the code sent to the host compiler, the closure type's array field is first default- initialized, and then each element of the array field is copy- assigned from the corresponding element of the captured array variable. Therefore, the array element type must be default- constructible and copy- assignable in host code."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - A function parameter that is a...",
    "content": "- A function parameter that is an element of a variadic argument pack cannot be captured.- The type of the captured variable cannot involve types that are either local to a function (except for closure types of extended lambdas), or are private or protected class members.- For a __host__ __device__ extended lambda, the types used in the return or parameter types of the lambda expression's operator() cannot involve types that are either local to a function (except for closure types of extended lambdas), or are private or protected class members.- Init- capture is not supported for __host__ __device__ extended lambdas. Init- capture is supported for __device__ extended lambdas, except when the init- capture is of array type or of type std::initializer_list."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - The function call operator for...",
    "content": "- The function call operator for an extended lambda is not constexpr. The closure type for an extended lambda is not a literal type. The constexpr and consteval specifier cannot be used in the declaration of an extended lambda."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - A variable cannot be implicitl......Example",
    "content": "A variable cannot be implicitly captured inside an if- constexpr block lexically nested inside an extended lambda, unless it has already been implicitly captured earlier outside the if- constexpr block or appears in the explicit capture list for the extended lambda (see example below).\n\nExample"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - void foovoid   OK an init capt...",
    "content": "void foo(void) { // OK: an init- capture is allowed for an // extended __device__ lambda. auto lam1  $=$ $[x = 1]$  __device__ () { return x; }; // Error: an init- capture is not allowed for // an extended __host__ __device__ lambda. auto lam2  $=$ $[x = 1]$  __host__ __device__ () { return x; }; int a  $=$  1; // Error: an extended __device__ lambda cannot capture // variables by reference. auto lam3  $=$  [&a] __device__ () { return a; }; // Error: by- reference capture is not allowed // for an extended __device__ lambda. auto lam4  $=$  [&x  $=$  a] __device__ () { return x; }; struct Sl_t { }; S1_t s1; // Error: a type local to a function cannot be used in the type // of a captured variable."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - auto lam5    a1 device     Err...",
    "content": " auto lam5  $=$  [a1] __device__ () { }; // Error: an init- capture cannot be of type std::initializer_list. auto lam7  $=$  [x  $=$  {11}] __device__ () { }; std::initializer_list<int> b  $=$  {11,22,33}; // Error: an init- capture cannot be of type std::initializer_list. auto lam8  $=$  [x  $=$  b] __device__ () { }; // Error scenario (lam9) and supported scenarios (lam10, lam11) // for capture within 'if- constexpr' block int yyy  $= 4$  . auto lam9  $=$  [=] __device__ { int result  $= 0$  . if constexpr(false) { //Error: An extended __device__ lambda cannot first- capture // 'yyy' in constexpr- if context result  $+ =$  yyyy; } return result; }; auto lam10  $=$  [yyyy] __device__ { int result  $= 0$  ."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - if constexprfalse  OK yyy alre...",
    "content": " if constexpr(false) { //OK: 'yyy' already listed in explicit capture list for the extended lambda result  $+ =$  yyyy; } return result;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - auto lam1   device  int result......Example",
    "content": "}; auto lam1 = [=] __device__ { int result = yyy; if constexpr(false) { //OK: 'yyy' already implicit captured outside the 'if- constexpr' block result += yyy; } return result; };\n\n13. When parsing a function, the CUDA compiler assigns a counter value to each extended lambda within that function. This counter value is used in the substituted named type passed to the host compiler. Hence, whether or not an extended lambda is defined within a function should not depend on a particular value of __CUDA_ARCH__, or on __CUDA_ARCH__ being undefined.\n\nExample"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - template typename T global voi...",
    "content": "template <typename T> global void kernel(T in) { in(); } _host__ __device__ void foo(void) { // Error: the number and relative declaration // order of extended lambdas depends on // __CUDA_ARCH__ #if defined(__CUDA_ARCH__) auto lam1 = [] __device__ { return 0; }; auto lam1b = [] __host__ __device__ { return 10; }; #endif auto lam2 = [] __device__ { return 4; }; kernel<<1,1>>>(lam2); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - 14 As described above the CUDA......Example",
    "content": "14. As described above, the CUDA compiler replaces a __device__ extended lambda defined in a host function with a placeholder type defined in namespace scope. This placeholder type does not define a operator() function equivalent to the original lambda declaration. An attempt to determine the return type or parameter types of the operator() function may therefore work incorrectly in host code, as the code processed by the host compiler will be semantically different than the input code processed by the CUDA compiler. However, it is OK to introspect the return type or parameter types of the operator() function within device code. Note that this restriction does not apply to __host__ __device__ extended lambdas.\n\nExample"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - include typetraits void foovoi......OK  lam2 represents a host dev...",
    "content": "include <type_traits> void foo(void) { auto lam1 = [] __device__ { return 10; }; // Error: attempt to extract the return type // of a __device__ lambda in host code std::result_of<decltype(lam1)()>::type xx1 = 1; auto lam2 = [] __host__ __device__ { return 10; };\n\n(continues on next page)\n\n// OK : lam2 represents a __host__ __device__ extended lambda std::result_of<decltype(lam2)()>::type xx2 = 1;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - 15 If the functor object repre......Example",
    "content": "15. If the functor object represented by an extended lambda is passed from host to device code (e.g., as the argument of a __global__ function), then any expression in the body of the lambda expression that captures variables must be remain unchanged irrespective of whether the __CUDA_ARCH__ macro is defined, and whether the macro has a particular value. This restriction arises because the lambda's closure class layout depends on the order in which captured variables are encountered when the compiler processes the lambda expression; the program may execute incorrectly if the closure class layout differs in device and host compilation.\n\nExample"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - device int result template typ......16 As described previously the...",
    "content": "device__ int result; template <typename T> global void kernel(T in) { result = in(); } void foo(void) { int  $\\times 1 = 1$  . auto lam1  $\\begin{array}{rl}{=}&{\\left[=]\\right.}\\end{array}$  __host__ __device__ // Error: \"x1\" is only captured when __CUDA_ARCH__ is defined. #ifdef __CUDA_ARCH__ return  $x1 + 1$  . #else return 10; #endif }; kernel  $\\epsilon < < 1$  ,1>>> (lam1); }\n\n16. As described previously, the CUDA compiler replaces an extended __device__ lambda expression with an instance of a placeholder type in the code sent to the host compiler. This placeholder type does not define a pointer-to-function conversion operator in host code, however the conversion operator is provided in device code. Note that this restriction does not apply to __host__ __device__ extended lambdas."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - Example...auto lamhd  equiv   host devic...",
    "content": "Example\n\ntemplate <typename T> global void kern(T in) { int (\\*fp)(double)  $\\equiv$  in; // OK: conversion in device code is supported fp(0); auto lam1  $\\equiv$  [](double) { return 1; } // OK: conversion in device code is supported fp  $\\equiv$  lam1; fp(0); } void foo(void) { auto lam_d  $\\equiv$  [] __device__ (double) { return 1; };\n\nauto lam_hd  $\\equiv$  [] _host__ _device_ (double) { return 1; }; kern  $\\epsilon < < 1$ $1 > > > (1a m\\_ d)$  kern  $\\epsilon < < 1$ $1 > > > (1a m\\_ h d)$  // OK : conversion for _host__ _device_ lambda is supported // in host code int (\\*fp)(double)  $=$  lam_hd; // Error: conversion for _device_ lambda is not supported in // host code. int (\\*fp2)(double)  $=$  lam_d; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - 17 As described previously the...",
    "content": "17. As described previously, the CUDA compiler replaces an extended __device__ or __host__ __device__ lambda expression with an instance of a placeholder type in the code sent to the host compiler. This placeholder type may define C++ special member functions (e.g. constructor, destructor). As a result, some standard C++ type traits may return different results for the closure type of the extended lambda, in the CUDA frontend compiler versus the host compiler. The following type traits are affected: std::is_trivially_copyable, std::is_trivially_constructible, std::is_trivially_copy_constructible, std::is_trivially_move_constructible, std::is_trivially_destroy reconstructible."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - Care must be taken that the re......ERROR this kernel launch may f...",
    "content": "Care must be taken that the results of these type traits are not used in __global__ function template instantiation or in __device__ / __constant__ / __managed__ variable template instantiation.\n\nExample\n\ntemplate <bool b> void __global__ foo() { printf(\"hi\"); }\n\ntemplate <typename T> void dolaunch() {\n\n// ERROR: this kernel launch may fail, because CUDA frontend compiler // and host compiler may disagree on the result of // std::is_trivially_copyable() trait on the closure type of the // extended lambda foo<std::is_trivially_copyable<T>::value<<<1,1>>>(); cudaDeviceSynchronize(); } int main() { int x = 0; auto lam1 = [=] __host__ __device__ () { return x; }; dolaunch<decitype(lam1)>; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Example: - The CUDA compiler will generat...",
    "content": "The CUDA compiler will generate compiler diagnostics for a subset of cases described in 1- 12; no diagnostic will be generated for cases 13- 17, but the host compiler may fail to compile the generated code."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.3. Notes on __host__ __device__ lambdas - Unlike device lambdas host dev...",
    "content": "Unlike __device__ lambdas, __host__ __device__ lambdas can be called from host code. As described earlier, the CUDA compiler replaces an extended lambda expression defined in host code with an instance of a named placeholder type. The placeholder type for an extended __host__ __device__ lambda invokes the original lambda's operator() with an indirect function C#<sup>Page 396, 31</sup>."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.3. Notes on __host__ __device__ lambdas - The presence of the indirect f...",
    "content": "The presence of the indirect function call may cause an extended __host__ __device__ lambda to be less optimized by the host compiler than lambdas that are implicitly or explicitly __host__ only. In the latter case, the host compiler can easily inline the body of the lambda into the calling context. But in case of an extended __host__ __device__ lambda, the host compiler encounters the indirect function call and may not be able to easily inline the original __host__ __device__ lambda body."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.4. *this Capture By Value - When a lambda is defined withi......Example",
    "content": "When a lambda is defined within a non- static class member function, and the body of the lambda refers to a class member variable,  $\\mathbb{C} + + 11 / \\mathbb{C} + + 14$  rules require that the this pointer of the class is captured by value, instead of the referenced member variable. If the lambda is an extended __device__ or __host__ __device__ lambda defined in a host function, and the lambda is executed on the GPU, accessing the referenced member variable on the GPU will cause a run time error if the this pointer points to host memory.\n\nExample:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.4. *this Capture By Value - cppinclude cstdlibtemplate typ...",
    "content": "```cpp#include <cstdlib>template <typename T>__global__ void foo(T in) { printf(\"\\n value = %d\", in()); }struct S1_t {    int xxx;    __device__ S1_t(void) : xxx(10) { };    void doit(void) {        auto lam1 = [=] __device__ {            // reference to \"xxx\" causes            // the 'this' pointer (S1_t*) to be captured by value            return xxx + 1;        };        // Kernel launch fails at run time because 'this- >xxx'        // is not accessible from the GPU        foo<<<1,1>>>(lam1);        cudaDeviceSynchronize();    };};int main(void) {    S1_t s1;    s1.doit();}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.4. *this Capture By Value - mathttC   17  solves this prob......Heres the above example modifi...",
    "content": "$\\mathtt{C + + 17}$  solves this problem by adding a new \\*\\*this\" capture mode. In this mode, the compiler makes a copy of the object denoted by \\*\\*this\" instead of capturing the pointer this by value. The \\*\\*this\" capture mode is described in more detail here: http://www.open- std.org/jtc1/sc22/wg21/docs/ papers/2016/p0018r3. html.\n\nThe CUDA compiler supports the \\*\\*this\" capture mode for lambdas defined within __device__ and __global__ functions and for extended __device__ lambdas defined in host code, when the - - extended- lambda nvcc flag is used.\n\nHere's the above example modified to use \\*\\*this\" capture mode:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "#include <cctdina> - template typename T global voi......note the this capture specific...",
    "content": "template <typename T> global__ void foo(T in) { printf(\"\\n value = %d\", in()); }\n\nstruct S1_t {\n\nint xxx; _host__ _device__ S1_t(void) : xxx(10) { };\n\nvoid doit(void) {\n\n// note the \\*\\*this\" capture specification auto lam1  $\\begin{array}{rl}{=}&{\\left[\\begin{array}{lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll}\\end{array}\\right]}\\end{array}$  // reference to \"xxx\" causes // the object denoted by \\*this' to be captured by // value, and the GPU code will access copy_of_star_this- >xxx return xxx + 1; }; // Kernel launch succeeds foo<<1,1>>=(lam1); cudaDeviceSynchronize(); }; int main(void) { S1_t s1; s1. doit(); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "#include <cctdina> - this capture mode is not allow......void hostfuncvoid",
    "content": "\\*\\*this\" capture mode is not allowed for unannotated lambdas defined in host code, or for extended __host__device__ lambdas. Examples of supported and unsupported usage:\n\nstruct S1_t { int xxx; _host__ _device__ S1_t(void) : xxx(10) { };\n\nvoid host_func(void) {"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "#include <cctdina> - OK use in an extended device l...",
    "content": "// OK: use in an extended __device__ lambda auto lam1  $\\begin{array}{rl}{=}&{\\left[\\begin{array}{lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll}\\end{array}\\right]}\\end{array}$  *this] _device_ { return xxx; }; // Error: use in an extended _host__ _device__ lambda auto lam2  $\\begin{array}{rl}{=}&{\\left[\\begin{array}{lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll}\\end{array}\\right]}\\end{array}$  *this] _host__ _device_ { return xxx; };"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "#include <cctdina> - Error use in an unannotated la...",
    "content": "// Error: use in an unannotated lambda in host function auto lam3  $=$ $[ =$  \\*this] { return xxx; }; } - - device- - void device_func(void) { // OK: use in a lambda defined in a - - device- - function auto lam1  $=$ $[ =$  \\*this] - - device- - { return xxx; }; // OK: use in a lambda defined in a - - device- - function auto lam2  $=$ $[ =$  \\*this] - - host- - - device- - { return xxx; }; // OK: use in a lambda defined in a - - device- - function auto lam3  $=$ $[ =$  \\*this] { return xxx; }; } - - host- - - device- - void host_device_func(void) { // OK: use in an extended - - device- - lambda auto lam1  $=$ $[ =$  \\*this] - - device- - { return xxx; }; // Error: use in an extended - - host- - - device- - lambda auto lam2  $=$ $[ =$  \\*this] - - host- - - device- - { return xxx; }; // Er"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "#include <cctdina> - ror use in an unannotated lamb...",
    "content": "ror: use in an unannotated lambda in a - - host- - - device- - function auto lam3  $=$ $[ =$  \\*this] { return xxx; }; } };"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.5. Additional Notes - 1 ADL Lookup As described earl......Example",
    "content": "1. ADL Lookup: As described earlier, the CUDA compiler will replace an extended lambda expression with an instance of a placeholder type, before invoking the host compiler. One template argument of the placeholder type uses the address of the function enclosing the original lambda expression. This may cause additional namespaces to participate in argument dependent lookup (ADL), for any host function call whose argument types involve the closure type of the extended lambda expression. This may cause an incorrect function to be selected by the host compiler.\n\nExample:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.5. Additional Notes - namespace N1  struct Slt   tem......is replaced with the placehold...",
    "content": "namespace N1 { struct Sl_t { }; template <typename T> void foo(T); }; namespace N2 { template <typename T> int foo(T); template <typename T> void doit(T in) { foo(in); } } void bar(N1::S1_t in) { /* extended __device__ lambda. In the code sent to the host compiler, this (continues on next page)\n\nis replaced with the placeholder type instantiation expression ' _nv_dl_wrapper_t< _nv_dl_tag<void (\\*)(N1::S1_t in),(&bar),1> > { }' As a result, the namespace 'N1' participates in ADL lookup of the call to \"foo\" in the body of N2::doit, causing ambiguity. */ auto lam1 = [=] __device__ { }; N2::doit(iam1); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.7.5. Additional Notes - In the example above the CUDA ...",
    "content": "In the example above, the CUDA compiler replaced the extended lambda with a placeholder type that involves the N1 namespace. As a result, the namespace N1 participates in the ADL lookup for foo(in) in the body of N2::doit, and host compilation fails because multiple overload candidates N1::foo and N2::foo are found."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.8. Code Samples",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.8.1. Data Aggregation Class - class PixelRGBA  public device...",
    "content": "# 17.8.1. Data Aggregation Class\nclass PixelRGBA { public: __device__ PixelRGBA(: r_0), g_0), b_0), a_0) {} __device__ PixelRGBA(unsigned char r, unsigned char g, unsigned char b, unsigned char a = 255): r_r), g_g), b_b), a_a) {} private: unsigned char r_ g_ b_ a_; friend PixelRGBA operator+(const PixelRGBA&, const PixelRGBA); }; __device__ PixelRGBA operator+(const PixelRGBA& p1, const PixelRGBA& p2) { return PixelRGBA(p1. r_ + p2. r_ p1. g_ + p2. g_ p1. b_ + p2. b_ p1. a_ + p2. a); } __device__ void func(void) { PixelRGBA p1, p2; // // Initialization of p1 and p2 here PixelRGBA p3 = p1 + p2; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.8.2. Derived Class - device void operator newsizet ...",
    "content": "# 17.8.2. Derived Class\ndevice__ void\\* operator new(size_t bytes, MemoryPool& p); - - device__ void operator delete(void\\*, MemoryPool& p); class Shape { public: - - device__ Shape(void) {} - - device__ void putThis(PrintBuffer \\*p) const; - - device__ virtual void Draw(PrintBuffer \\*p) const { p- >put(\"Shapeless\"); } - - device__ virtual \\~Shape() {} }; class Point : public Shape { public: - - device__ Point() : x(0), y(0) {} - - device__ Point(int ix, int iy) : x(ix), y(iy) {} - - device__ void PutCoord(PrintBuffer \\*p) const; - - device__ void Draw(PrintBuffer \\*p) const; - - device__ \\~Point() {} private: int x, y; }; - - device__ Shape\\* GetPointObj(MemoryPool& pool) { Shape\\* shape  $=$  new(pool) Point(rand(- 20,10), rand(- 100,- 20)); return shape; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.8.4. Function Template - template class T class myValue......template typename T device boo...",
    "content": "# 17.8.3. Class Template\ntemplate <class T> class myValues { T values[MAX VALUES]; public: - - device__ myValues(T clear) { ... } - - device__ void setValue(int idx, T value) { ... } - - device__ void putToMemory(T\\* valueLocation) { ... } }; template <class T> void global__ useValues(T\\* memoryBuffer) { myValues<T> myLocation(0); } - - device__ void\\* buffer; int main() { useValues<int<<<blocks, threads>>> (buffer); }\n\n# 17.8.4. Function Template\ntemplate <typename T> _device__ bool func(T x) { return (...) } template  $\\epsilon >$  _device__ bool func<int>(T x) // Specialization { return true; } // Explicit argument specification bool result  $=$  func<double>0.5); // Implicit argument deduction int  $x = 1$  . bool result  $=$  func(x);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "17.8.5. Functor Class - class Add  public  device floa......VectorOperationblocks threads ...",
    "content": "# 17.8.5. Functor Class\nclass Add { public: - _device float operator() (float a, float b) const { return a + b; } }; class Sub { public: - _device float operator() (float a, float b) const { return a - b; } }; // Device code template<class 0> global void VectorOperation(const float \\* A, const float \\* B, float \\* C, unsigned int N, O op) unsigned int iElement  $=$  blockDim.x \\* blockIdx.x  $^+$  threadIdx.x; if (iElement < N) C[iElement]  $=$  op(A[iElement], B[iElement]); } // Host code int main() {\n\n(continued from previous page)\n\nVectorOperation<<blocks, threads>>> (v1, v2, v3, N, Add());"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 18. Texture Fetching - This section gives the formula......N  texels for a onedimensional...",
    "content": "This section gives the formula used to compute the value returned by the texture functions of Texture Functions depending on the various attributes of the texture reference (see Texture and Surface Memory).\n\nThe texture bound to the texture reference is represented as an array  $T$  of\n\n-  $N$  texels for a one-dimensional texture,-  $N \\times M$  texels for a two-dimensional texture,-  $N \\times M \\times L$  texels for a three-dimensional texture."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 18. Texture Fetching - It is fetched using non normal...",
    "content": "It is fetched using non- normalized texture coordinates x, y, and z, or the normalized texture coordinates  $x / N$ ,  $y / M$ , and  $z / L$  as described in Texture Memory. In this section, the coordinates are assumed to be in the valid range. Texture Memory explained how out- of- range coordinates are remapped to the valid range based on the addressing mode."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "18.1. Nearest-Point Sampling - In this filtering mode the val......Fig 1 NearestPoint Sampling Fi...",
    "content": "# 18.1. Nearest-Point Sampling\nIn this filtering mode, the value returned by the texture fetch is -  $tex(x) = T[i]$  for a one-dimensional texture,-  $tex(x,y) = T[i,j]$  for a two-dimensional texture,-  $tex(x,y,z) = T[i,j,k]$  for a three-dimensional texture, where  $i = \\text{floor} (x), j = \\text{floor} (y)$ , and  $k = \\text{floor} (z)$ .\n\nFigure 18 illustrates nearest- point sampling for a one- dimensional texture with  $N = 4$ .\n\nFor integer textures, the value returned by the texture fetch can be optionally remapped to [0.0, 1.0] (see Texture Memory).\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/f10da300e5f6aedb999566a9aa9e9c634684b9c0fc77e84b885e522953fb5423.jpg)  \nFig. 1: Nearest-Point Sampling Filtering Mode"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "18.2. Linear Filtering - In this filtering mode which i...",
    "content": "In this filtering mode, which is only available for floating- point textures, the value returned by the texture fetch is $\\scriptstyle \\mathsf{t e x}(x) = (1 - \\sqcup)T[ij + \\sqcup T[i + 1]$  for a one- dimensional texture,  $\\scriptstyle \\mathsf{t e x}(x,y) = (1 - \\sqcup)(1 - \\sqcup)T[i,j + \\sqcup (1 - \\sqcup)T[i + 1,j] + (1 - \\sqcup)\\sqcup T[i,j + 1) + \\sqcup \\sqcup T[i + 1,j + 1]$  for a two- dimensional texture,  $\\scriptstyle \\mathsf{t e x}(x,y,z) =$ $(1 - \\sqcup)(1 - \\sqcup)(1 - \\sqcup)T[i,j,k] + \\sqcup (1 - \\sqcup)(1 - \\sqcup)T[i + 1,j,k]+$ $(1 - \\sqcup)(1 - \\sqcup)T[i,j + 1,k] + \\sqcup (1 - \\sqcup)T[i + 1,j + 1,k]+$ $(1 - \\sqcup)(1 - \\sqcup)T[i,j,k + 1] + (1 - \\sqcup)\\sqcup T[i + 1,j,k + 1]+$ $(1 - \\sqcup)\\sqcup T[i,j + 1,k + 1] + \\sqcup \\sqcup T[i + 1,j + 1,k + 1]$  for a three- d"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "18.2. Linear Filtering - imensional texture where",
    "content": "imensional texture, where:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "18.2. Linear Filtering - scriptstyle mathsfb   floorxB ......Fig 2 Linear Filtering Mode",
    "content": "$\\scriptstyle \\mathsf{b} =$  floorxB,  $\\sqsupseteq =$  fracxB)  $xB = x - 0.5$ $\\scriptstyle \\mathsf{b} =$  floor(yB),  $\\sqsupseteq =$  frac(yB),  $yB = y - 0.5$ $\\scriptstyle \\mathsf{b} =$  floor(zB),  $\\sqsupseteq =$  frac(zB),  $zB = z - 0.5$\n\n$\\sqsupseteq ,\\sqcup ,$  and  $\\sqsupseteq$  are stored in 9- bit fixed point format with 8 bits of fractional value (so 1.0 is exactly represented).\n\nFigure 19 illustrates linear filtering of a one- dimensional texture with  $N = 4$ .\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/952bf15f9b8168beab5f137289f999fb6386898dd1e8b0d318fbc7be68166713.jpg)  \nFig. 2: Linear Filtering Mode"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "CUDA C++ Programming Guide, Release 12.1 - A table lookup  TLx  where  x ......Fig 3 OneDimensional Table Loo...",
    "content": "# 18.3. Table Lookup\nA table lookup  $TL(x)$  where  $x$  spans the interval  $[0, R]$  can be implemented as  $TL(x) = \\text{ten} ((N - 1) / R)x + 0.5$  in order to ensure that  $TL(0) = T[0]$  and  $TL(R) = T[N - 1]$ .\n\nFigure 20 illustrates the use of texture filtering to implement a table lookup with  $R = 4$  or  $R = 1$  from a one- dimensional texture with  $N = 4$ .\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/d0c5228ba35af111b40aa356797f8cd12133622c2234661237fbfe962c9b7410.jpg)  \nFig. 3: One-Dimensional Table Lookup Using Linear Filtering\n\n# CUDA C++ Programming Guide, Release 12.1\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 19. Compute Capabilities - The general specifications and......Sections Compute Capability 5 ...",
    "content": "# Chapter 19. Compute Capabilities\nThe general specifications and features of a compute device depend on its compute capability (see Compute Capability).\n\nTable 14 and Table 15 show the features and technical specifications associated with each compute capability that is currently supported.\n\nFloating- Point Standard reviews the compliance with the IEEE floating- point standard.\n\nSections Compute Capability 5. x, Compute Capability 6. x, Compute Capability 7. x, Compute Capability 8. x and Compute Capability 9.0 give more details on the architecture of devices of compute capabilities 5. x, 6. x, 7. x, 8. x and 9.0 respectively."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.1. Feature Availability - A compute feature is introduce......There are potentially two sets...",
    "content": "A compute feature is introduced with a compute architecture with the intention that the feature will be available on all subsequent architectures. This is shown in Table 14 by the \"yes\" for availability of a feature on compute capabilities subsequent to its introduction.\n\nHighly specialized compute features that are introduced with an architecture may not be guaranteed to be available on all subsequent compute capabilities. These features target acceleration of specialized operations which are not intended for all classes of compute capabilities (denoted by the compute capability's minor number) or are likely to significantly change on future generations (denoted by the compute capability's major number).\n\nThere are potentially two sets of compute features for a given compute capability:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.1. Feature Availability - Compute Capability  The predom......Compilation of device code tar...",
    "content": "Compute Capability #.#: The predominant set of compute features that are introduced with the intent to be available for subsequent compute architectures. These features and their availability are summarized in Table 14.\n\nCompute Capability #.#a: A small and highly specialized set of features that are introduced to accelerate specialized operations, which are not guaranteed to be available or might change significantly on subsequent compute architecture. These features are summarized in the respective \"Compute Capability #.#\" subsection.\n\nCompilation of device code targets a particular compute capability. A feature which appears in device code must be available for the targeted compute capability. For example:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.1. Feature Availability - The compute90 compilation targ...",
    "content": "- The compute_90 compilation target allows use of Compute Capability 9.0 features but does not allow use of Compute Capability 9.0a features.- The compute_90a compilation target allows use of the complete set of compute device features, both 9.0a features and 9.0 features."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "CUDA C++ Programming Guide, Release 12.1",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - Table 1 Table 14 Feature Suppo...",
    "content": "Table 1: Table 14. Feature Support per Compute Capability"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - tabletrtdFeature Supporttdtd c...",
    "content": "<table><tr><td>Feature Support</td><td colspan=\"6\">Compute Capability</td></tr><tr><td>(Unlisted features are supported for all compute capabilities)</td><td>5.0, 5.2</td><td>5.3</td><td>6.x</td><td>7.x</td><td>8.x</td><td>9."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - 0tdtrtrtdAtomic functions oper...",
    "content": "0</td></tr><tr><td>Atomic functions operating on 32-bit integer values in global memory (Atomic Functions)</td><td colspan=\"6\">Yes</td></tr><tr><td>Atomic functions operating on 32-bit integer values in shared memory (Atomic Functions)</td><td colspan=\"6\">Yes</td></tr><tr><td>Atomic functions operating on 64-bit integer values in global memory (Atomic Functions)</td><td colspan=\"6\">Yes</td></tr><tr><td>Atomic functions operating on 64-bit integer values in shared memory (Atomic Functions)</td><td colspan=\"6\">Yes</td></tr><tr><td>Atomic addition operating on 32-bit floating point values in global and shared memory (atomicAdd())</td><td colspan=\"6\">Yes</td></tr><tr><td>Atomic addition operating on 64-bit floating point values in global memory and shared memory (atomicAdd())</td><td colspan=\""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - 2Notdtd colspan4YestdtrtrtdAto...",
    "content": "2\">No</td><td colspan=\"4\">Yes</td></tr><tr><td>Atomic addition operating on float2 and float4 floating point vec-tors in global memory (atomicAdd())</td><td colspan=\"4\">No</td><td colspan=\"2\">Yes</td></tr><tr><td>Warp vote functions (Warp Vote Functions)</td><td colspan=\"6\">Yes</td></tr><tr><td>Memory fence functions (Memory Fence Functions)</td><td colspan=\"6\">Yes</td></tr><tr><td>Synchronization functions (Synchronization Functions)</td><td colspan=\"6\">Yes</td></tr><tr><td>Surface functions (Surface Functions)</td><td colspan=\"6\">Yes</td></tr><tr><td>Unified Memory Programming (Unified Memory Programming)</td><td colspan=\"6\">Yes</td></tr><tr><td>Dynamic Parallelism (CUDA Dynamic Parallelism)</td><td colspan=\"6\">Yes</td></tr><tr><td>Half-precision floating-point operations: addition, subt"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - raction multiplication compari...",
    "content": "raction, multiplication, comparison, warp shuffle functions, conversion</td><td>No</td><td colspan=\"5\">Yes</td></tr><tr><td>Bfloat16-precision floating-point operations: addition, subtrac-tion, multiplication, comparison, warp shuffle functions, conver-sion</td><td colspan=\"3\">No</td><td colspan=\"3\">Yes</td></tr><tr><td>Tensor Cores</td><td colspan=\"2\">No</td><td colspan=\"4\">Yes</td></tr><tr><td>Mixed Precision Warp-Matrix Functions (Warp matrix functions)</td><td colspan=\"2\">No</td><td colspan=\"4\">Yes</td></tr><tr><td>Hardware-accelerated memcpy_async (Asynchronous Data Copies using cuda:pipeline)</td><td colspan=\"4\">No</td><td colspan=\"2\">Yes</td></tr><tr><td>Hardware-accelerated Split Arrive/Wait Barrier (Asynchronous Barrier)</td><td colspan=\"4\">No</td><td colspan=\"2\">Yes</td></tr><tr>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - tdL2 Cache Residency Managemen...",
    "content": "<td>L2 Cache Residency Management (Device Memory L2 Access Management)</td><td colspan=\"4\">No</td><td colspan=\"2\">Yes</td></tr><tr><td>DPX Instructions for Accelerated Dynamic Programming</td><td colspan=\"4\">No</td><td colspan=\"2\">Yes</td></tr><tr><td>Distributed Shared Memory</td><td colspan=\"4\">No</td><td colspan=\"2\">Yes</td></tr><tr><td>19."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - 2 Features and Technical Speci...",
    "content": "2 Features and Technical Specifications</td><td colspan=\"4\">No</td><td colspan=\"2\">Yes</td></tr><tr><td>Tensor Memory Accelerator (TMA) unit</td><td colspan=\"4\">No</td><td colspan=\"2\">Yes</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - Table 2 Table 15 Technical Spe...",
    "content": "Note that the KB and K units used in the following table correspond to 1024 bytes (i.e., a KiB) and 1024 respectively.\n\nTable 2: Table 15. Technical Specifications per Compute Capability"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - tabletrtdtdtd colspan14Compute...",
    "content": "<table><tr><td></td><td colspan=\"14\">Compute Capability</td></tr><tr><td>Technical Specifications</td><td>5.0</td><td>5.2</td><td>5.3</td><td>6.0</td><td>6.1</td><td>6.2</td><td>7.0</td><td>7.2</td><td>7.5</td><td>8.0</td><td>8.6</td><td>8.7</td><td>8.9</td><td>9."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - 0tdtrtrtdMaximum number of res...",
    "content": "0</td></tr><tr><td>Maximum number of resident grids per device (Concurrent Kernel Execution)</td><td>32</td><td></td><td>16</td><td>128</td><td>32</td><td>16</td><td>128</td><td>16</td><td>128</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Maximum dimensionality of grid of thread blocks</td><td>3</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Maximum x -dimension of a grid of thread blocks</td><td>231 - 1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Maximum y- or z-dimension of a grid of thread blocks</td><td>65535</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - tdtdtdtdtdtdtdtrtrtdMaximum di...",
    "content": "></td><td></td><td></td><td></td></tr><tr><td>Maximum dimensionality of thread block</td><td>3</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Maximum x- or y-dimensionality of a block</td><td>1024</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Maximum z-dimension of a block</td><td>64</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Maximum number of threads per block</td><td>1024</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Warp size</td><td>32</t"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - dtdtdtdtdtdtdtdtdtdtdtdtdtdtdt...",
    "content": "d><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Maximum number of resident blocks per SM</td><td>32</td><td></td><td></td><td></td><td></td><td></td><td>16</td><td>32</td><td>16</td><td></td><td>24</td><td>32</td><td></td><td></td></tr><tr><td>Maximum number of resident warps per SM</td><td>64</td><td></td><td></td><td></td><td></td><td></td><td>32</td><td>64</td><td>48</td><td></td><td></td><td>64</td><td></td><td></td></tr><tr><td>Maximum number of resident threads per SM</td><td>2048</td><td></td><td></td><td></td><td></td><td></td><td>102</td><td>420</td><td>48</td><td>536</td><td></td><td>2048</td><td></td><td></td></tr><tr><td>Number of 32-bit registers per SM</td><td>64 K</td><td></td><td></td><td></"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - tdtdtdtdtdtdtdtdtdtdtdtdtdtdtd...",
    "content": "td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Maximum number of 32-bit reg-isters per thread block</td><td>64 K</td><td>32 K</td><td>64 K</td><td>32 K</td><td>64 K</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Maximum number of 32-bit reg-isters per thread</td><td>255</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Maximum amount of shared memory per SM</td><td>64 KB</td><td>96 KB</td><td>64 KB</td><td>96 KB</td><td>64 KB</td><td>96 KB</td><td>64 KB</td><td>164 KB</td><td>100 KB</td><td>164 KB</td><td>100 KB</td><td>228 KB</td><td></td><td></td></tr><tr><td>Maximum amount of shared memory per th"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - read blocktdtd48 KBtdtdtdtdtdt...",
    "content": "read block</td><td>48 KB</td><td></td><td></td><td></td><td></td><td>96 KB</td><td>96 KB</td><td>64 KB</td><td>163 KB</td><td>99 KB</td><td>163 KB</td><td>99 KB</td><td>227 KB</td><td></td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - continues on next page...Table 2continued from previous...",
    "content": "continues on next page\n\nTable 2-continued from previous page"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - tabletrtdtdtd colspan10Compute...",
    "content": "<table><tr><td></td><td colspan=\"10\">Compute Capability</td></tr><tr><td>Number of shared memory banks</td><td colspan=\"10\">32</td></tr><tr><td>Maximum amount of local mem-ory per thread</td><td colspan=\"10\">512 KB</td></tr><tr><td>Constant memory size</td><td colspan=\"10\">64 KB</td></tr><tr><td>Cache working set per SM for constant memory</td><td>8 KB</td><td>4 KB</td><td colspan=\"8\">8 KB</td></tr><tr><td>Cache working set per SM for texture memory</td><td>Between 12 KB and 48 KB</td><td>Between 12 KB and 48 KB</td><td>Between 24 KB and 48 KB</td><td>32 ~ 128 KB</td><td>32 or 64 KB</td><td>28 KB ~ 192 KB</td><td>28 KB ~ 128 KB</td><td>28 KB ~ 192 KB</td><td>28 KB ~ 128 KB</td><td>28 KB ~ 256 KB</td></tr><tr><td>Maximum width for a 1D texture reference bound to a CUDA array</td><td>65536</"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - tdtd colspan9131072tdtrtrtdMax...",
    "content": "td><td colspan=\"9\">131072</td></tr><tr><td>Maximum width for a 1D texture reference bound to linear mem-ory</td><td>227</td><td>228</td><td>227</td><td>228</td><td>227</td><td colspan=\"5\">228</td></tr><tr><td>Maximum width and number of layers for a 1D layered texture reference</td><td>16384 x 2048</td><td colspan=\"9\">32768 x 2048</td></tr><tr><td>Maximum width and height for a 2D texture reference bound to a CUDA array</td><td>65536 x 65536</td><td colspan=\"9\">131072 x 65536</td></tr><tr><td>Maximum width and height for a 2D texture reference bound to linear memory</td><td>65536 x 65536</td><td colspan=\"9\">131072 x 65000</td></tr><tr><td>Maximum width and height for a 2D texture reference bound to a CUDA array supporting texture gather</td><td>16384 x 16384</td><td colspan=\"9\">32768 x 327"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - 68tdtrtrtdMaximum width height...",
    "content": "68</td></tr><tr><td>Maximum width, height, and number of layers for a 2D layered texture reference</td><td>16384 x 16384 x 2048</td><td colspan=\"9\">32768 x 32768 x 2048</td></tr><tr><td>Maximum width, height, and depth for a 3D texture reference bound to a CUDA array</td><td>4096 x 4096 x 4096</td><td colspan=\"9\">16384 x 16384 x 16384</td></tr><tr><td>Maximum width (and height) for a cubemap texture reference</td><td>16384</td><td colspan=\"9\">32768</td></tr><tr><td>Maximum width (and height) and number of layers for a cubemap layered texture reference</td><td>16384 x 2046</td><td colspan=\"9\">32768 x 2046</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - continues on next page...Table 2continued from previous...",
    "content": "continues on next page\n\nTable 2-continued from previous page"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - tabletrtdtdtd colspan3Compute ...",
    "content": "<table><tr><td></td><td colspan=\"3\">Compute Capability</td></tr><tr><td>Maximum number of textures that can be bound to a kernel</td><td colspan=\"3\">256</td></tr><tr><td>Maximum width for a 1D surface reference bound to a CUDA array</td><td>16384</td><td colspan=\"2\">32768</td></tr><tr><td>Maximum width and number of layers for a 1D layered surface reference</td><td>16384 x 2048</td><td colspan=\"2\">32768 x 2048</td></tr><tr><td>Maximum width and height for a 2D surface reference bound to a CUDA array</td><td>65536 x 65536</td><td colspan=\"2\">1 31072 x 65536</td></tr><tr><td>Maximum width, height, and number of layers for a 2D layered surface reference</td><td>16384 x 16384 x 2048</td><td colspan=\"2\">32768 x 32768 x 1048</td></tr><tr><td>Maximum width, height, and depth for a 3D surface refe"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.2. Features and Technical Specifications - rence bound to a CUDA arraytdt...",
    "content": "rence bound to a CUDA array</td><td>4096 x 4096 x 4096</td><td colspan=\"2\">16384 x 16384 x 16384</td></tr><tr><td>Maximum width (and height) for a cubemap surface reference bound to a CUDA array</td><td>16384</td><td colspan=\"2\">32768</td></tr><tr><td>Maximum width (and height) and number of layers for a cubemap layered surface reference</td><td>16384 x 2046</td><td colspan=\"2\">32768 x 2046</td></tr><tr><td>Maximum number of surfaces that can be bound to a kernel</td><td colspan=\"2\">16</td><td>32</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.3. Floating-Point Standard - All compute devices follow the...",
    "content": "All compute devices follow the IEEE 754- 2008 standard for binary floating- point arithmetic with the following deviations:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.3. Floating-Point Standard - There is no dynamically config...",
    "content": "There is no dynamically configurable rounding mode; however, most of the operations support multiple IEEE rounding modes, exposed via device intrinsics. There is no mechanism for detecting that a floating- point exception has occurred and all operations behave as if the IEEE- 754 exceptions are always masked, and deliver the masked response as defined by IEEE- 754 if there is an exceptional event. For the same reason, while SNaN encodings are supported, they are not signaling and are handled as quiet. The result of a single- precision floating- point operation involving one or more input NaNs is the quiet NaN of bit pattern 0x7fffffff. Double- precision floating- point absolute value and negation are not compliant with IEEE- 754 with respect to NaNs; these are passed through unchanged."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.3. Floating-Point Standard - Code must be compiled with  ft......In accordance to the IEEE 754R...",
    "content": "Code must be compiled with - ftz=false, - prec- div=true, and - prec- sqrt=true to ensure IEEE compliance (this is the default setting; see the nvcc user manual for description of these compilation flags).\n\nRegardless of the setting of the compiler flag - ftz, - atomic single-precision floating-point adds on global memory always operate in flush-to-zero mode, i.e., behave equivalent to FADD.F32.FTZ.RN,  \n- atomic single-precision floating-point adds on shared memory always operate with denormal support, i.e., behave equivalent to FADD.F32.RN.\n\nIn accordance to the IEEE- 754R standard, if one of the input parameters to fminf(), fminf(), fmaxf(), or fmaxf() is NaN, but not the other, the result is the non- NaN parameter."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.3. Floating-Point Standard - The conversion of a floating p......httpsdevelopernvidiacomcontent...",
    "content": "The conversion of a floating- point value to an integer value in the case where the floating- point value falls outside the range of the integer format is left undefined by IEEE- 754. For compute devices, the behavior is to clamp to the end of the supported range. This is unlike the x86 architecture behavior.\n\nThe behavior of integer division by zero and integer overflow is left undefined by IEEE- 754. For compute devices, there is no mechanism for detecting that such integer operation exceptions have occurred. Integer division by zero yields an unspecified, machine- specific value.\n\nhttps://developer.nvidia.com/content/precision- performance- floating- point- and- ieee- 754- compliance- nvidia- gpus includes more information on the floating point accuracy and compliance of NVIDIA GPUs."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.4. Compute Capability 5.x",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.4.1. Architecture - An SM consists of...An SM has",
    "content": "An SM consists of:\n\n- 128 CUDA cores for arithmetic operations (see Arithmetic Instructions for throughputs of arithmetic operations),  \n- 32 special function units for single-precision floating-point transcendental functions,  \n- 4 warp schedulers.\n\nWhen an SM is given warps to execute, it first distributes them among the four schedulers. Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.\n\nAn SM has:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.4.1. Architecture - The unified L1texture cache is......There is also an L2 cache shar...",
    "content": "- a read-only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory,  \n- a unified L1/texture cache of 24 KB used to cache reads from global memory,  \n- 64 KB of shared memory for devices of compute capability 5.0 or 96 KB of shared memory for devices of compute capability 5.2.\n\nThe unified L1/texture cache is also used by the texture unit that implements the various addressing modes and data filtering mentioned in Texture and Surface Memory.\n\nThere is also an L2 cache shared by all SMs that is used to cache accesses to local or global memory, including temporary register spills. Applications may query the L2 cache size by checking the 12CacheSize device property (see Device Enumeration)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.4.1. Architecture - The cache behavior eg whether ...",
    "content": "The cache behavior (e.g., whether reads are cached in both the unified L1/texture cache and L2 or in L2 only) can be partially configured on a per- access basis using modifiers to the load instruction."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.4.2. Global Memory - Global memory accesses are alw......Data that is read only for the...",
    "content": "Global memory accesses are always cached in L2.\n\nData that is read- only for the entire lifetime of the kernel can also be cached in the unified L1/texture cache described in the previous section by reading it using the __ldg() function (see Read- Only Data Cache Load Function). When the compiler detects that the read- only condition is satisfied for some data, it will use __ldg() to read it. The compiler might not always be able to detect that the read- only condition is satisfied for some data. Marking pointers used for loading such data with both the const and __restrict__ qualifiers increases the likelihood that the compiler will detect the read- only condition."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.4.2. Global Memory - Data that is not read only for......fscmca compilation flag in whi...",
    "content": "Data that is not read- only for the entire lifetime of the kernel cannot be cached in the unified L1/texture cache for devices of compute capability 5.0. For devices of compute capability 5.2, it is, by default, not cached in the unified L1/texture cache, but caching may be enabled using the following mechanisms:\n\n- Perform the read using inline assembly with the appropriate modifier as described in the PTX reference manual;- Compile with the \n-Xptxas \n-dlcm=ca compilation flag, in which case all reads are cached, except reads that are performed using inline assembly with a modifier that disables caching;- Compile with the \n-Xptxas \n-fscm=ca compilation flag, in which case all reads are cached, including reads that are performed using inline assembly regardless of the modifier used."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.4.2. Global Memory - When caching is enabled using ...",
    "content": "When caching is enabled using one of the three mechanisms listed above, devices of compute capability 5.2 will cache global memory reads in the unified L1/texture cache for all kernel launches except for the kernel launches for which thread blocks consume too much of the SM's register file. These exceptions are reported by the profiler."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.4.3. Shared Memory - Shared memory has 32 banks tha......Figure 23 shows some examples ...",
    "content": "Shared memory has 32 banks that are organized such that successive 32- bit words map to successive banks. Each bank has a bandwidth of 32 bits per clock cycle.\n\nA shared memory request for a warp does not generate a bank conflict between two threads that access any address within the same 32- bit word (even though the two addresses fall in the same bank). In that case, for read accesses, the word is broadcast to the requesting threads and for write accesses, each address is written by only one of the threads (which thread performs the write is undefined).\n\nFigure 22 shows some examples of strided access.\n\nFigure 23 shows some examples of memory read accesses that involve the broadcast mechanism."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.4.3. Shared Memory - httpscdnmineruopenxlaborgcnres......Fig 2 Irregular Shared Memory ...",
    "content": "![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/30b1b39d858a3339cf62727b79f277bfa74e00e9f1584c9a38682265546590e9.jpg)  \nFig. 1: Strided Shared Memory Accesses in 32 bit bank size mode.Left Linear addressing with a stride of one 32-bit word (no bank conflict).Middle Linear addressing with a stride of two 32-bit words (two-way bank conflict).Right Linear addressing with a stride of three 32-bit words (no bank conflict).\n\n![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/64d7fdd289f1f5116e9042cdf6bffc54f513a8d287a0f2e49236d63bc6347c52.jpg)  \nFig. 2: Irregular Shared Memory Accesses."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.4.3. Shared Memory - Left Conflict free access via ...",
    "content": "Left Conflict- free access via random permutation.  Middle Conflict- free access since threads 3, 4, 6, 7, and 9 access the same word within bank 5.  Right Conflict- free broadcast access (threads access the same word within a bank)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.5. Compute Capability 6.x",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.5.1. Architecture - An SM consists of...An SM has",
    "content": "An SM consists of:\n\n64 (compute capability 6.0) or 128 (6.1 and 6.2) CUDA cores for arithmetic operations, 16 (6.0) or 32 (6.1 and 6.2) special function units for single- precision floating- point transcendental function6, 2 (6.0) or 4 (6.1 and 6.2) warp schedulers.\n\nWhen an SM is given warps to execute, it first distributes them among its schedulers. Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.\n\nAn SM has:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.5.1. Architecture - a read only constant cache tha......There is also an L2 cache shar...",
    "content": "a read- only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory, a unified L1/texture cache for reads from global memory of size 24 KB (6.0 and 6.2) or 48 KB (6.1), a shared memory of size 64 KB (6.0 and 6.2) or 96 KB (6.1).\n\nThe unified L1/texture cache is also used by the texture unit that implements the various addressing modes and data filtering mentioned in Texture and Surface Memory.\n\nThere is also an L2 cache shared by all SMs that is used to cache accesses to local or global memory, including temporary register spills. Applications may query the L2 cache size by checking the 12CacheSize device property (see Device Enumeration)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.5.1. Architecture - The cache behavior eg whether ...",
    "content": "The cache behavior (e.g., whether reads are cached in both the unified L1/texture cache and L2 or in L2 only) can be partially configured on a per- access basis using modifiers to the load instruction."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.6. Compute Capability 7.x - 1952 Global MemoryGlobal memor......Shared memory behaves the same...",
    "content": "19.5.2. Global MemoryGlobal memory behaves the same way as in devices of compute capability 5. x (See Global Memory).\n\n# 19.5.3. Shared Memory\nShared memory behaves the same way as in devices of compute capability 5. x (See Shared Memory).\n\n# 19.6. Compute Capability 7.x\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.6.1. Architecture - An SM consists of...An SM has",
    "content": "An SM consists of:\n\n64 FP32 cores for single- precision arithmetic operations, 32 FP64 cores for double- precision arithmetic operations,35 64 INT32 cores for integer math, 8 mixed- precision Tensor Cores for deep learning matrix arithmetic 16 special function units for single- precision floating- point transcendental functions, 4 warp schedulers.\n\nAn SM statically distributes its warps among its schedulers. Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.\n\nAn SM has:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.6.1. Architecture - a read only constant cache tha......Shared memory is partitioned o...",
    "content": "a read- only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory, a unified data cache and shared memory with a total size of 128 KB (Volta) or 96 KB (Turing).\n\nShared memory is partitioned out of unified data cache, and can be configured to various sizes (See Shared Memory.) The remaining data cache serves as an L1 cache and is also used by the texture unit that implements the various addressing and data filtering modes mentioned in Texture and Surface Memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.6.2. Independent Thread Scheduling - The Volta architecture introdu......Below are code patterns of con...",
    "content": "The Volta architecture introduces Independent Thread Scheduling among threads in a warp, enabling intra- warp synchronization patterns previously unavailable and simplifying code changes when porting CPU code. However, this can lead to a rather different set of threads participating in the executed code than intended if the developer made assumptions about warp- synchronicity of previous hardware architectures.\n\nBelow are code patterns of concern and suggested corrective actions for Volta- safe code."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.6.2. Independent Thread Scheduling - 1 For applications using warp ......if definedCUDARTVERSION  CUDAR...",
    "content": "1. For applications using warp intrinsics (__shfl\\*, _any, _all, __ballot), it is necessary that developers port their code to the new, safe, synchronizing counterpart, with the \\*_sync suffix. The new warp intrinsics take in a mask of threads that explicitly define which lanes (threads of a warp) must participate in the warp intrinsic. See Warp Vote Functions and Warp Shuffle Functions for details.\n\nSince the intrinsics are available with CUDA 9.0+, (if necessary) code can be executed conditionally with the following preprocessor macro:\n\nif defined(CUDART_VERSION) && CUDART_VERSION >= 9000 // \\*_sync intrinsic #endif"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.6.2. Independent Thread Scheduling - These intrinsics are available......if tid  warpSize  16     float...",
    "content": "These intrinsics are available on all architectures, not just Volta or Turing, and in most cases a single code- base will suffice for all architectures. Note, however, that for Pascal and earlier architectures, all threads in mask must execute the same warp intrinsic instruction in convergence, and the union of all values in mask must be equal to the warp's active mask. The following code pattern is valid on Volta, but not on Pascal or earlier architectures.\n\nif (tid % warpSize < 16) {    float swapped = __shfl_xor_sync(0xffffffff, val, 16);} else {    float swapped = __shfl_xor_sync(0xffffffff, val, 16);}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.6.2. Independent Thread Scheduling - The replacement for ballot1 is......Sets bit in output to 1 if the...",
    "content": "The replacement for __ballot(1) is __activemask(). Note that threads within a warp can diverge even within a single code path. As a result, __activemask() and __ballot(1) may return only a subset of the threads on the current code path. The following invalid code example sets bit i of output to 1 when data[i] is greater than threshold. __activemask() is used in an attempt to enable cases where dataLen is not a multiple of 32.\n\n// Sets bit in output[] to 1 if the correspond element in data[i] // is greater than 'threshold', using 32 threads in a warp. for (int i = warpLane; i < dataLen; i += warpSize) {    unsigned active = __activemask();    unsigned bitPack = __ballot_sync(active, data[i] > threshold);    if (warpLane == 0) {        output[i / 32] = bitPack;    }}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.6.2. Independent Thread Scheduling - This code is invalid because C......for int i  warpLane i  warpLan...",
    "content": "This code is invalid because CUDA does not guarantee that the warp will diverge ONLY at the loop condition. When divergence happens for other reasons, conflicting results will be computed for the same 32- bit output element by different subsets of threads in the warp. A correct code might use a non- divergent loop condition together with __ballot_sync() to safely enumerate the set of threads in the warp participating in the threshold calculation as follows.\n\nfor (int i = warpLane; i - warpLane < dataLen; i += warpSize) {    unsigned active = __ballot_sync(0xffffffff, i < dataLen);    if (i < dataLen) {        unsigned bitPack = __ballot_sync(active, data[i] > threshold);        if (warpLane == 0) {            output[i / 32] = bitPack;        }    }}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.6.2. Independent Thread Scheduling - Discovery Pattern demonstrates......1 If applications have warpsyn...",
    "content": "Discovery Pattern demonstrates a valid use case for __activemask().\n\n1. If applications have warp-synchronous codes, they will need to insert the new __sync warp() warp-wide barrier synchronization instruction between any steps where data is exchanged between threads via global or shared memory. Assumptions that code is executed in lockstep or that reads/writes from separate threads are visible across a warp without synchronization are invalid."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.6.2. Independent Thread Scheduling - shared float sbuffBLOCKSIZE sb...",
    "content": "__shared__ float s_buff[BLOCK_SIZE]; s_buff[tid]  $=$  val; __syncthreads(); // Inter- warp reduction for (int  $\\mathrm{\\bf i} =$  BLOCK_SIZE / 2; i  $> = 32$  ; i  $f = 2$  ){ if (tid  $= \\dot{\\mathbf{1}}$  ){ s_buff[tid]  $+ =$  s_buff[tid  $+\\dot{1}$  }; } __syncthreads(); } // Intra- warp reduction // Butterfly reduction simplifies syncwarp mask if (tid  $< 32$  ){ float temp; temp  $=$  s_buff[tid ^ 16]; __syncwarp(); s_buff[tid]  $+ =$  temp; __syncwarp(); temp  $=$  s_buff[tid ^ 8]; __syncwarp(); s_buff[tid]  $+ =$  temp; __syncwarp(); temp  $=$  s_buff[tid ^ 4]; __syncwarp(); s_buff[tid]  $+ =$  temp; __syncwarp(); temp  $=$  s_buff[tid ^ 2]; __syncwarp(); s_buff[tid]  $+ =$  temp; __syncwarp(); } if (tid  $= = 0$  ){ *output  $=$  s_buff[0]  $^+$  s_buff[1]; } __syncthreads();"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.6.2. Independent Thread Scheduling - 2 Although syncthreads has bee...",
    "content": "2. Although __syncthreads() has been consistently documented as synchronizing all threads in the thread block, Pascal and prior architectures could only enforce synchronization at the warp level. In certain cases, this allowed a barrier to succeed without being executed by every thread as long as at least some thread in every warp reached the barrier. Starting with Volta, the CUDA built-in __syncthreads() and PTX instruction bar.sync (and their derivatives) are enforced per thread and thus will not succeed until reached by all non-exited threads in the block. Code exploiting the previous behavior will likely deadlock and must be modified to ensure that all non-exited threads reach the barrier."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.6.2. Independent Thread Scheduling - The racecheck and synccheck to......To aid migration while impleme...",
    "content": "The racecheck and synccheck tools provided by compute- saniter can help with locating violations.\n\nTo aid migration while implementing the above- mentioned corrective actions, developers can opt- in to the Pascal scheduling model that does not support independent thread scheduling. See Application Compatibility for details."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.6.3. Global Memory - 1963 Global MemoryGlobal memor...",
    "content": "19.6.3. Global MemoryGlobal memory behaves the same way as in devices of compute capability 5. x (See Global Memory)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.6.4. Shared Memory - The amount of the unified data...",
    "content": "The amount of the unified data cache reserved for shared memory is configurable on a per kernel basis. For the Volta architecture (compute capability 7.0), the unified data cache has a size of 128 KB, and the shared memory capacity can be set to 0, 8, 16, 32, 64 or 96 KB. For the Turing architecture (compute capability 7.5), the unified data cache has a size of 96 KB, and the shared memory capacity can be set to either 32 KB or 64 KB. Unlike Kepler, the driver automatically configures the shared memory capacity for each kernel to avoid shared memory occupancy bottlenecks while also allowing concurrent execution with already launched kernels where possible. In most cases, the driver's default behavior should provide optimal performance."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.6.4. Shared Memory - Because the driver is not alwa...",
    "content": "Because the driver is not always aware of the full workload, it is sometimes useful for applications to provide additional hints regarding the desired shared memory configuration. For example, a kernel with little or no shared memory use may request a larger carveout in order to encourage concurrent execution with later kernels that require more shared memory. The new cudaFuncSetAttribute() API allows applications to set a preferred shared memory capacity, or carveout, as a percentage of the maximum supported shared memory capacity (96 KB for Volta, and 64 KB for Turing)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.6.4. Shared Memory - cudaFuncSetAttribute relaxes e...",
    "content": "cudaFuncSetAttribute() relaxes enforcement of the preferred shared capacity compared to the legacy cudaFuncSetCacheConfig() API introduced with Kepler. The legacy API treated shared memory capacities as hard requirements for kernel launch. As a result, interleaving kernels with different shared memory configurations would needlessly serialize launches behind shared memory reconfigurations. With the new API, the carveout is treated as a hint. The driver may choose a different configuration if required to execute the function or to avoid thrashing."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.6.4. Shared Memory - Device code    global void MyK...",
    "content": "// Device code  - - global__ void MyKernel(...)  {      - - shared__ float buffer[BLOCK_DIM];      ...  }  // Host code  int carveout = 50; // prefer shared memory capacity 50% of maximum  // Named Carveout Values:  // carveout = cudaSharedmemCarveoutDefault; // (- 1)  // carveout = cudaSharedmemCarveoutMaxL1; // (0)  // carveout = cudaSharedmemCarveoutMaxShared; // (100)  cudaFuncSetAttribute(MyKernel, cudaFuncAttributePreferredSharedMemoryCarveout, - - carveout);  MyKernel << <gridDim, BLOCK_DIM>>>(...);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.6.4. Shared Memory - In addition to an integer perc......Compute capability 7 x devices...",
    "content": "In addition to an integer percentage, several convenience enums are provided as listed in the code comments above. Where a chosen integer percentage does not map exactly to a supported capacity (SM 7.0 devices support shared capacities of 0, 8, 16, 32, 64, or 96 KB), the next larger capacity is used. For instance, in the example above, 50% of the 96 KB maximum is 48 KB, which is not a supported shared memory capacity. Thus, the preference is rounded up to 64 KB.\n\nCompute capability 7. x devices allow a single thread block to address the full capacity of shared memory: 96 KB on Volta, 64 KB on Turing. Kernels relying on shared memory allocations over 48 KB per"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.6.4. Shared Memory - block are architecture specifi......Otherwise shared memory behave...",
    "content": "block are architecture- specific, as such they must use dynamic shared memory (rather than statically sized arrays) and require an explicit opt- in using cudaFuncSetAttribute() as follows.\n\n// Device code  - - global__ void MyKernel(...)  {      extern __shared__ float buffer[];      ...  }  // Host code  int maxbytes = 98304; // 96 KB  cudaFuncSetAttribute(MyKernel, cudaFuncAttributeMaxDynamicSharedMemorySize, maxbytes);  MyKernel << <gridDim, blockDim, maxbytes>>>(...);\n\nOtherwise, shared memory behaves the same way as for devices of compute capability 5. x (See Shared Memory)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.7. Compute Capability 8.x",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.7.1. Architecture - A Streaming Multiprocessor SM ...",
    "content": "A Streaming Multiprocessor (SM) consists of:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.7.1. Architecture - 64 FP32 cores for singleprecis...",
    "content": "- 64 FP32 cores for single-precision arithmetic operations in devices of compute capability 8.0 and 128 FP32 cores in devices of compute capability 8.6, 8.7 and 8.9,  - 32 FP64 cores for double-precision arithmetic operations in devices of compute capability 8.0 and 2 FP64 cores in devices of compute capability 8.6, 8.7 and 8.9  - 64 INT32 cores for integer math,  - 4 mixed-precision Third-Generation Tensor Cores supporting half-precision (fp16), __nv_bfloat16, tf32, sub-byte and double precision (fp64) matrix arithmetic for compute capabilities 8.0, 8.6 and 8.7 (see Warp matrix functions for details),  - 4 mixed-precision Fourth-Generation Tensor Cores supporting fp8, fp16, __nv_bfloat16, tf32, sub-byte and fp64 for compute capability 8.9 (see Warp matrix functions for details),  "
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.7.1. Architecture - 16 special function units for ...",
    "content": "- 16 special function units for single-precision floating-point transcendental functions,  - 4 warp schedulers."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.7.1. Architecture - An SM statically distributes i......Shared memory is partitioned o...",
    "content": "An SM statically distributes its warps among its schedulers. Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.\n\nAn SM has:\n\n- a read-only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory,  \n- a unified data cache and shared memory with a total size of 192 KB for devices of compute capability 8.0 and 8.7 (1.5x Volta's 128 KB capacity) and 128 KB for devices of compute capabilities 8.6 and 8.9.\n\nShared memory is partitioned out of the unified data cache, and can be configured to various sizes (see Shared Memory section). The remaining data cache serves as an L1 cache and is also used by the"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.7.1. Architecture - texture unit that implements t...",
    "content": "texture unit that implements the various addressing and data filtering modes mentioned in Texture and Surface Memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.7.2. Global Memory - Global memory behaves the same...",
    "content": "Global memory behaves the same way as for devices of compute capability 5. x (See Global Memory)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.7.3. Shared Memory - Similar to the Volta architect......cudaFuncSetAttributekernelname...",
    "content": "Similar to the Volta architecture, the amount of the unified data cache reserved for shared memory is configurable on a per kernel basis. For the NVIDIA Ampere GPU architecture, the unified data cache has a size of 192 KB for devices of compute capability 8.0 and 8.7 and 128 KB for devices of compute capabilities 8.6 and 8.9. The shared memory capacity can be set to 0, 8, 16, 32, 64, 100, 132 or 164 KB for devices of compute capability 8.0 and 8.7, and to 0, 8, 16, 32, 64 or 100 KB for devices of compute capabilities 8.6 and 8.9.\n\nAn application can set the carveout, i.e., the preferred shared memory capacity, with the cudaFuncSetAttribute().\n\ncudaFuncSetAttribute(kernel_name, cudaFuncAttributePreferredSharedMemoryCarveout,  $\\rightarrow$  carveout);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.7.3. Shared Memory - The API can specify the carveo...",
    "content": "The API can specify the carveout either as an integer percentage of the maximum supported shared memory capacity of 164 KB for devices of compute capability 8.0 and 8.7 and 100 KB for devices of compute capabilities 8.6 and 8.9 respectively, or as one of the following values: {cudaSharedmemCarveoutDefault, cudaSharedmemCarveoutMaxL1, or cudaSharedmemCarveoutMaxShared. When using a percentage, the carveout is rounded up to the nearest supported shared memory capacity. For example, for devices of compute capability 8.0,  $50\\%$  will map to a 100 KB carveout instead of an 82 KB one. Setting the cudaFuncAttributePreferredSharedMemoryCarveout is considered a hint by the driver, the driver may choose a different configuration, if needed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.7.3. Shared Memory - Devices of compute capability ......Note that the maximum amount o...",
    "content": "Devices of compute capability 8.0 and 8.7 allow a single thread block to address up to 163 KB of shared memory, while devices of compute capabilities 8.6 and 8.9 allow up to 99 KB of shared memory. Kernels relying on shared memory allocations over 48 KB per block are architecture- specific, and must use dynamic shared memory rather than statically sized shared memory arrays. These kernels require an explicit opt- in by using cudaFuncSetAttribute() to set the cudaFuncAttributeMaxDynamicSharedMemorySize, see Shared Memory for the Volta architecture.\n\nNote that the maximum amount of shared memory per thread block is smaller than the maximum shared memory partition available per SM. The 1 KB of shared memory not made available to a thread block is reserved for system use."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.8. Compute Capability 9.0",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.8.1. Architecture - A Streaming Multiprocessor SM ......128 FP32 cores for single prec...",
    "content": "A Streaming Multiprocessor (SM) consists of:\n\n128 FP32 cores for single- precision arithmetic operations, 64 FP64 cores for double- precision arithmetic operations, 64 INT32 cores for integer math, 4 mixed- precision fourth- generation Tensor Cores supporting the new FP8 input type in either E4M3 or E5M2 for exponent (E) and mantissa (M), half- precision (fp16), _nv_bfloat16, tf32, INT8 and double precision (fp64) matrix arithmetic (see Warp Matrix Functions for details) with sparsity support, 16 special function units for single- precision floating- point transcendental functions, 4 warp schedulers."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.8.1. Architecture - An SM statically distributes i......a read only constant cache tha...",
    "content": "An SM statically distributes its warps among its schedulers. Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.\n\nAn SM has:\n\na read- only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory, a unified data cache and shared memory with a total size of 256 KB for devices of compute capability 9.0 (1.33x NVIDIA Ampere GPU Architecture's 192 KB capacity)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.8.1. Architecture - Shared memory is partitioned o...",
    "content": "Shared memory is partitioned out of the unified data cache, and can be configured to various sizes (see Shared Memory section). The remaining data cache serves as an L1 cache and is also used by the texture unit that implements the various addressing and data filtering modes mentioned in Texture and Surface Memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.8.2. Global Memory - 1982 Global MemoryGlobal memor...",
    "content": "19.8.2. Global MemoryGlobal memory behaves the same way as for devices of compute capability 5. x (See Global Memory)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.8.3. Shared Memory - Similar to the NVIDIA Ampere G...",
    "content": "Similar to the NVIDIA Ampere GPU architecture, the amount of the unified data cache reserved for shared memory is configurable on a per kernel basis. For the NVIDIA H100 Tensor Core GPU architecture, the unified data cache has a size of 256 KB for devices of compute capability 9.0. The shared memory capacity can be set to 0, 8, 16, 32, 64, 100, 132, 164, 196 or 228 KB."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.8.3. Shared Memory - As with the NVIDIA Ampere GPU ......to set the cudaFuncAttributeMa...",
    "content": "As with the NVIDIA Ampere GPU architecture, an application can configure its preferred shared memory capacity, i.e., the carveout. Devices of compute capability 9.0 allow a single thread block to address up to 227 KB of shared memory. Kernels relying on shared memory allocations over 48 KB per block are architecture- specific, and must use dynamic shared memory rather than statically sized shared memory arrays. These kernels require an explicit opt- in by using cudaFuncSetAttribute()\n\nto set the cudaFuncAttributeMaxDynamicSharedMemorySize; see Shared Memory for the Volta architecture."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.8.3. Shared Memory - Note that the maximum amount o...",
    "content": "Note that the maximum amount of shared memory per thread block is smaller than the maximum shared memory partition available per SM. The 1 KB of shared memory not made available to a thread block is reserved for system use."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.8.4. Features Accelerating Specialized Computations - The NVIDIA Hopper GPU architec......It is strongly recommended tha...",
    "content": "The NVIDIA Hopper GPU architecture includes features to accelerate matrix multiply- accumulate (MMA) computations with:\n\nasynchronous execution of MMA instructions MMA instructions acting on large matrices spanning a warp- group dynamic reassignment of register capacity among warp- groups to support even larger matrices, and operand matrices accessed directly from shared memory\n\nThis feature set is only available within the CUDA compilation toolchain through inline PTX.\n\nIt is strongly recommended that applications utilize this complex feature set through CUDA- X libraries such as cuBLAS, cuDNN, or cuFFT."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "19.8.4. Features Accelerating Specialized Computations - It is strongly recommended tha...",
    "content": "It is strongly recommended that device kernels utilize this complex feature set through CUTLASS, a collection of CUDA C++ template abstractions for implementing high- performance matrix- multiplication (GEMM) and related computations at all levels and scales within CUDA."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "CUDA C++ Programming Guide, Release 12.1",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 20. Driver API - This section assumes knowledge......Table 1 Table 16 Objects Avail...",
    "content": "This section assumes knowledge of the concepts described in CUDA Runtime.\n\nThe driver API is implemented in the cuda dynamic library (cuda.d11 or cuda.so) which is copied on the system during the installation of the device driver. All its entry points are prefixed with cu.\n\nIt is a handle- based, imperative API: Most objects are referenced by opaque handles that may be specified to functions to manipulate the objects.\n\nThe objects available in the driver API are summarized in Table 16.\n\nTable 1: Table 16. Objects Available in the CUDA Driver API"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 20. Driver API - tabletrtdObjecttdtdHandletdtdD...",
    "content": "<table><tr><td>Object</td><td>Handle</td><td>Description</td></tr><tr><td>Device</td><td>Cude-vice</td><td>CUDA-enabled device</td></tr><tr><td>Context</td><td>Cucon-text</td><td>Roughly equivalent to a CPU process</td></tr><tr><td>Module</td><td>CU-module</td><td>Roughly equivalent to a dynamic library</td></tr><tr><td>Function</td><td>CU-func-tion</td><td>Kernel</td></tr><tr><td>Heap memory</td><td>Cude-viceptr</td><td>Pointer to device memory</td></tr><tr><td>CUDA array</td><td>Cuar-ray</td><td>Opaque container for one-dimensional or two-dimensional data on the de-vice, readable via texture or surface references</td></tr><tr><td>Texture reference</td><td>CU-texref</td><td>Object that describes how to interpret texture memory data</td></tr><tr><td>Surface reference</td><td>Cusurfref</td>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 20. Driver API - tdObject that describes how to...",
    "content": "<td>Object that describes how to read or write CUDA arrays</td></tr><tr><td>Stream</td><td>Cus-tream</td><td>Object that describes a CUDA stream</td></tr><tr><td>Event</td><td>Cuevent</td><td>Object that describes a CUDA event</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 20. Driver API - The driver API must be initial......Within a CUDA context kernels ...",
    "content": "The driver API must be initialized with cuInit() before any function from the driver API is called. A CUDA context must then be created that is attached to a specific device and made current to the calling host thread as detailed in Context.\n\nWithin a CUDA context, kernels are explicitly loaded as PTX or binary objects by the host code as described in Module. Kernels written in  $\\mathtt{C + + }$  must therefore be compiled separately into PTX or binary objects. Kernels are launched using API entry points as described in Kernel Execution."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 20. Driver API - Any application that wants to ......Here is the host code of the s...",
    "content": "Any application that wants to run on future device architectures must load PTX, not binary code. This is because binary code is architecture- specific and therefore incompatible with future architectures, whereas PTX code is compiled to binary code at load time by the device driver.\n\nHere is the host code of the sample from Kernels written using the driver API:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 20. Driver API - int main  int  textttN  ldots ...",
    "content": "int main() { int  $\\texttt{N} = \\ldots$  size_t size  $=$  N \\* sizeof(float); // Allocate input vectors h_A and h_B in host memory float\\* h_A  $=$  (float\\*)malloc(size); float\\* h_B  $=$  (float\\*)malloc(size); // Initialize input vectors // Initialize cuInit(0); // Get number of devices supporting CUDA int deviceCount  $= \\theta$  . cuDeviceGetCount  $=$  deviceCount); if (deviceCount  $= = 0$  ){ printf(\"There is no device supporting Cuda.\\n\"); exit (0); } // Get handle for device 0 CUdevice cuDevice; cuDeviceGet(&cuDevice, 0); // Create context CUcontext cuContext; cuCtxCreate(&cuContext, 0, cuDevice); // Create module from binary file CUmodule cuModule; cuModuleLoad(&cuModule, \"VecAdd."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 20. Driver API - ptx  Allocate vectors in devic...",
    "content": "ptx\"); // Allocate vectors in device memory CUdeviceptr d_A; cuMemAlloc(&d_A, size); CUdeviceptr d_B; cuMemAlloc(&d_B, size); CUdeviceptr d_C; cuMemAlloc(&d_C, size); // Copy vectors from host memory to device memory cuMemcpyHtcd(d_A, h_A, size); cuMemcpyHtcd(d_B, h_B, size); // Get function handle from module"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 20. Driver API - continued from previous page...Full code can be found in the ...",
    "content": "(continued from previous page)\n\nCUfunction vecAdd; cuModuleGetFunction(&vecAdd, cuModule, \"VecAdd\"); // Invoke kernel int threadsPerBlock = 256; int blocksPerGrid = (N + threadsPerBlock - 1) / threadsPerBlock; void* args[] = { &d_A, &d_B, &d_C, &N }; cuLaunchKernel(vecAdd, blocksPerGrid, 1, 1, threadsPerBlock, 1, 1, 0, 0, args, 0);\n\nFull code can be found in the vectorAddDrv CUDA sample."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.1. Context - A CUDA context is analogous to...",
    "content": "A CUDA context is analogous to a CPU process. All resources and actions performed within the driver API are encapsulated inside a CUDA context, and the system automatically cleans up these resources when the context is destroyed. Besides objects such as modules and texture or surface references, each context has its own distinct address space. As a result, CUdeviceptr values from different contexts reference different memory locations."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.1. Context - A host thread may have only on......Each host thread has a stack o...",
    "content": "A host thread may have only one device context current at a time. When a context is created with cuCtxCreate(), it is made current to the calling host thread. CUDA functions that operate in a context (most functions that do not involve device enumeration or context management) will return CUDA_ERROR_INVALID_CONTEXT if a valid context is not current to the thread.\n\nEach host thread has a stack of current contexts. cuCtxCreate() pushes the new context onto the top of the stack. cuCtxPopCurrent() may be called to detach the context from the host thread. The context is then \"floating\" and may be pushed as the current context for any host thread. cuCtxPopCurrent() also restores the previous current context, if any."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.1. Context - A usage count is also maintain......The driver API is interoperabl...",
    "content": "A usage count is also maintained for each context. cuCtxCreate() creates a context with a usage count of 1. cuCtxAttach() increments the usage count and cuCtxDetach() decrements it. A context is destroyed when the usage count goes to 0 when calling cuCtxDetach() or cuCtxDestroy().\n\nThe driver API is interoperable with the runtime and it is possible to access the primary context (see Initialization) managed by the runtime from the driver API via cuDevicePrimaryCtxRetain()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.1. Context - Usage count facilitates intero...",
    "content": "Usage count facilitates interoperability between third party authored code operating in the same context. For example, if three libraries are loaded to use the same context, each library would call cuCtxAttach() to increment the usage count and cuCtxDetach() to decrement the usage count when the library is done using the context. For most libraries, it is expected that the application will have created a context before loading or initializing the library; that way, the application can create the context using its own heuristics, and the library simply operates on the context handed to it."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.1. Context - Libraries that wish to create ...",
    "content": " Libraries that wish to create their own contexts - unbeknownst to their API clients who may or may not have created contexts of their own - would use cuCtxPushCurrent() and cuCtxPopCurrent() as illustrated in the following figure."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.1. Context - httpscdnmineruopenxlaborgcnres......Fig 1 Library Context Manageme...",
    "content": "![](https://cdn-mineru.openxlab.org.cn/result/2025-08-31/1ed427a0-0858-4b09-a70d-dc15cd618217/baef135e95b0e36cae2a08b1f07071592fcff5eb7b832cd1e2811f70b96127d5.jpg)  \nFig. 1: Library Context Management"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.2. Module - Modules are dynamically loadab......This code sample compiles and ...",
    "content": "Modules are dynamically loadable packages of device code and data, akin to DLLs in Windows, that are output by nvcc (see Compilation with NVCC). The names for all symbols, including functions, global variables, and texture or surface references, are maintained at module scope so that modules written by independent third parties may interoperate in the same CUDA context.\n\nThis code sample loads a module and retrieves a handle to some kernel:\n\n```cppCumodule cuModule;cuModuleLoad(&cuModule, \"myModule.ptx\");CUFunction myKernel;cuModuleGetFunction(&myKernel, cuModule, \"myKernel\");```\n\nThis code sample compiles and loads a new module from PTX code and parses compilation errors:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.2. Module - define BUFFERSIZE 8192Cumodule......continues on next page",
    "content": "define BUFFER_SIZE 8192Cumodule cuModule;CUjit_option options[3];void* values[3];char* PTXCode = \"some PTX code\";char error_log[BUFFER_SIZE];int err;options[0] = CU_JIT_ERROR_LOG_BUFFER;values[0] = (void*)error_log;options[1] = CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES;values[1] = (void*)BUFFER_SIZE;options[2] = CU_JIT_TARGET_FROM_COCONTEXT;values[2] = 0;err = cuModuleLoadDataEx(&cuModule, PTXCode, 3, options, values);if (err != CUDA_SUCCESS)    printf(\"Link error:\\n%s\\n\", error_log);```\n\nThis code sample compiles, links, and loads a new module from multiple PTX codes and parses link and compilation errors:\n\ndefine BUFFER_SIZE 8192Cumodule cuModule;\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.2. Module - Cujitoption options6 void valu...",
    "content": "Cujit_option options[6]; void\\* values[6]; float walltime; char error_log[BUFFER_SIZE], info_log[BUFFER_SIZE]; char\\* PTXCode0  $=$  \"some PTX code\"; char\\* PTXCode1  $=$  \"some other PTX code\"; CulinkState linkState; int err; void\\* cubin; size_t cubinSize; options[0]  $=$  CU_JIT_WALL_TIME; values[0]  $=$  (void\\*)&walltime; options[1]  $=$  CU_JIT_INFO_LOG_BUFFER; values[1]  $=$  (void\\*)info_log; options[2]  $=$  CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES; values[2]  $=$  (void\\*)BUFFER_SIZE; options[3]  $=$  CU_JIT_ERROR_LOG_BUFFER; values[3]  $=$  (void\\*)error_log; options[4]  $=$  CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES; values[4]  $=$  (void\\*)BUFFER_SIZE; options[5]  $=$  CU_JIT_LOG_VERBOSE; values[5]  $=$  (void\\*)1; cuLinkCreate(6, options, values, &linkState); err  $=$  cuLinkAddData(linkSt"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.2. Module - ate CUJITINPUTPTX voidPTXCode0...",
    "content": "ate, CU_JIT_INPUT_PTX, (void\\*)PTXCode0, strlen(PTXCode0) + 1, 0, 0, 0, 0); if (err  $!"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.2. Module - CUDASUCCESS printfLink errorns...",
    "content": " =$  CUDA_SUCCESS) printf(\"Link error:\\n%s\\n\", error_log); err  $=$  cuLinkAddData(linkState, CU_JIT_INPUT_PTX, (void\\*)PTXCode1, strlen(PTXCode1) + 1, 0, 0, 0, 0); if (err  $! =$  CUDA_SUCCESS) printf(\"Link error:\\n%s\\n\", error_log); cuLinkComplete(linkState, &cubin, &cubinSize); printf(\"Link completed in %fms. Linker Output:\\n%s\\n\", walltime, info_log); cuModuleLoadData(cuModule, cubin); cuLinkDestroy(linkState);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.2. Module - Full code can be found in the ...",
    "content": "Full code can be found in the ptxjit CUDA sample."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.3. Kernel Execution - cuLaunchKernel launches a kern......When parameters are passed as ...",
    "content": "cuLaunchKernel() launches a kernel with a given execution configuration.\n\nParameters are passed either as an array of pointers (next to last parameter of cuLaunchKernel()) where the nth pointer corresponds to the nth parameter and points to a region of memory from which the parameter is copied, or as one of the extra options (last parameter of cuLaunchKernel()).\n\nWhen parameters are passed as an extra option (the CU_LAUNCH_PARAM_BUFFER_POINTER option), they are passed as a pointer to a single buffer where parameters are assumed to be properly offset with respect to each other by matching the alignment requirement for each parameter type in device code."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.3. Kernel Execution - Alignment requirements in devi......Cdeviceptr is an integer but r...",
    "content": "Alignment requirements in device code for the built- in vector types are listed in Table 4. For all other basic types, the alignment requirement in device code matches the alignment requirement in host code and can therefore be obtained using __alignof(). The only exception is when the host compiler\n\naligns double and long long (and long on a 64- bit system) on a one- word boundary instead of a two- word boundary (for example, using gcc's compilation flag - mno- align- double) since in device code these types are always aligned on a two- word boundary.\n\nCdeviceptr is an integer, but represents a pointer, so its alignment requirement is __alignof(void\\*)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.3. Kernel Execution - The following code sample uses......define ADDTOPARAMBUFFERvalue a...",
    "content": "The following code sample uses a macro (ALIGN_UP()) to adjust the offset of each parameter to meet its alignment requirement and another macro (ADD_TO_PARAM_BUFFER()) to add each parameter to the parameter buffer passed to the CU_LAUNCH_PARAM_BUFFER_POINTER option.\n\ndefine ALTGN_UP(offset, alignment)  $(offset) = ((offset) + (alignment) - 1) & \\sim ((alignment) - 1)$\n\nchar paramBuffer[1024]; size_t paramBufferSize  $= \\theta$  .\n\ndefine ADD_TO_PARAM_BUFFER(value, alignment) do { paramBufferSize  $=$  ALIGN_UP(paramBufferSize, alignment); memcpy(paramBuffer  $^+$  paramBufferSize, &value), sizeof(value)); paramBufferSize  $+ =$  sizeof(value); } while (0)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.3. Kernel Execution - int i ADDTOPARAMBUFFERi aligno......void extra   CULAUNCHPARAMBUFF...",
    "content": "int i; ADD_TO_PARAM_BUFFER(i, __alignof(i)); float4 f4; ADD_TO_PARAM_BUFFER(f4, 16); // float4's alignment is 16 char c; ADD_TO_PARAM_BUFFER(c, __alignof(c)); float f; ADD_TO_PARAM_BUFFER(f, __alignof(f)); Cdeviceptr devPtr; ADD_TO_PARAM_BUFFER(devPtr, __alignof(devPtr)); float2 f2; ADD_TO_PARAM_BUFFER(f2, 8); // float2's alignment is 8\n\nvoid\\* extra[] = { CU_LAUNCH_PARAM_BUFFER_POINTER, paramBuffer, CU_LAUNCH_PARAM_BUFFER_SIZE, &paramBufferSize, CU_LAUNCH_PARAM_END }; cuLaunchKernel(cufunction, blockWidth, blockHeight, blockDepth, gridWidth, gridHeight, gridDepth, 0, 0, 0, extra);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.3. Kernel Execution - The alignment requirement of a......typedef struct  float f float4...",
    "content": "The alignment requirement of a structure is equal to the maximum of the alignment requirements of its fields. The alignment requirement of a structure that contains built- in vector types, Cdeviceptr, or non- aligned double and long long, might therefore differ between device code and host code. Such a structure might also be padded differently. The following structure, for example, is not padded at all in host code, but it is padded in device code with 12 bytes after field f since the alignment requirement for field f4 is 16.\n\ntypedef struct { float f; float4 f4;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.4. Interoperability between Runtime and Driver APIs - An application can mix runtime......Device memory can be allocated...",
    "content": "An application can mix runtime API code with driver API code.\n\nIf a context is created and made current via the driver API, subsequent runtime calls will pick up this context instead of creating a new one.\n\nIf the runtime is initialized (implicitly as mentioned in CUDA Runtime), cuCtxGetCurrent() can be used to retrieve the context created during initialization. This context can be used by subsequent driver API calls.\n\nThe implicitly created context from the runtime is called the primary context (see Initialization). It can be managed from the driver API with the Primary Context Management functions.\n\nDevice memory can be allocated and freed using either API. CUdeviceptr can be cast to regular pointers and vice- versa:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.4. Interoperability between Runtime and Driver APIs - cppCdeviceptr devPtrfloat ddat......All functions from the device ...",
    "content": "```cppCdeviceptr devPtr;float* d_data;// Allocation using driver APIcuMemAlloc(&devPtr, size);d_data = (float*)devPtr;// Allocation using runtime APICudaMalloc(&d_data, size);devPtr = (CUdeviceptr)d_data;```\n\nIn particular, this means that applications written using the driver API can invoke libraries written using the runtime API (such as cuFFT, cuBLAS, ...).\n\nAll functions from the device and version management sections of the reference manual can be used interchangeably."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5. Driver Entry Point Access",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.1. Introduction - The Driver Entry Point Access ......Retrieve the address of a driv...",
    "content": "# 20.5.1. Introduction\nThe Driver Entry Point Access APIs provide a way to retrieve the address of a CUDA driver function. Starting from CUDA 11.3, users can call into available CUDA driver APIs using function pointers obtained from these APIs.\n\nThese APIs provide functionality similar to their counterparts, dlsym on POSIX platforms and GetProcaAddress on Windows. The provided APIs will let users:\n\nRetrieve the address of a driver function using the CUDA Driver API.\n\n- Retrieve the address of a driver function using the CUDA Runtime API.- Request per-thread default stream version of a CUDA driver function. For more details, see Retrieve per-thread default stream versions- Access new CUDA features on older toolkits but with a newer driver."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.2. Driver Function Typedefs - To help retrieve the CUDA Driv......Table 2 Table 17 Typedefs head...",
    "content": "To help retrieve the CUDA Driver API entry points, the CUDA Toolkit provides access to headers containing the function pointer definitions for all CUDA driver APIs. These headers are installed with the CUDA Toolkit and are made available in the toolkit's include/ directory. The table below summarizes the header files containing the typedefs for each CUDA API header file.\n\nTable 2: Table 17. Typedefs header files for CUDA driver APIs"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.2. Driver Function Typedefs - tabletrtdAPI header filetdtdAP......The above headers do not defin...",
    "content": "<table><tr><td>API header file</td><td>API Typedef header file</td></tr><tr><td>cuda.h</td><td>cudaTypedefs.h</td></tr><tr><td>cudaGL.h</td><td>cudaGLTypedefs.h</td></tr><tr><td>cudaProfiler.h</td><td>cudaProfilerTypedefs.h</td></tr><tr><td>cudaVDPAU.h</td><td>cudaVDPAUTypedefs.h</td></tr><tr><td>cudaEGL.h</td><td>cudaEGLTypedefs.h</td></tr><tr><td>cudaD3D9.h</td><td>cudaD3D9Typedefs.h</td></tr><tr><td>cudaD3D10.h</td><td>cudaD3D10Typedefs.h</td></tr><tr><td>cudaD3D11.h</td><td>cudaD3D11Typedefs.h</td></tr></table>\n\nThe above headers do not define actual function pointers themselves; they define the typedefs for function pointers. For example, cudaTypedefs . h has the below typedefs for the driver API cuMemAlloc:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.2. Driver Function Typedefs - typedef CUresult CUDAAPI PFNcu...",
    "content": "typedef CUresult (CUDAAPI \\*PFN_cuMemAlloc_v3020) (CUdeviceptr_v2 \\*dptr, size_t  $\\rightharpoonup$  bytesize); typedef CUresult (CUDAAPI \\*PFN_cuMemAlloc_v2000) (CUdeviceptr_v1 \\*dptr, unsigned int  $\\rightharpoonup$  bytesize);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.2. Driver Function Typedefs - CUDA driver symbols have a ver......PFNcuMemAllocv3020 pfncuMemAll...",
    "content": "CUDA driver symbols have a version based naming scheme with a  $\\_ v^*$  extension in its name except for the first version. When the signature or the semantics of a specific CUDA driver API changes, we increment the version number of the corresponding driver symbol. In the case of the cuMemAlloc driver API, the first driver symbol name is cuMemAlloc and the next symbol name is cuMemAlloc_v2. The typedef for the first version which was introduced in CUDA 2.0 (2000) is PFN_cuMemAlloc_v2000. The typedef for the next version which was introduced in CUDA 3.2 (3020) is PFN_cuMemAlloc_v3020.\n\nThe typedefs can be used to more easily define a function pointer of the appropriate type in code:\n\nPFN_cuMemAlloc_v3020 pfn_cuMemAlloc_v2; PFN_cuMemAlloc_v2000 pfn_cuMemAlloc_v1;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.2. Driver Function Typedefs - The above method is preferable......PFNcuMemAlloc pfncuMemAlloc",
    "content": "The above method is preferable if users are interested in a specific version of the API. Additionally, the headers have predefined macros for the latest version of all driver symbols that were available\n\nwhen the installed CUDA toolkit was released; these typedefs do not have a _v* suffix. For CUDA 11.3 toolkit, cuMemAlloc_v2 was the latest version and so we can also define its function pointer as below:\n\nPFN_cuMemAlloc pfn_cuMemAlloc;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.3. Driver Function Retrieval - Using the Driver Entry Point A...",
    "content": "Using the Driver Entry Point Access APIs and the appropriate typedef, we can get the function pointer to any CUDA driver API."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.3.1 Using the driver API - The driver API requires CUDA v......cudaTypedefsh  typedef CUresul...",
    "content": "The driver API requires CUDA version as an argument to get the ABI compatible version for the requested driver symbol. CUDA Driver APIs have a per- function ABI denoted with a _v* extension. For example, consider the versions of cuStreamBeginCapture and their corresponding typedefs from cudaTypedes.h:\n\n// cuda.h  CUresult CUDAAPI cuStreamBeginCapture(CUstream hStream);  CUresult CUDAAPI cuStreamBeginCapture_v2(CUstream hStream, CUstreamCaptureMode mode);\n\n// cudaTypedefs.h  typedef CUresult (CUDAAPI *PFN_cuStreamBeginCapture_v10000)(CUstream hStream);  typedef CUresult (CUDAAPI *PFN_cuStreamBeginCapture_v10010)(CUstream hStream, _CUIstreamCaptureMode mode);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.3.1 Using the driver API - From the above typedefs in the......Get the function pointer to th...",
    "content": "From the above typedefs in the code snippet, version suffixes _v10000 and _v10010 indicate that the above APIs were introduced in CUDA 10.0 and CUDA 10.1 respectively.\n\ninclude <cudaTypedefs.h>\n\n// Declare the entry points for cuStreamBeginCapture  PFN_cuStreamBeginCapture_v10000 pfn_cuStreamBeginCapture_v1;  PFN_cuStreamBeginCapture_v10010 pfn_cuStreamBeginCapture_v2;\n\n// Get the function pointer to the cuStreamBeginCapture driver symbol  cuGetProcAddress(\"cuStreamBeginCapture\", &PFN_cuStreamBeginCapture_v1, 10000, CU_GET_PROC_ADDRESS_DEFAULT, &driverStatus);  // Get the function pointer to the cuStreamBeginCapture_v2 driver symbol  cuGetProcAddress(\"cuStreamBeginCapture\", &PFN_cuStreamBeginCapture_v2, 10010, CU_GET_PROC_ADDRESS_DEFAULT, &driverStatus);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.3.1 Using the driver API - Referring to the code snippet ...",
    "content": "Referring to the code snippet above, to retrieve the address to the _v1 version of the driver API cuStreamBeginCapture, the CUDA version argument should be exactly 10.0 (10000). Similarly, the CUDA version for retrieving the address to the _v2 version of the API should be 10.1 (10010). Specifying a higher CUDA version for retrieving a specific version of a driver API might not always be portable. For example, using 11030 here would still return the _v2 symbol, but if a hypothetical _v3 version is released in CUDA 11.3, the cuGetProcAddress API would start returning the newer _v3 symbol instead when paired with a CUDA 11.3 driver."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.3.1 Using the driver API - Since the ABI and function sig...",
    "content": " Since the ABI and function signatures of the _v2 and _v3 symbols might differ, calling the _v3 function using the _v10010 typedef intended for the _v2 symbol would exhibit undefined behavior."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.3.1 Using the driver API - To retrieve the latest version......pointer Since   sqrt2  is the ...",
    "content": "To retrieve the latest version of a driver API for a given CUDA Toolkit, we can also specify CUDA_VERSION as the version argument and use the unversioned typedef to define the function\n\npointer. Since  $- \\sqrt{2}$  is the latest version of the driver API cuStreamBeginCapture in CUDA 11.3, the below code snippet shows a different method to retrieve it."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.3.1 Using the driver API - Assuming we are using CUDA 113......Note that requesting a driver ...",
    "content": "// Assuming we are using CUDA 11.3 Toolkit#include <cudaTypedefs.h>// Declare the entry pointPFN_cuStreamBeginCapture pfn_cuStreamBeginCapture_latest;// Intialize the entry point. Specifying CUDA_VERSION will give the function pointer to the cuStreamBeginCapture_v2 symbol since it is latest version on CUDA 11.3. cuGetProcAddress(\"cuStreamBeginCapture\", &pfn_cuStreamBeginCapture_latest, CUDA_VERSION, CU_GET_PROC_ADDRESS_DEFAULT, &driverStatus);\n\nNote that requesting a driver API with an invalid CUDA version will return an error CUDA_ERROR_NOT_FOUND. In the above code examples, passing in a version less than 10000 (CUDA 10.0) would be invalid."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.3.2 Using the runtime API - The runtime API uses the CUDA ......Call the entry pointifdriverSt...",
    "content": "# 20.5.3.2 Using the runtime API\nThe runtime API uses the CUDA runtime version to get the ABI compatible version for the requested driver symbol. In the below code snippet, the minimum CUDA runtime version required would be CUDA 11.2 as cuMemAllocAsync was introduced then.\n\ninclude <cudaTypedefs.h>\n\n// Declare the entry point\n\nPFN_cuMemAllocAsync pfn_cuMemAllocAsync;\n\n// Intialize the entry point. Assuming CuDA runtime version  $> = 11.2$  cudaGetDriverEntryPoint(\"cuMemAllocAsync\", &pfn_cuMemAllocAsync, cudaEnableDefault, & driverStatus);\n\n// Call the entry pointif(driverStatus == cudaDriverEntryPointSuccess && pfn_cuMemAllocAsync) {    pfn_cuMemAllocAsync(...);}"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.3.3 Retrieve per-thread default stream versions - Some CUDA driver APIs can be c......The default stream or per thre...",
    "content": "Some CUDA driver APIs can be configured to have default stream or per- thread default stream semantics. Driver APIs having per- thread default stream semantics are suffixed with _ptsz or _pts in their name. For example, cuLaunchKernel has a per- thread default stream variant named cuLaunchKernel_ptsz. With the Driver Entry Point Access APIs, users can request for the per- thread default stream version of the driver API cuLaunchKernel instead of the default stream version. Configuring the CUDA driver APIs for default stream or per- thread default stream semantics affects the synchronization behavior. More details can be found here.\n\nThe default stream or per- thread default stream versions of a driver API can be obtained by one of the following ways:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.3.3 Retrieve per-thread default stream versions - Use the compilation flag   def......Force default stream or perthr...",
    "content": "Use the compilation flag - - default- stream per- thread or define the macro CUDA_API_PER_THREAD_DEFAULT_STREAM to get per- thread default stream behavior.\n\n- Force default stream or per-thread default stream behavior using the flags CU_GET_PROC_ADDRESS_LEGACY_STREAM/cudaEnableLegacyStream or CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM/cudaEnablePerThreadDefaultStream respectively."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.3.4 Access new CUDA features - It is always recommended to in...",
    "content": "It is always recommended to install the latest CUDA toolkit to access new CUDA driver features, but if for some reason, a user does not want to update or does not have access to the latest toolkit, the API can be used to access new CUDA features with only an updated CUDA driver. For discussion, let us assume the user is on CUDA 11.3 and wants to use a new driver API cuFoo available in the CUDA 12.0 driver. The below code snippet illustrates this use- case:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.3.4 Access new CUDA features - cppint main   Assuming we have...",
    "content": "```cppint main() { // Assuming we have CUDA 12.0 driver installed. // Manually define the prototype as cudatypedefs.h in CUDA 11.3 does not have the cuFoo typedef CUresult (CUDAAPI *PFN_cuFoo)(...);PFN_cuFoo pfn_cuFoo = NULL;CUdriverProcAddressQueryResult driverStatus; // Get the address for cuFoo API using cudatrucAddress. Specify CUDA version as // 12000 since cuFoo was introduced then or get the driver version dynamically // using cuDriverGetVersionint driverVersion;cuDriverGetVersion(&driverVersion);CUresult status = cuGetProcAddress(\"cuFoo\", &pfn_cuFoo, driverVersion, CU_GET_PROC_ADDRESS_DEFAULT, &driverStatus);if (status == CUDA_SUCCESS && pfn_cuFoo) {    pfn_cuFoo(...);} else {    printf(\"Cannot retrieve the address to cuFoo - driverStatus = %.d."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.3.4 Access new CUDA features - Check if the latest driver for...",
    "content": " Check if the latest driver for CUDA 12.0 is installed.\\n\", driverStatus);    assert(0);} // rest of code here}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4. Potential Implications with cuGetProcAddress - Below is a set of concrete and...",
    "content": "Below is a set of concrete and theoretical examples of potential issues with cuGetProcAddress and cudaGetDriverEntryPoint."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.1 Implications with cuGetProcAddress vs Implicit Linking - cuDeviceGetUuid was introduced......In this example assume the use...",
    "content": "cuDeviceGetUuid was introduced in CUDA 9.2. This API has a newer revision (cuDeviceGetUuid_v2) introduced in CUDA 11.4. To preserve minor version compatibility, cuDeviceGetUuid will not be version bumped to cuDeviceGetUuid_v2 in cuda.h until CUDA 12.0. This means that calling it by obtaining a function pointer to it via cuGetProcAddress might have different behavior. Example using the API directly:\n\ninclude <cuda.h> Clluuid uuid; CUdevice dev; CUresult status; status  $=$  cuDeviceGet(&dev, 0); // Get device 0 // handle status status  $=$  cuDeviceGetUuid(&uuid, dev) // Get uuid of device 0\n\nIn this example, assume the user is compiling with CUDA 11.4. Note that this will perform the behavior of cuDeviceGetUuid, not _v2 version. Now an example of using cuGetProcAddress:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.1 Implications with cuGetProcAddress vs Implicit Linking - include cudaTypedefsh CUuuid u......In this example assume the use...",
    "content": "include <cudaTypedefs.h> CUuuid uuid; CUdevice dev; CUresult status; CUdriverProcAddressQueryResult driverStatus; status  $=$  cuDeviceGet(&dev, 0); // Get device 0 // handle status PFN_cuDeviceGetUuid pfn_cuDeviceGetUuid; status  $=$  cuGetProcAddress(\"cuDeviceGetUuid\", &pfn_cuDeviceGetUuid, CUDA_VERSION, CU_  $\\hookrightarrow$  GET_PROC_ADDRESS_DEFAULT, &driverStatus); if(CUDA_SUCCESS  $= =$  status && pfn_cuDeviceGetUuid) { // pfn_cuDeviceGetUuid points to ??? }\n\nIn this example, assume the user is compiling with CUDA 11.4. This will get the function pointer of cuDeviceGetUuid_v2. Calling the function pointer will then invoke the new _v2 function, not the same cuDeviceGetUuid as shown in the previous example."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.2 Compile Time vs Runtime Version Usage in cuGetProcAddress - Lets take the same issue and m......continued from previous page",
    "content": "Let's take the same issue and make one small tweak. The last example used the compile time constant of CUDA_VERSION to determine which function pointer to obtain. More complications arise if the user queries the driver version dynamically using cuDriverGetVersion or cudaDriverGetVersion to pass to cuGetProcAddress. Example:\n\ninclude <cudaTypedefs.h>\n\nCUuuid uuid; CUdevice dev; CUresult status;\n\n(continues on next page)\n\n(continued from previous page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.2 Compile Time vs Runtime Version Usage in cuGetProcAddress - int cudaVersion CudriverProcAd...",
    "content": "int cudaVersion; CudriverProcAddressQueryResult driverStatus; status  $=$  cuDeviceGet(&dev, 0); // Get device 0 // handle status status  $=$  cuDriverGetVersion(&cudaVersion); // handle status PFN_cuDeviceGetUuid pfn_cuDeviceGetUuid; status  $=$  cuGetProcAddress(\"cuDeviceGetUuid\", &pfn_cuDeviceGetUuid, cudaVersion, CU_ _GET_PROC_ADDRESS_DEFAULT, &driverStatus); if(CUDA_SUCCESS  $= =$  status && pfn_cuDeviceGetUuid) { // pfn_cuDeviceGetUuid points to ??? }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.2 Compile Time vs Runtime Version Usage in cuGetProcAddress - In this example assume the use...",
    "content": "In this example, assume the user is compiling with CUDA 11.3. The user would debug, test, and deploy this application with the known behavior of getting cuDeviceGetUuid (not the _v2 version). Since CUDA has guaranteed ABI compatibility between minor versions, this same application is expected to run after the driver is upgraded to CUDA 11.4 (without updating the toolkit and runtime) without requiring recompilation. This will have undefined behavior though, because now the typedef for PFN_cuDeviceGetUuid will still be of the signature for the original version, but since cudaVersion would now be 11040 (CUDA 11.4), cuGetProcAddress would return the function pointer to the _v2 version, meaning calling it might have undefined behavior."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.2 Compile Time vs Runtime Version Usage in cuGetProcAddress - typedef Clresult CUDAAPI PFNcu......So in this case the APIABI is ...",
    "content": "Note in this case the original (not the _v2 version) typedef looks like:\n\ntypedef Clresult (CUDAAPI \\*PFN_cuDeviceGetUuid_v9020)(cluuid \\*uuid, ClDevice_v1 dev);\n\nBut the _v2 version typedef looks like:\n\ntypedef Clresult (CUDAAPI \\*PFN_cuDeviceGetUuid_v11040)(cluuid \\*uuid, ClDevice_v1 dev);\n\nSo in this case, the API/ABI is going to be the same and the runtime API call will likely not cause issues- - only the potential for unknown uuid return. In Implications to API/ABI, we discuss a more problematic case of API/ABI compatibility."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.3 API Version Bumps with Explicit Version Checks - Above was a specific concrete ......Notice that the API has been m...",
    "content": "Above, was a specific concrete example. Now for instance let's use a theoretical example that still has issues with compatibility across driver versions. Example:\n\nCUresult cuFoo(int bar); // Introduced in CUDA 11.4 CUresult cuFoo_v2(int bar); // Introduced in CUDA 11.5 CUresult cuFoo_v3(int bar, void\\* jazz); // Introduced in CUDA 11.6 typedef Clresult (CUDAAPI \\*PFN_cuFoo_v11040)(int bar); typedef Clresult (CUDAAPI \\*PFN_cuFoo_v11050)(int bar); typedef Clresult (CUDAAPI \\*PFN_cuFoo_v11060)(int bar, void\\* jazz);\n\nNotice that the API has been modified twice since original creation in CUDA 11.4 and the latest in CUDA 11.6 also modified the API/ABI interface to the function. The usage in user code compiled against CUDA 11.5 is:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.3 API Version Bumps with Explicit Version Checks - cinclude cudahinclude cudaType...",
    "content": "```c#include <cuda.h>#include <cudaTypedefs.h>CUresult status;int cudaVersion;CUdriverProcAddressQueryResult driverStatus;status = cuDriverGetVersion(&cudaVersion); // handle statusPFN_cuFoo_v11040 pfn_cuFoo_v11040;PFN_cuFoo_v11050 pfn_cuFoo_v11050;if(cudaVersion < 11050) {    // We know to get the CUDA 11.4 version    status = cuGetProcAddress(\"cuFoo\", &pfn_cuFoo_v11040, cudaVersion, CU_GET_PROC_ADDRESS_DEFAULT, &driverStatus);    // Handle status and validating pfn_cuFoo_v11040} else {    // Assume >= CUDA 11.5 version we can use the second version    status = cuGetProcAddress(\"cuFoo\", &pfn_cuFoo_v11050, cudaVersion, CU_GET_PROC_ADDRESS_DEFAULT, &driverStatus);    // Handle status and validating pfn_cuFoo_v11050}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.3 API Version Bumps with Explicit Version Checks - In this example without update...",
    "content": "In this example, without updates for the new typedef in CUDA 11.6 and recompiling the application with those new typedefs and case handling, the application will get the cuFoo_v3 function pointer returned and any usage of that function would then cause undefined behavior. The point of this example was to illustrate that even explicit version checks for cuGetProcAddress may not safely cover the minor version bumps within a CUDA major release."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.4 Issues with Runtime API Usage - The above examples were focuse......cinclude cudahinclude cudaType...",
    "content": "The above examples were focused on the issues with the Driver API usage for obtaining the function pointers to driver APIs. Now we will discuss the potential issues with the Runtime API usage for cudaApiGetDriverEntryPoint.\n\nWe will start by using the Runtime APIs similar to the above.\n\n```c#include <cuda.h>#include <cudaTypedefs.h>#include <cuda_runtime.h>CUresult status;cudaError_t error;int driverVersion, runtimeVersion;CUdriverProcAddressQueryResult driverStatus;// Ask the runtime for the functionPFN_cuDeviceGetUuid pfn_cuDeviceGetUuidRuntime;error = cudaGetDriverEntryPoint(\"cuDeviceGetUuid\", &pfn_cuDeviceGetUuidRuntime, cudaEnableDefault, &driverStatus);if(cudaSuccess == error && pfn_cuDeviceGetUuidRuntime) {    // pfn_cuDeviceGetUuid points to ???}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.4 Issues with Runtime API Usage - The function pointer in this e......tabletrtdtdtdtdtdtdtrtrtdDrive...",
    "content": "The function pointer in this example is even more complicated than the driver only examples above because there is no control over which version of the function to obtain; it will always get the API for the current CUDA Runtime version. See the following table for more information:\n\n<table><tr><td></td><td></td><td></td></tr><tr><td>Driver Version Installed</td><td>V11.3</td><td>V11.4</td></tr><tr><td>V11.3</td><td>v1</td><td>v1x</td></tr><tr><td>V11.4</td><td>v1</td><td>v2</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.4 Issues with Runtime API Usage - V113  113 CUDA Runtime and Too...",
    "content": "V11.3 => 11.3 CUDA Runtime and Toolkit (includes header files cuda.h and cudaTypedefs.  $\\rightarrow h$  V11.4 => 11.4 CUDA Runtime and Toolkit (includes header files cuda.h and cudaTypedefs.  $\\rightarrow h$ $\\lor 1\\Rightarrow$  cuDeviceGetUuid  $\\lor 2\\Rightarrow$  cuDeviceGetUuid_v2  $x = >$  Implies the typedef function pointer won't match the returned function pointer. In these cases, the typedef at compile time using a CUDA 11.4 runtime, would match the _v2 version, but the returned function pointer would be the original (non _v2) function."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.4 Issues with Runtime API Usage - The problem in the table comes...",
    "content": "The problem in the table comes in with a newer CUDA 11.4 Runtime and Toolkit and older driver (CUDA 11.3) combination, labeled as v1x in the above. This combination would have the driver returning the pointer to the older function (non _v2), but the typedef used in the application would be for the new function pointer."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.5 Issues with Runtime API and Dynamic Versioning - More complications arise when ...",
    "content": "More complications arise when we consider different combinations of the CUDA version with which an application is compiled, CUDA runtime version, and CUDA driver version that an application dynamically links against."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.5 Issues with Runtime API and Dynamic Versioning - cinclude cudahinclude cudaType...",
    "content": "```c#include <cuda.h>#include <cudaTypedefs.h>#include <cuda_runtime.h>CUresult status;cudaError_t error;int driverVersion, runtimeVersion;CUdriverProcAddressQueryResult driverStatus;enum cudaDriverEntryPointQueryResult runtimeStatus;PFN_cuDeviceGetUuid pfn_cuDeviceGetUuidDriver;status = cuGetProcAddress(\"cuDeviceGetUuid\", &pfn_cuDeviceGetUuidDriver, CUDA_VERSION,  $\\rightarrow$  CU_GET_PROC_ADDRESS_DEFAULT, &driverStatus);if(CUDA_SUCCESS == status && pfn_cuDeviceGetUuidDriver) {    // pfn_cuDeviceGetUuidDriver points to ???}// Ask the runtime for the functionPFN_cuDeviceGetUuid pfn_cuDeviceGetUuidRuntime;error = cudaGetDriverEntryPoint(\"cuDeviceGetUuid\", &pfn_cuDeviceGetUuidRuntime,  $\\rightarrow$  cudaEnableDefault, &runtimeStatus);```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.5 Issues with Runtime API and Dynamic Versioning - ifcudaSuccess     error  pfncu......The following matrix of functi...",
    "content": "if(cudaSuccess  $= =$  error && pfn_cuDeviceGetUuidRuntime) { // pfn_cuDeviceGetUuidRuntime points to ??? }\n\n// Ask the driver for the function based on the driver version (obtained via runtime) error  $=$  cudaDriverGetVersion(&driverVersion); PFN_cuDeviceGetUuid pfn_cuDeviceGetUuidDriverDriverVer; status  $=$  cuGetProcAddress (\"cuDeviceGetUuid\", &pfn_cuDeviceGetUuidDriverDriverVer, _driverVersion, CU_GET_PROC_ADDRESS_DEFAULT, &driverStatus); if(CUDA_SUCCESS  $= =$  status && pfn_cuDeviceGetUuidDriverDriverVer) { // pfn_cuDeviceGetUuidDriverDriverVer points to ??? }\n\nThe following matrix of function pointers is expected:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.5 Issues with Runtime API and Dynamic Versioning - tabletrtdFunction PointertdtdA...",
    "content": "<table><tr><td>Function Pointer</td><td>Application Compiled/Runtime Dynamic Linked Version/Driver Version</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>(3 =&amp;gt; CUDA 11.3 and 4 =&amp;gt; CUDA 11."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.5 Issues with Runtime API and Dynamic Versioning - 4tdtdtdtdtdtdtdtdtdtdtdtdtdtdt...",
    "content": "4)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>3/3/3</td><td>3/3/4</td><td>3/4/3</td><td>3/4/4</td><td>4/3/3</td><td>4/3/4</td><td>4/4/3</td><td>4/4/4</td></tr><tr><td>pfn_cuDeviceGetUuidDriver</td><td>t1/v1</td><td>t1/v1</td><td>t1/v1</td><td>N/A</td><td>N/A</td><td>t2/v1</td><td>t2/v2</td><td></td></tr><tr><td>pfn_cuDeviceGetUuidRahtime</td><td>t1/v1</td><td>t1/v1</td><td>t1/v2</td><td>N/A</td><td>N/A</td><td>t2/v1</td><td>t2/v2</td><td></td></tr><tr><td>pfn_cuDeviceGetUuidRahtimeDriver</td><td>t1/v2</td><td>t1/v1</td><td>t1/v2</td><td>N/A</td><td>N/A</td><td>t2/v1</td><td>t2/v2</td><td></td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.5 Issues with Runtime API and Dynamic Versioning - tx   Typedef version used at c......If the application is compiled...",
    "content": "tx - > Typedef version used at compile time  vX - > Version returned/used at runtime\n\nIf the application is compiled against CUDA Version 11.3, it would have the typedef for the original function, but if compiled against CUDA Version 11.4, it would have the typedef for the _v2 function. Because of that, notice the number of cases where the typedef does not match the actual version returned/used."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.6 Implications to API/ABI - In the above examples using cu...",
    "content": "In the above examples using cuDeviceGetUuid, the implications of the mismatched API are minimal, and may not be entirely noticeable to many users as the _v2 was added to support Multi- Instance GPU (MIG) mode. So, on a system without MIG, the user might not even realize they are getting a different API."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.6 Implications to API/ABI - More problematic is an API whi......PFNcuCtxCreate cuUnknown  CUdr...",
    "content": "More problematic is an API which changes its application signature (and hence ABI) such as cuCtxCreate. The _v2 version, introduced in CUDA 3.2 is currently used as the default cuCtxCreate when using cuda.h but now has a newer version introduced in CUDA 11.4 (cuCtxCreate_v3). The API signature has been modified as well, and now takes extra arguments. So, in some of the cases above, where the typedef to the function pointer doesn't match the returned function pointer, there is a chance for non- obvious ABI incompatibility which would lead to undefined behavior.\n\nFor example, assume the following code compiled against a CUDA 11.3 toolkit with a CUDA 11.4 driver installed:\n\nPFN_cuCtxCreate cuUnknown;  CUdriverProcAddressQueryResult driverStatus;"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.4.6 Implications to API/ABI - status    cuGetProcAddresscuCt......Running this code where cudaVe...",
    "content": "status  $=$  cuGetProcAddress(\"cuCtxCreate\", (void\\*\\*)&cuUnknown, cudaVersion, CU_GET_PROC_ ADDRESS_DEFAULT, &driverStatus); if(CUDA_SUCCESS  $= =$  status && cuUnknown) { status  $=$  cuUnknown(&ctx, 0, dev); }\n\nRunning this code where cudaVersion is set to anything  $> = 11040$  (indicating CUDA 11.4) could have undefined behavior due to not having adequately supplied all the parameters required for the _v3 version of the cuCtxCreate_v3 API."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.5. Determining cuGetProcAddress Failure Reasons - There are two types of errors ......The second error type encodes ...",
    "content": "There are two types of errors with cuGetProcAddress. Those are (1) API/usage errors and (2) inability to find the driver API requested. The first error type will return error codes from the API via the CUresult return value. Things like passing NULL as the pfn variable or passing invalid flags.\n\nThe second error type encodes in the CudriverProcAddressQueryResult \\*symbolStatus and can be used to help distinguish potential issues with the driver not being able to find the symbol requested. Take the following example:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.5. Determining cuGetProcAddress Failure Reasons - cuDeviceGetExecAffinitySupport...",
    "content": "// cuDeviceGetExecAffinitySupport was introduced in release CUDA 11.4 #include <cuda.h> CuDriverProcAddressQueryResult driverStatus; cudaVersion  $=$  ...; status  $=$  cuGetProcAddress(\"cuDeviceGetExecAffinitySupport\", &pfn, cudaVersion, 0, & driverStatus); if (CUDA_SUCCESS  $= =$  status) { if (CU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT  $= =$  driverStatus) { printf(\"We can use the new feature when you upgrade cudaVersion to 11.4, but CUDA driver is good to go!\\n\"); // Indicating cudaVersion was < 11.4 but run against a CUDA driver  $> = 11.4$  } else if (CU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND  $= =$  driverStatus) { printf(\"Please update both CUDA driver and cudaVersion to at least 11.4 to use the new feature!\\n\"); // Indicating driver is < 11."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.5. Determining cuGetProcAddress Failure Reasons - 4 since string not found doesn...",
    "content": "4 since string not found, doesn't matter what cudaVersion was } else if (CU_GET_PROC_ADDRESS_SUCCESS  $= =$  driverStatus && pfn) { printf(\"You're using cudaVersion and CUDA driver  $> = 11.4$  , using new feature!\\n  $\\rightarrow^{\\prime \\prime}$  ): pfn(); } }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.5. Determining cuGetProcAddress Failure Reasons - The first case with the return...",
    "content": "The first case with the return code CU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT indicates that the symbol was found when searching in the CUDA driver but it was added later than the cudaVersion supplied. In the example, specifying cudaVersion as anything 11030 or less and when running against a CUDA driver  $> =$  CUDA 11.4 would give this result of CU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT. This is because cuDeviceGetExecAffinitySupport was added in CUDA 11.4 (11040)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.5. Determining cuGetProcAddress Failure Reasons - The second case with the retur...",
    "content": "The second case with the return code CU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND indicates that the symbol was not found when searching in the CUDA driver. This can be due to a few reasons such as unsupported CUDA function due to older driver as well as just having a typo. In the latter, similar to the last example if the user had put symbol as CUDADeviceGetExecAffinitySupport - notice the capital CU to start the string - cuGetProcAddress would not be able to find the API because the string doesn't match. In the former case an example might be the user developing an application against a CUDA driver supporting the new API, and deploying the application against an older CUDA driver. Using the last example, if the developer developed against CUDA 11.4 or later but was deployed against a CUDA 11."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "20.5.5. Determining cuGetProcAddress Failure Reasons - 3 driver during their developm...",
    "content": "3 driver, during their development they may have had a successful cuGetProcAddress, but when deploying an application running against a CUDA 11.3 driver the call would no longer work with the CU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND returned in driver status."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 21. CUDA Environment Variables - The following table lists the ......Table 1Table 18CUDA Environmen...",
    "content": "The following table lists the CUDA environment variables. Environment variables related to the Multi- Process Service are documented in the Multi- Process Service section of the GPU Deployment and Management guide.\n\nTable 1:Table 18.CUDA Environment Variables"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 21. CUDA Environment Variables - tabletrtdVariabletdtdValuestdt...",
    "content": "<table><tr><td>Variable</td><td>Values</td><td>Description</td></tr><tr><td>Device Enumeration and Prop-erties</td><td></td><td></td></tr><tr><td>CUDA_VISIBLE_DEVICES</td><td>A comma-separated sequence of GPU identifiers MIG support: MIG-&amp;lt;GPU-UUID&amp;gt;/&amp;lt;GPU in-stance ID&amp;gt;/&amp;lt;compute in-stance ID&amp;gt;</td><td>GPU identifiers are given as integer indices or as UUID strings. GPU UUID strings should follow the same format as given by nvidia-smi, such as GPU-8932f937-d72c-4106-c12f-20bd9faed9f6. However, for convenience, abbreviated forms are allowed; simply specify enough digits from the beginning of the GPU UUID to uniquely identify that GPU in the target system."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 21. CUDA Environment Variables - For example CUDAVISIBLEDEVICES...",
    "content": " For example, CUDA_VISIBLE_DEVICES=GPU-8932f937 may be a valid way to refer to the above GPU UUID, assuming no other GPU in the system shares this prefix. Only the devices whose index is present in the sequence are visible to CUDA applications and they are enumerated in the order of the sequence. If one of the indices is invalid, only the devices whose index precedes the invalid index are visible to CUDA applications. For example, setting CUDA_VISIBLE_DEVICES to 2,1 causes device 0 to be invisible and device 2 to be enumerated before device 1. Setting CUDA_VISIBLE_DEVICES to 0,2,-1,1 causes devices 0 and 2 to be visible and device 1 to be invisible. MIG format starts with MIG keyword and GPU UUID should follow the same format as given by nvidia-smi."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 21. CUDA Environment Variables - For example MIGGPU8932f937d72c...",
    "content": " For example, MIG-GPU-8932f937-d72c-4106-c12f-20bd9faed9f6/1/2. Only single MIG instance enumeration is supported.</td></tr><tr><td>CUDA_MANAGED_FORCE_DEVICE_DEAD最喜欢的 default is 0)</td><td></td><td>Forces the driver to place all managed allocations in device memory.</td></tr><tr><td>CUDA_DEVICE_ORDER</td><td>FASTEST_FIRST_PCI_BUS_ID (default is FASTEST_FIRST_FIRST)</td><td>FASTEST_FIRST_BUS_id 2 to enumerate the available devices in fastest to slowest or-der using a simple heuristic. PCI_BUS_ID orders devices by</td></tr></table>"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 22. Unified Memory Programming",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1. Unified Memory Introduction - Unified Memory is a component ......The underlying system manages ...",
    "content": "Unified Memory is a component of the CUDA programming model, first introduced in CUDA 6.0, that defines a managed memory space in which all processors see a single coherent memory image with a common address space.\n\nNote: A processor refers to any independent execution unit with a dedicated MMU. This includes both CPUs and GPUs of any type and architecture.\n\nThe underlying system manages data access and locality within a CUDA program without need for explicit memory copy calls. This benefits GPU programming in two primary ways:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1. Unified Memory Introduction - In simple terms Unified Memory...",
    "content": "- GPU programming is simplified by unifying memory spaces coherently across all GPUs and CPUs in the system and by providing tighter and more straightforward language integration for CUDA programmers.  \n- Data access speed is maximized by transparently migrating data towards the processor using it.\n\nIn simple terms, Unified Memory eliminates the need for explicit data movement via the cudaMemory\\* () routines without the performance penalty incurred by placing all data into zero- copy memory. Data movement, of course, still takes place, so a program's run time typically does not decrease; Unified Memory instead enables the writing of simpler and more maintainable code."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1. Unified Memory Introduction - Unified Memory offers a single......The term Unified Memory descri...",
    "content": "Unified Memory offers a \"single- pointer- to- data\" model that is conceptually similar to CUDA's zero- copy memory. One key difference between the two is that with zero- copy allocations the physical location of memory is pinned in CPU system memory such that a program may have fast or slow access to it depending on where it is being accessed from. Unified Memory, on the other hand, decouples memory and execution spaces so that all data accesses are fast.\n\nThe term Unified Memory describes a system that provides memory management services to a wide range of programs, from those targeting the Runtime API down to those using the Virtual ISA (PTX). Part of this system defines the managed memory space that opts in to Unified Memory services."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1. Unified Memory Introduction - Managed memory is interoperabl......Note Unified memory is not sup...",
    "content": "Managed memory is interoperable and interchangeable with device- specific allocations, such as those created using the cudaMalloc() routine. All CUDA operations that are valid on device memory are also valid on managed memory; the primary difference is that the host portion of a program is able to reference and access the memory as well.\n\nNote: Unified memory is not supported on discrete GPUs attached to Tegra."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.1. System Requirements - Unified Memory has two basic r......GPUs with SM architecture 6 x ...",
    "content": "# 22.1.1. System Requirements\nUnified Memory has two basic requirements:\n\na GPU with SM architecture 3.0 or higher (Kepler class or newer) a 64- bit host application and non- embedded operating system (Linux or Windows)\n\nGPUs with SM architecture 6. x or higher (Pascal class or newer) provide additional Unified Memory features such as on- demand page migration and GPU memory oversubscription that are outlined throughout this document. Note that currently these features are only supported on Linux operating systems. Applications running on Windows (whether in TCC or WDDM mode) will use the basic Unified Memory model as on pre- 6. x architectures even when they are running on hardware with compute capability 6. x or higher. See Data Migration and Coherency for details."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.2. Simplifying GPU Programming - Unification of memory spaces m......A program allocates managed me...",
    "content": "Unification of memory spaces means that there is no longer any need for explicit memory transfers between host and device. Any allocation created in the managed memory space is automatically migrated to where it is needed.\n\nA program allocates managed memory in one of two ways: via the cudaMallocManaged() routine, which is semantically similar to cudaMalloc(); or by defining a global __managed__ variable, which is semantically similar to a __device__ variable. Precise definitions of these are found later in this document."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.2. Simplifying GPU Programming - The following code examples il...",
    "content": "Note: On supporting platforms with devices of compute capability 6. x and higher, Unified Memory will enable applications to allocate and share data using the default system allocator. This allows the GPU to access the entire system virtual memory without using a special allocator. See System Allocator for more detail.\n\nThe following code examples illustrate how the use of managed memory can change the way in which host code is written. First, a simple program written without the benefit of Unified Memory:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.2. Simplifying GPU Programming - continues on next page...This first example combines tw...",
    "content": "- global__ void AplusB(int *ret, int a, int b) {    ret[threadIdx.x] = a + b + threadIdx.x;}int main() {    int *ret;    cudaMalloc(&ret, 1000 * sizeof(int));    AplusB<<< 1, 1000>>>(ret, 10, 100);    int *host_ret = (int *)malloc(1000 * sizeof(int));    cudaMemcpy(host_ret, ret, 1000 * sizeof(int), cudaMemcpyDefault);    for(int i = 0; i < 1000; i++)        printf(\"%d: A+B = %d\\n\", i, host_ret[i]);    free(host_ret);    cudaFree(ret);\n\n(continues on next page)\n\nThis first example combines two numbers together on the GPU with a per- thread ID and returns the values in an array. Without managed memory, both host- and device- side storage for the return values is required (host_ret and ret in the example), as is an explicit copy between the two using cudaMemorycopy()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.2. Simplifying GPU Programming - Compare this with the Unified ......cppglobal void AplusBint ret i...",
    "content": "Compare this with the Unified Memory version of the program, which allows direct access of GPU data from the host. Notice the cudaMallocManaged() routine, which returns a pointer valid from both host and device code. This allows ret to be used without a separate host_ret copy, greatly simplifying and reducing the size of the program.\n\n```cpp__global__ void AplusB(int *ret, int a, int b) {    ret[threadIdx.x] = a + b + threadIdx.x;}int main() {    int *ret;    cudaMallocManaged(&ret, 1000 * sizeof(int));    AplusB<<< 1, 1000 >>>(ret, 10, 100);    cudaDeviceSynchronize();    for(int i = 0; i < 1000; i++)        printf(\"%d: A+B = %d\\n\", i, ret[i]);    cudaFree(ret);    return 0;}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.2. Simplifying GPU Programming - Finally language integration a......Note the absence of explicit c...",
    "content": "Finally, language integration allows direct reference of a GPU- declared __managed__ variable and simplifies a program further when global variables are used.\n\n```cpp__device__ __managed__ int ret[1000];__global__ void AplusB(int a, int b) {    ret[threadIdx.x] = a + b + threadIdx.x;}int main() {    AplusB<<< 1, 1000 >>>(10, 100);    cudaDeviceSynchronize();    for(int i = 0; i < 1000; i++)        printf(\"%d: A+B = %d\\n\", i, ret[i]);    return 0;}```\n\nNote the absence of explicit cuda memcpy() commands and the fact that the return array ret is visible on both CPU and GPU."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.2. Simplifying GPU Programming - It is worth a comment on the s...",
    "content": "It is worth a comment on the synchronization between host and device. Notice how in the non- managed example, the synchronous cuda memcpy() routine is used both to synchronize the kernel (that is, to wait for it to finish running), and to transfer the data to the host. The Unified Memory examples do not call cuda memcpy() and so require an explicit cudaDeviceSynchronize() before the host program can safely use the output from the GPU."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.3. Data Migration and Coherency - Unified Memory attempts to opt...",
    "content": "Unified Memory attempts to optimize memory performance by migrating data towards the device where it is being accessed (that is, moving data to host memory if the CPU is accessing it and to device memory if the GPU will access it). Data migration is fundamental to Unified Memory, but is transparent to a program. The system will try to place data in the location where it can most efficiently be accessed without violating coherency."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.3. Data Migration and Coherency - The physical location of data ...",
    "content": "The physical location of data is invisible to a program and may be changed at any time, but accesses to the data's virtual address will remain valid and coherent from any processor regardless of locality. Note that maintaining coherence is the primary requirement, ahead of performance; within the constraints of the host operating system, the system is permitted to either fail accesses or move data in order to maintain global coherence between processors."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.3. Data Migration and Coherency - GPU architectures of compute c...",
    "content": "GPU architectures of compute capability lower than 6. x do not support fine- grained movement of the managed data to GPU on- demand. Whenever a GPU kernel is launched all managed memory generally has to be transferred to GPU memory to avoid faulting on memory access. With compute capability 6. x a new GPU page faulting mechanism is introduced that provides more seamless Unified Memory functionality. Combined with the system- wide virtual address space, page faulting provides several benefits. First, page faulting means that the CUDA system software doesn't need to synchronize all managed memory allocations to the GPU before each kernel launch."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.3. Data Migration and Coherency - If a kernel running on the GPU...",
    "content": " If a kernel running on the GPU accesses a page that is not resident in its memory, it faults, allowing the page to be automatically migrated to the GPU memory on- demand. Alternatively, the page may be mapped into the GPU address space for access over the PCIe or NVLink interconnects (mapping on access can sometimes be faster than migration). Note that Unified Memory is system- wide: GPUs (and CPUs) can fault on and migrate memory pages either from CPU memory or from the memory of other GPUs in the system."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.4. GPU Memory Oversubscription - Devices of compute capability ...",
    "content": "Devices of compute capability lower than 6. x cannot allocate more managed memory than the physical size of GPU memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.4. GPU Memory Oversubscription - Devices of compute capability ...",
    "content": "Devices of compute capability 6. x extend addressing mode to support 49- bit virtual addressing. This is large enough to cover the 48- bit virtual address spaces of modern CPUs, as well as the GPU's own memory. The large virtual address space and page faulting capability enable applications to access the entire system virtual memory, not limited by the physical memory size of any one processor. This means that applications can oversubscribe the memory system: in other words they can allocate, access, and share arrays larger than the total physical capacity of the system, enabling out- of- core processing of very large datasets. cudaMallocManaged will not run out of memory as long as there is enough system memory available for the allocation."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.5. Multi-GPU - 2215 Multi GPUFor devices of c...",
    "content": "22.1.5. Multi- GPUFor devices of compute capability lower than 6. x managed memory allocation behaves identically to unmanaged memory allocated using cudaMalloc(): the current active device is the home for the physical allocation, and all other GPUs receive peer mappings to the memory. This means that other GPUs in the system will access the memory at reduced bandwidth over the PCIe bus. Note that if peer mappings are not supported between the GPUs in the system, then the managed memory pages are placed in CPU system memory (\"zero- copy\" memory), and all GPUs will experience PCIe bandwidth restrictions. See Managed Memory with Multi- GPU Programs on pre- 6. x Architectures for details."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.5. Multi-GPU - Managed allocations on systems...",
    "content": "Managed allocations on systems with devices of compute capability 6. x are visible to all GPUs and can migrate to any processor on- demand. Unified Memory performance hints (see Performance Tuning) allow developers to explore custom usage patterns, such as read duplication of data across GPUs and direct access to peer GPU memory without migration."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.6. System Allocator - Devices of compute capability ...",
    "content": "Devices of compute capability 7.0 support Address Translation Services (ATS) over NVLink. If supported by the host CPU and operating system, ATS allows the GPU to directly access the CPU's page tables. A miss in the GPU MMU will result in an Address Translation Request (ATR) to the CPU. The CPU looks in its page tables for the virtual- to- physical mapping for that address and supplies the translation back to the GPU. ATS provides the GPU full access to system memory, such as memory allocated with malloc, memory allocated on stack, global variables and file- backed memory. An application can query whether the device supports coherently accessing pageable memory via ATS by checking the new pageableMemoryAccessUsesHostPageTables property."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.6. System Allocator - Here is an example code that w...",
    "content": "Here is an example code that works on any system that satisfies the basic requirements for Unified Memory (see System Requirements):"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.6. System Allocator - int data cudaMallocManageddata...",
    "content": "int \\*data; cudaMallocManaged(&data, sizeof(int) \\* n); kernel- - - - - - grid, block- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - These new access patterns are supported on systems with pageableMemoryAccess property: int \\*data  $=$  (int\\*)mallocsizeof(int) \\* n); kernel- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - kernel- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.6. System Allocator - int data1024 kernel           ...",
    "content": " - - - - - - - - - - - - - - int data[1024]; kernel- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - extern int \\*data; kernel- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - kernel- \\* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.6. System Allocator - In the example above data coul......Note ATS over NVLink is curren...",
    "content": "In the example above, data could be initialized by a third party CPU library, and then directly accessed by the GPU kernel. On systems with pageableMemoryAccess, users may also prefetch pageable memory to the GPU by using cudaMemPrefetchAsync. This could yield performance benefits through optimized data locality.\n\nNote: ATS over NVLink is currently supported only on IBM Power9 systems."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.7. Hardware Coherency - The second generation of NVLin...",
    "content": "The second generation of NVLink allows direct load/store/atomic access from the CPU to each GPU's memory. Coupled with a new CPU mastering capability, NVLink supports coherency operations allowing data reads from GPU memory to be stored in the CPU's cache hierarchy. The lower latency of access from the CPU's cache is key for CPU performance. Devices of compute capability 6. x support only peer GPU atomics. Devices of compute capability 7. x can send GPU atomics across NVLink and have them completed at the target CPU, thus the second generation of NVLink adds support for atomics initiated by either the GPU or the CPU."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.7. Hardware Coherency - Consider an example code below",
    "content": "Note that cudaMalloc allocations are not accessible from the CPU. Therefore, to take advantage of hardware coherency users must use Unified Memory allocators such as cudaMallocManaged or system allocator with ATS support (see System Allocator). The new property directManagedMemAccessFromHost indicates if the host can directly access managed memory on the device without migration. By default, any CPU access of cudaMallocManaged allocations resident in GPU memory will trigger page faults and data migration. Applications can use cudaMemAdviseSetAccessedBy performance hint with cudaCpuDeviceId to enable direct access of GPU memory on supported systems.\n\nConsider an example code below:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.7. Hardware Coherency - cppglobal void writeint ret in...",
    "content": "```cpp__global__ void write(int *ret, int a, int b) {    ret[threadIdx.x] = a + b + threadIdx.x;}__global__ void append(int *ret, int a, int b) {    ret[threadIdx.x] += a + b + threadIdx."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.7. Hardware Coherency - xint main     int ret    cudaM...",
    "content": "x;}int main() {    int *ret;    cudaMallocManaged(&ret, 1000 * sizeof(int));    cudaMemAdvise(ret, 1000 * sizeof(int), cudaMemAdviseSetAccessedBy, cudaCpuDeviceId); // set direct access hint    write<<< 1, 1000>>>(ret, 10, 100); // pages populated in GPU memory    cudaDeviceSynchronize();    for(int i = 0; i < 1000; i++)        printf(\"A: A+B = %d\\n\", i, ret[i]);    //    _directManagedMemAccessFromHost = 1: CPU accesses GPU memory directly without migrations    //    _directManagedMemAccessFromHost = 0: CPU faults and triggers device- to- host migrations    append<<< 1, 1000>>>(ret, 10, 100);    //    _directManagedMemAccessFromHost = 1: GPU accesses GPU memory without migrations    cudaDeviceSynchronize();    //    _directManagedMemAccessFromHost = 0: GPU faults and triggers host- to- de"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.7. Hardware Coherency - vice migrations    cudaFreeret...",
    "content": "vice migrations    cudaFree(ret);    return 0;}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.7. Hardware Coherency - After write kernel is complete...",
    "content": "After write kernel is completed, ret will be created and initialized in GPU memory. Next, the CPU will access ret followed by append kernel using the same ret memory again. This code will show different behavior depending on the system architecture and support of hardware coherency:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.7. Hardware Coherency - On systems with directManagedM...",
    "content": "- On systems with directManagedMemAccessFromHost = 1: CPU accesses to the managed buffer will not trigger any migrations; the data will remain resident in GPU memory and any subsequent GPU kernels can continue to access it directly without inflicting faults or migrations.- On systems with directManagedMemAccessFromHost = 0: CPU accesses to the managed buffer will page fault and initiate data migration; any GPU kernel trying to access the same data first time will page fault and migrate pages back to GPU memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.1.8. Access Counters - Devices of compute capability ......Note Access Counters are curre...",
    "content": "# 22.1.8. Access Counters\nDevices of compute capability 7.0 introduce a new Access Counter feature that keeps track of the frequency of access that a GPU makes to memory located on other processors. Access Counters help ensure memory pages are moved to the physical memory of the processor that is accessing the pages most frequently. The Access Counters feature can guide migrations between CPU and GPU, and between peer GPUs.\n\nFor cudaMallocManaged, Access Counters migration can be opt- in by using cudaMemAdviseSetAccessedBy hint with the corresponding device id. The driver may also use Access Counters for more efficient thrashing mitigation or memory oversubscription scenarios.\n\nNote: Access Counters are currently enabled only on IBM Power9 systems and only for the cudaMallocManaged allocator."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2. Programming Model",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.1. Managed Memory Opt In - Most platforms require a progr......Devices of compute capability ...",
    "content": "Most platforms require a program to opt in to automatic data management by either annotating a __device__ variable with the __managed__ keyword (see the Language Integration section) or by using a new cudaMallocManaged() call to allocate data.\n\nDevices of compute capability lower than 6. x must always allocate managed memory on the heap, either with an allocator or by declaring global storage. It is not possible either to associate previously allocated memory with Unified Memory, or to have the Unified Memory system manage a CPU or a GPU stack pointer."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.1. Managed Memory Opt In - Starting with CUDA 80 and on s...",
    "content": "Starting with CUDA 8.0 and on supporting systems with devices of compute capability 6. x, memory allocated with the default OS allocator (e.g. malloc or new) can be accessed from both GPU code and CPU code using the same pointer. On these systems, Unified Memory is the default: there is no need to use a special allocator or the creation of a specially managed memory pool."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.1.1 Explicit Allocation Using cudaMallocManaged() - Unified memory is most commonl......cudaErrort cudaMallocManagedvo...",
    "content": "Unified memory is most commonly created using an allocation function that is semantically and syntactically similar to the standard CUDA allocator, cudaMalloc(). The function description is as follows:\n\ncudaError_t cudaMallocManaged(void \\*\\*devPtr, size_t size, unsigned int flags  $= \\Theta$  );"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.1.1 Explicit Allocation Using cudaMallocManaged() - The cudaMallocManaged function...",
    "content": "The cudaMallocManaged() function reserves size bytes of managed memory and returns a pointer in devPtr. Note the difference in cudaMallocManaged() behavior between various GPU architectures. By default, the devices of compute capability lower than 6. x allocate managed memory directly on the GPU. However, the devices of compute capability 6. x and greater do not allocate physical memory when calling cudaMallocManaged(): in this case physical memory is populated on first touch and may be resident on the CPU or the GPU. The managed pointer is valid on all GPUs and the CPU in the"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.1.1 Explicit Allocation Using cudaMallocManaged() - system although program access......cppglobal void printmechar str...",
    "content": "system, although program accesses to this pointer must obey the concurrency rules of the Unified Memory programming model (see Coherency and Concurrency). Below is a simple example, showing the use of cudaMallocManaged():\n\n```cpp__global__ void printme(char *str) {    printf(str);}int main() {    // Allocate 100 bytes of memory, accessible to both Host and Device code    char *s;    cudaMallocManaged(&s, 100);    // Note direct Host- code use of \"s\"    strncpy(s, \"Hello Unified Memory\\n\", 99);    // Here we pass \"s\" to a kernel without explicitly copying    printme<<< 1, 1>>>(s);    cudaDeviceSynchronize();    // Free as for normal CUDA allocations    cudaFree(s);    return 0;}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.1.1 Explicit Allocation Using cudaMallocManaged() - A programs behavior is functio......Device code is not able to cal...",
    "content": "A program's behavior is functionally unchanged when cudaMalloc() is replaced with cudaMallocManaged(); however, the program should go on to eliminate explicit memory copies and take advantage of automatic migration. Additionally, dual pointers (one to host and one to device memory) can be eliminated.\n\nDevice code is not able to call cudaMallocManaged(). All managed memory must be allocated from the host or at global scope (see the next section). Allocations on the device heap using malloc() in a kernel will not be created in the managed memory space, and so will not be accessible to CPU code."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.1.2 Global-Scope Managed Variables Using __managed__ - File scope and global scope CU......All semantics of the original ...",
    "content": "File- scope and global- scope CUDA __device__ variables may also opt- in to Unified Memory management by adding a new __managed__ annotation to the declaration. These may then be referenced directly from either host or device code, as follows:\n\n```cpp__device__ __managed__ int x[2];__device__ __managed__ int y;__global__ void kernel() {    x[1] = x[0] + y;}int main() {    x[0] = 3;    y = 5;    kernel<<< 1, 1>>>();    cudaDeviceSynchronize();    printf(\"result = %d\\n\", x[1]);    return 0;}```\n\nAll semantics of the original __device__ memory space, along with some additional unified- memory- specific constraints, are inherited by the managed variable (see Compilation with NVCC)."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.1.2 Global-Scope Managed Variables Using __managed__ - Note that variables marked con...",
    "content": "Note that variables marked __constant__ may not also be marked as __managed__; this annotation is reserved for __device__ variables only. Constant memory must be set either statically at compile time or by using cuda memcpyToSymbol() as usual in CUDA."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2. Coherency and Concurrency - 2222 Coherency and Concurrency...",
    "content": "# 22.2.2. Coherency and Concurrency\n22.2.2. Coherency and ConcurrencySimultaneous access to managed memory on devices of compute capability lower than 6. x is not possible, because coherence could not be guaranteed if the CPU accessed a Unified Memory allocation while a GPU kernel was active. However, devices of compute capability 6. x on supporting operating systems allow the CPUs and GPUs to access Unified Memory allocations simultaneously via the new page faulting mechanism. A program can query whether a device supports concurrent access to managed memory by checking a new concurrentManagedAccess property. Note, as with any parallel application, developers need to ensure correct synchronization to avoid data hazards between processors."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.1 GPU Exclusive Access To Managed Memory - To ensure coherency on pre 6 x...",
    "content": "To ensure coherency on pre- 6. x GPU architectures, the Unified Memory programming model puts constraints on data accesses while both the CPU and GPU are executing concurrently. In effect, the GPU has exclusive access to all managed data while any kernel operation is executing, regardless of whether the specific kernel is actively using the data. When managed data is used with cudaMempcy\\*() or cudaMemset\\*(), the system may choose to access the source or destination from the host or the device, which will put constraints on concurrent CPU access to that data while the cudaMempcy\\*() or cudaMemset\\*() is executing. See Memcpy()/Memset() Behavior With Managed Memory for further details."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.1 GPU Exclusive Access To Managed Memory - It is not permitted for the CP......device managed int x  y  2   g...",
    "content": "It is not permitted for the CPU to access any managed allocations or variables while the GPU is active for devices with concurrentManagedAccess property set to 0. On these systems concurrent CPU/GPU accesses, even to different managed memory allocations, will cause a segmentation fault because the page is considered inaccessible to the CPU.\n\ndevice__ managed__ int x,  $y = 2$  . global__ void kernel() {  $\\texttt{x} = \\texttt{10}$  } int main() { kernel<< 1, 1 >>>();  $\\texttt{y} = \\texttt{20}$  // Error on GPUs not supporting concurrent access cudaDeviceSynchronize(); return 0; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.1 GPU Exclusive Access To Managed Memory - In example above the GPU progr......device managed int x  y  2   g...",
    "content": "In example above, the GPU program kernel is still active when the CPU touches y. (Note how it occurs before cudaDeviceSynchronize(). The code runs successfully on devices of compute capability 6. x due to the GPU page faulting capability which lifts all restrictions on simultaneous access. However, such memory access is invalid on pre- 6. x architectures even though the CPU is accessing different data than the GPU. The program must explicitly synchronize with the GPU before accessing y:\n\ndevice__ managed__ int x,  $y = 2$  . global__ void kernel() {  $\\texttt{x} = \\texttt{10}$  } int main() { kernel<< 1, 1 >>>(); cudaDeviceSynchronize();  $\\texttt{y} = \\texttt{20}$  // Success on GPUs not supporing concurrent access return 0; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.1 GPU Exclusive Access To Managed Memory - As this example shows on syste...",
    "content": "As this example shows, on systems with pre- 6. x GPU architectures, a CPU thread may not access any managed data in between performing a kernel launch and a subsequent synchronization call, regardless of whether the GPU kernel actually touches that same data (or any managed data at all). The mere potential for concurrent CPU and GPU access is sufficient for a process- level exception to be raised."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.1 GPU Exclusive Access To Managed Memory - Note that if memory is dynamic...",
    "content": "Note that if memory is dynamically allocated with cudaMallocManaged() or cuMemAllocManaged() while the GPU is active, the behavior of the memory is unspecified until additional work is launched or the GPU is synchronized. Attempting to access the memory on the CPU during this time may or may not cause a segmentation fault. This does not apply to memory allocated using the flag cudaMemAttachHost or CU_MEM_ATTACH_HOST."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.2 Explicit Synchronization and Logical GPU Activity - Note that explicit synchroniza...",
    "content": "Note that explicit synchronization is required even if kernel runs quickly and finishes before the CPU touches y in the above example. Unified Memory uses logical activity to determine whether the GPU is idle. This aligns with the CUDA programming model, which specifies that a kernel can run at any time following a launch and is not guaranteed to have finished until the host issues a synchronization call."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.2 Explicit Synchronization and Logical GPU Activity - Any function call that logical......Dependencies created between s...",
    "content": "Any function call that logically guarantees the GPU completes its work is valid. This includes cudaDeviceSynchronize(); cudaStreamSynchronize() and cudaStreamQuery() (provided it returns cudaSuccess and not cudaErrorNotReady) where the specified stream is the only stream still executing on the GPU; cudaEventSynchronize() and cudaEventQuery() in cases where the specified event is not followed by any device work; as well as uses of cudaMemcopy() and cudaMemset() that are documented as being fully synchronous with respect to the host.\n\nDependencies created between streams will be followed to infer completion of other streams by synchronizing on a stream or event. Dependencies can be created via cudaStreamWaitEvent() or implicitly when using the default (NULL) stream."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.2 Explicit Synchronization and Logical GPU Activity - It is legal for the CPU to acc......There are several important po...",
    "content": "It is legal for the CPU to access managed data from within a stream callback, provided no other stream that could potentially be accessing managed data is active on the GPU. In addition, a callback that is not followed by any device work can be used for synchronization: for example, by signaling a condition variable from inside the callback; otherwise, CPU access is valid only for the duration of the callback(s).\n\nThere are several important points of note:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.2 Explicit Synchronization and Logical GPU Activity - It is always permitted for the......There are no constraints on co...",
    "content": "- It is always permitted for the CPU to access non-managed zero-copy data while the GPU is active.  \n- The GPU is considered active when it is running any kernel, even if that kernel does not make use of managed data. If a kernel might use data, then access is forbidden, unless device property concurrentManagedAccess is 1.  \n- There are no constraints on concurrent inter-GPU access of managed memory, other than those that apply to multi-GPU access of non-managed memory.  \n- There are no constraints on concurrent GPU kernels accessing managed data."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.2 Explicit Synchronization and Logical GPU Activity - int main  cudaStreamt stream1 ......continues on next page",
    "content": "Note how the last point allows for races between GPU kernels, as is currently the case for non- managed GPU memory. As mentioned previously, managed memory functions identically to non- managed memory from the perspective of the GPU. The following code example illustrates these points:\n\nint main() { cudaStream_t stream1, stream2; cudaStreamCreate(&stream1); cudaStreamCreate(&stream2); int *nonManaged, *managed, *alsoManaged; cudaMallocHost(&nonManaged, 4); // Non- managed, CPU- accessible memory cudaMallocManaged(&managed, 4);\n\n(continues on next page)"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.2 Explicit Synchronization and Logical GPU Activity - cudaMallocManagedalsoManaged 4...",
    "content": "cudaMallocManaged(&alsoManaged, 4); // Point 1: CPU can access non- managed data. kernel  $\\epsilon < < <$  1,1,0, stream1  $\\geq \\geq \\geq$  (managed); \\*nonManaged  $= 1$  . // Point 2: CPU cannot access any managed data while GPU is busy, // unless concurrentManagedAccess  $= 1$  // Note we have not yet synchronized, so kernel\" is still active. \\*alsoManaged  $= 2$  // Will issue segmentation fault // Point 3: Concurrent GPU kernels can access the same data. kernel  $\\epsilon < < <$  1,1,0, stream2  $\\geq \\geq \\geq$  (managed); // Point 4: Multi- GPU concurrent access is also permitted. cudaSetDevice(1); kernel  $\\epsilon < < <$  1,1  $\\geq \\geq \\geq$  (managed); return 0; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.3 Managing Data Visibility and Concurrent CPU + GPU Access with Streams - Until now it was assumed that ...",
    "content": "Until now it was assumed that for SM architectures before 6. x: 1) any active kernel may use any managed memory, and 2) it was invalid to use managed memory from the CPU while a kernel is active. Here we present a system for finer- grained control of managed memory designed to work on all devices supporting managed memory, including older architectures with concurrentManagedAccess equal to 0."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.3 Managing Data Visibility and Concurrent CPU + GPU Access with Streams - The CUDA programming model pro...",
    "content": "The CUDA programming model provides streams as a mechanism for programs to indicate dependence and independence among kernel launches. Kernels launched into the same stream are guaranteed to execute consecutively, while kernels launched into different streams are permitted to execute concurrently. Streams describe independence between work items and hence allow potentially greater efficiency through concurrency."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.3 Managing Data Visibility and Concurrent CPU + GPU Access with Streams - Unified Memory builds upon the......cudaErrort cudaStreamAttachMem...",
    "content": "Unified Memory builds upon the stream- independence model by allowing a CUDA program to explicitly associate managed allocations with a CUDA stream. In this way, the programmer indicates the use of data by kernels based on whether they are launched into a specified stream or not. This enables opportunities for concurrency based on program- specific data access patterns. The function to control this behavior is:\n\ncudaError_t cudaStreamAttachMemAsync(cudaStream_t stream, void *ptr, size_t length=0, unsigned int flags=0);"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.3 Managing Data Visibility and Concurrent CPU + GPU Access with Streams - The cudaStreamAttachMemAsync f...",
    "content": "The cudaStreamAttachMemAsync() function associates length bytes of memory starting from ptr with the specified stream. (Currently, length must always be 0 to indicate that the entire region should be attached.) Because of this association, the Unified Memory system allows CPU access to this memory region so long as all operations in stream have completed, regardless of whether other streams are active. In effect, this constrains exclusive ownership of the managed memory region by an active GPU to per- stream activity instead of whole- GPU activity."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.3 Managing Data Visibility and Concurrent CPU + GPU Access with Streams - Most importantly if an allocat......system it is the programmers r...",
    "content": "Most importantly, if an allocation is not associated with a specific stream, it is visible to all running kernels regardless of their stream. This is the default visibility for a cudaMallocManaged() allocation or a __managed__ variable; hence, the simple- case rule that the CPU may not touch the data while any kernel is running.\n\nBy associating an allocation with a specific stream, the program makes a guarantee that only kernels launched into that stream will touch that data. No error checking is performed by the Unified Memory\n\nsystem: it is the programmer's responsibility to ensure that guarantee is honored."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.3 Managing Data Visibility and Concurrent CPU + GPU Access with Streams - In addition to allowing greate...",
    "content": "In addition to allowing greater concurrency, the use of cudaStreamAttachMemAsync() can (and typically does) enable data transfer optimizations within the Unified Memory system that may affect latencies and other overhead."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.4 Stream Association Examples - Associating data with a stream......device managed int x  y  2   g...",
    "content": "Associating data with a stream allows fine- grained control over CPU + GPU concurrency, but what data is visible to which streams must be kept in mind when using devices of compute capability lower than 6. x. Looking at the earlier synchronization example:\n\ndevice__ _managed__ int x,  $y = 2$  . global__ void kernel() {  $\\texttt{x} = \\texttt{10}$  } int main() { cudaStream_t stream1; cudaStreamCreate(&stream1); cudaStreamAttachMemAsync(stream1, &y, 0, cudaMemAttachHost); cudaDeviceSynchronize(); // Wait for Host attachment to occur. kernel  $\\epsilon \\epsilon \\epsilon \\epsilon$  1,1,0, stream1 >>>(); // Note: Launches into stream1.  $y = 20$  // Success - a kernel is running but \"y\" // has been associated with no stream. return 0; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.4 Stream Association Examples - Here we explicitly associate y......Note that associating a variab...",
    "content": "Here we explicitly associate y with host accessibility, thus enabling access at all times from the CPU. (As before, note the absence of cudaDeviceSynchronize() before the access.) Accesses to y by the GPU running kernel will now produce undefined results.\n\nNote that associating a variable with a stream does not change the associating of any other variable. E.g. associating x with stream1 does not ensure that only x is accessed by kernels launched in stream1, thus an error is caused by this code:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.4 Stream Association Examples - device managed int x  y  2   g......Note how the access to y will ...",
    "content": "device__ _managed__ int x,  $y = 2$  . global__ void kernel() {  $\\texttt{x} = \\texttt{10}$  } int main() { cudaStream_t stream1; cudaStreamCreate(&stream1); cudaStreamAttachMemAsync(stream1, &x); // Associate \"x\" with stream1. cudaDeviceSynchronize(); // Wait for \"x\" attachment to occur. kernel  $\\epsilon \\epsilon \\epsilon \\epsilon$  1,1,0, stream1 >>>(); // Note: Launches into stream1.  $y = 20$  // ERROR: \"y\" is still associated globally // with all streams by default return 0; }\n\nNote how the access to y will cause an error because, even though x has been associated with a stream, we have told the system nothing about who can see y. The system therefore conservatively assumes that kernel might access it and prevents the CPU from doing so."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.5 Stream Attach With Multithreaded Host Programs - The primary use for cudaStream......Such a program would simply ad...",
    "content": "The primary use for cudaStreamAttachMemAsync() is to enable independent task parallelism using CPU threads. Typically in such a program, a CPU thread creates its own stream for all work that it generates because using CUDA's NULL stream would cause dependencies between threads.\n\nThe default global visibility of managed data to any GPU stream can make it difficult to avoid interactions between CPU threads in a multi- threaded program. Function cudaStreamAttachMemAsync() is therefore used to associate a thread's managed allocations with that thread's own stream, and the association is typically not changed for the life of the thread.\n\nSuch a program would simply add a single call to cudaStreamAttachMemAsync() to use unified memory for its data accesses:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.5 Stream Attach With Multithreaded Host Programs - This function performs some ta...",
    "content": "// This function performs some task, in its own private stream. void run_task(int \\*in, int \\*out, int length) { // Create a stream for us to use. cudaStream_t stream; cudaStreamCreate(&stream); // Allocate some managed data and associate with our stream. // Note the use of the host- attach flag to cudaMallocManaged(); // we then associate the allocation with our stream so that // our GPU kernel launches can access it. int \\*data; cudaMallocManaged((void \\*\\*)&data, length, cudaMemAttachHost); cudaStreamAttachMemAsync(stream, data); cudaStreamSynchronize(stream); // Iterate on the data in some way, using both Host & Device."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.5 Stream Attach With Multithreaded Host Programs - forint  dot1  Theta    dot1  m...",
    "content": " for(int  $\\dot{1} = \\Theta$  ;  $\\dot{1} = \\mathbb{N}$  ;  $\\dot{1} ++$  ){ transform  $\\scriptstyle \\epsilon = \\epsilon$  100, 256, 0, stream  $> > > ($  in, data, length); cudaStreamSynchronize(stream); host_process(data, length); // CPU uses managed data. convert  $\\epsilon = \\epsilon$  100, 256, 0, stream  $> > > ($  out, data, length); } cudaStreamSynchronize(stream); cudaStreamDestroy(stream); cudaFree(data); }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.5 Stream Attach With Multithreaded Host Programs - In this example the allocation...",
    "content": "In this example, the allocation- stream association is established just once, and then data is used repeatedly by both the host and device. The result is much simpler code than occurs with explicitly copying data between host and device, although the result is the same."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.6 Advanced Topic: Modular Programs and Data Access Constraints - In the previous example cudaMa...",
    "content": "In the previous example cudaMallocManaged() specifies the cudaMemAttachHost flag, which creates an allocation that is initially invisible to device- side execution. (The default allocation would be visible to all GPU kernels on all streams.) This ensures that there is no accidental interaction with another thread's execution in the interval between the data allocation and when the data is acquired for a specific stream."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.6 Advanced Topic: Modular Programs and Data Access Constraints - Without this flag a new alloca...",
    "content": "Without this flag, a new allocation would be considered in- use on the GPU if a kernel launched by another thread happens to be running. This might impact the thread's ability to access the newly allocated data from the CPU (for example, within a base- class constructor) before it is able to explicitly attach it to a private stream. To enable safe independence between threads, therefore, allocations should be made specifying this flag."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.6 Advanced Topic: Modular Programs and Data Access Constraints - Note An alternative would be t...",
    "content": "Note: An alternative would be to place a process- wide barrier across all threads after the allocation has been attached to the stream. This would ensure that all threads complete their data/stream associations before any kernels are launched, avoiding the hazard. A second barrier would be needed before the stream is destroyed because stream destruction causes allocations to revert to their default visibility. The cudaMemAttachHost flag exists both to simplify this process, and because it is not always possible to insert global barriers where required."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.7 Memcopy()/Memset() Behavior With Managed Memory - Since managed memory can be ac......If cudaMemcopyHostTo is specif...",
    "content": "Since managed memory can be accessed from either the host or the device, cudaMemcopy*() relies on the type of transfer, specified using cudaMemcopyKind, to determine whether the data should be accessed as a host pointer or a device pointer.\n\nIf cudaMemcopyHostTo* is specified and the source data is managed, then it will be accessed from the host if it is coherently accessible from the host in the copy stream (1); otherwise it will be accessed from the device. Similar rules apply to the destination when cudaMemcopy*ToHost is specified and the destination is managed memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.7 Memcopy()/Memset() Behavior With Managed Memory - If cudaMemcopyDeviceTo is spec......If cudaMemcopyDefault is speci...",
    "content": "If cudaMemcopyDeviceTo* is specified and the source data is managed, then it will be accessed from the device. The source must be coherently accessible from the device in the copy stream (2); otherwise, an error is returned. Similar rules apply to the destination when cudaMemcopy*ToDevice is specified and the destination is managed memory.\n\nIf cudaMemcopyDefault is specified, then managed data will be accessed from the host either if it cannot be coherently accessed from the device in the copy stream (2) or if the preferred location for the data is cudaCpuDeviceId and it can be coherently accessed from the host in the copy stream (1); otherwise, it will be accessed from the device."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.7 Memcopy()/Memset() Behavior With Managed Memory - When using cudaMemset with man......When data is accessed from the...",
    "content": "When using cudaMemset*() with managed memory, the data is always accessed from the device. The data must be coherently accessible from the device in the stream being used for the cudaMemset() operation (2); otherwise, an error is returned.\n\nWhen data is accessed from the device either by cudaMemcopy* or cudaMemset*, the stream of operation is considered to be active on the GPU. During this time, any CPU access of data that is associated with that stream or data that has global visibility, will result in a segmentation fault if the GPU has a zero value for the device attribute concurrentManagedAccess. The program must synchronize appropriately to ensure the operation has completed before accessing any associated data from the CPU."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.2.7 Memcopy()/Memset() Behavior With Managed Memory - 1 For managed memory to be coh......2 For managed memory to be coh...",
    "content": "(1) For managed memory to be coherently accessible from the host in a given stream, at least one of the following conditions must be satisfied. The given stream is associated with a device that has a non-zero value for the device attribute concurrentManagedAccess. The memory neither has global visibility nor is it associated with the given stream. \n(2) For managed memory to be coherently accessible from the device in a given stream, at least one of the following conditions must be satisfied. The device has a non-zero value for the device attribute concurrentManagedAccess. The memory either has global visibility or is associated with the given stream."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.3. Language Integration - Users of the CUDA Runtime API ......The following example seen ear...",
    "content": "Users of the CUDA Runtime API who compile their host code using nvcc have access to additional language integration features, such as shared symbol names and inline kernel launch via the  $< < < \\ldots$ $> > > >$  operator. Unified Memory adds one additional element to CUDA's language integration: variables annotated with the __managed__ keyword can be referenced directly from both host and device code.\n\nThe following example, seen earlier in Simplifying GPU Programming, illustrates a simple use of __managed__ global declarations:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.3. Language Integration - Managed variable declaration i...",
    "content": "// Managed variable declaration is an extra annotation with __device__- __device__ __managed__ int x; - - global__ void kernel(){ // Reference \"x\" directly - it's a normal variable on the GPU. printf(\"GPU sees:  $\\texttt{x} = \\% \\texttt{d}\\texttt{n}^{\\prime \\prime}$  ,x); } int main(){ // Set \"x\" from Host code. Note it's just a normal variable on the CPU.  $x = 1234$  . // Launch a kernel which uses \"x\" from the GPU. kernel  $\\leq \\leq \\leq 1$  1  $> > > > ($  cudaDeviceSynchronize(); return 0; }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.3. Language Integration - The capability available with ......Semantically the behavior of m...",
    "content": "The capability available with __managed__ variables is that the symbol is available in both device code and in host code without the need to dereference a pointer, and the data is shared by all. This makes it particularly easy to exchange data between host and device programs without the need for explicit allocations or copying.\n\nSemantically, the behavior of __managed__ variables is identical to that of storage allocated via cudaMallocManaged(). See Explicit Allocation Using cudaMallocManaged() for detailed explanation. Stream visibility defaults to cudaMemAttachGlobal, but may be constrained using cudaStreamAttachMemAsync()."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.3. Language Integration - A valid CUDA context is necess......mathttC     objects declared a...",
    "content": "A valid CUDA context is necessary for the correct operation of __managed__ variables. Accessing __managed__ variables can trigger CUDA context creation if a context for the current device hasn't already been created. In the example above, accessing x before the kernel launch triggers context creation on device 0. In the absence of that access, the kernel launch would have triggered context creation.\n\n$\\mathtt{C + + }$  objects declared as __managed__ are subject to certain specific constraints, particularly where static initializers are concerned. Please refer to  $\\mathtt{C + + }$  Language Support in the CUDA  $\\mathtt{C + + }$  Programming Guide for a list of these constraints."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.3.1 Host Program Errors with __managed__ Variables - The use of managed variables d......When CUDA specific operations ...",
    "content": "# 22.2.3.1 Host Program Errors with __managed__ Variables\nThe use of __managed__ variables depends upon the underlying Unified Memory system functioning correctly. Incorrect functioning can occur if, for example, the CUDA installation failed or if the CUDA context creation was unsuccessful.\n\nWhen CUDA- specific operations fail, typically an error is returned that indicates the source of the failure. Using __managed__ variables introduces a new failure mode whereby a non- CUDA operation (for example, CPU access to what should be a valid host memory address) can fail if the Unified Memory system is not operating correctly. Such invalid memory accesses cannot easily be attributed to the underlying CUDA subsystem, although a debugger such as cuda- gdb will indicate that a managed memory address is the source of the failure."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.4. Querying Unified Memory Support",
    "content": ""
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.4.1 Device Properties - Unified Memory is supported on......Either property will be set to...",
    "content": "Unified Memory is supported only on devices with compute capability 3.0 or higher. A program may query whether a GPU device supports managed memory by using cudaGetDeviceProperties() and checking the new managedMemory property. The capability can also be determined using the individual attribute query function cudaDeviceGetAttribute() with the attribute cudaDevAttrManagedMemory.\n\nEither property will be set to 1 if managed memory allocations are permitted on the GPU and under the current operating system. Note that Unified Memory is not supported for 32- bit applications (unless on Android), even if a GPU is of sufficient capability."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.4.1 Device Properties - Devices of compute capability ......With the new page fault mechan...",
    "content": "Devices of compute capability 6. x on supporting platforms can access pageable memory without calling cudaHostRegister on it. An application can query whether the device supports coherently accessing pageable memory by checking the new pageableMemoryAccess property.\n\nWith the new page fault mechanism, global data coherency is guaranteed with Unified Memory. This means that the CPUs and GPUs can access Unified Memory allocations simultaneously. This was illegal on devices of compute capability lower than 6. x, because coherence could not be guaranteed if the CPU accessed a Unified Memory allocation while a GPU kernel was active. A program can query concurrent access support by checking concurrentManagedAccess property. See Coherency and Concurrency for details."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.5. Advanced Topics - To determine if a given pointe...",
    "content": "To determine if a given pointer refers to managed memory, a program can call cudaPointerGetAttributes() and check the value of the isManaged attribute. This attribute is set to 1 if the pointer refers to managed memory and to 0 if not.\n\n# 22.2.5. Advanced Topics\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.5.1 Managed Memory with Multi-GPU Programs on pre-6.x Architectures - On systems with devices of com......On Linux the managed memory is...",
    "content": "On systems with devices of compute capabilities lower than 6. x managed allocations are automatically visible to all GPUs in a system via the peer- to- peer capabilities of the GPUs.\n\nOn Linux the managed memory is allocated in GPU memory as long as all GPUs that are actively being used by a program have the peer- to- peer support. If at any time the application starts using a GPU that doesn't have peer- to- peer support with any of the other GPUs that have managed allocations on them, then the driver will migrate all managed allocations to system memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.5.1 Managed Memory with Multi-GPU Programs on pre-6.x Architectures - On Windows if peer mappings ar...",
    "content": "On Windows if peer mappings are not available (for example, between GPUs of different architectures), then the system will automatically fall back to using zero- copy memory, regardless of whether both GPUs are actually used by a program. If only one GPU is actually going to be used, it is necessary to set the CUDA_VISIBLE_DEVICES environment variable before launching the program. This constrains which GPUs are visible and allows managed memory to be allocated in GPU memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.5.1 Managed Memory with Multi-GPU Programs on pre-6.x Architectures - Alternatively on Windows users...",
    "content": "Alternatively, on Windows users can also set CUDA_MANAGED_FORCE_DEVICE_ALLOC to a non- zero value to force the driver to always use device memory for physical storage. When this environment variable is set to a non- zero value, all devices used in that process that support managed memory have to be peer- to- peer compatible with each other. The error : : cudaErrorInvalidDevice will be returned if a device that supports managed memory is used and it is not peer- to- peer compatible with any of the other managed memory supporting devices that were previously used in that process, even if : : cudaDeviceReset has been called on those devices. These environment variables are described in CUDA Environment Variables. Note that starting from CUDA 8."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.5.1 Managed Memory with Multi-GPU Programs on pre-6.x Architectures - 0 CUDAMANAGEDFORCEDEVICEALLOC ...",
    "content": "0 CUDA_MANAGED_FORCE_DEVICE_ALLOC has no effect on Linux operating systems."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.2.5.2 Using fork() with Managed Memory - The Unified Memory system does......It is safe however to fork  a ...",
    "content": "# 22.2.5.2 Using fork() with Managed Memory\nThe Unified Memory system does not allow sharing of managed memory pointers between processes. It will not correctly manage memory handles that have been duplicated via a fork () operation. Results will be undefined if either the child or parent accesses managed data following a fork ().\n\nIt is safe, however, to fork () a child process that then immediately exits via an exec () call, because the child drops the memory handles and the parent becomes the sole owner once again. It is not safe for the parent to exit and leave the child to access the handles."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3. Performance Tuning - In order to achieve good perfo...",
    "content": "In order to achieve good performance with Unified Memory, the following objectives must be met:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3. Performance Tuning - Faults should be avoided While...",
    "content": "Faults should be avoided: While replayable faults are fundamental to enabling a simpler programming model, they can be severely detrimental to application performance. Fault handling can take tens of microseconds because it may involve TLB invalidates, data migrations and page table updates. All the while, execution in certain portions of the application will be halted, thereby potentially impacting overall performance. Data should be local to the accessing processor: As mentioned before, memory access latencies and bandwidth are significantly better when the data is placed local to the processor accessing it. Therefore, data should be suitably migrated to take advantage of lower latencies and higher bandwidth."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3. Performance Tuning - Memory thrashing should be pre...",
    "content": "Memory thrashing should be prevented: If data is frequently accessed by multiple processors and has to be constantly migrated around to achieve data locality, then the overhead of migration may exceed the benefits of locality. Memory thrashing should be prevented to the extent possible. If it cannot be prevented, it must be detected and resolved appropriately."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3. Performance Tuning - To achieve the same level of p...",
    "content": "To achieve the same level of performance as what's possible without using Unified Memory, the application has to guide the Unified Memory driver subsystem into avoiding the aforementioned pitfalls. It is worthy to note that the Unified Memory driver subsystem can detect common data access patterns and achieve some of these objectives automatically without application participation. But when the data access patterns are non- obvious, explicit guidance from the application is crucial. CUDA 8.0 introduces useful APIs for providing the runtime with memory usage hints (cudaMemAdvise()) and for explicit prefetching (cudaMemPrefetchAsync()). These tools allow the same capabilities as explicit memory copy and pinning APIs without reverting to the limitations of explicit GPU memory allocation."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3. Performance Tuning - Note cudaMemPrefetchAsync is n...",
    "content": "Note: cudaMemPrefetchAsync() is not supported on Tegra devices."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3.1. Data Prefetching - Data prefetching means migrati...",
    "content": "Data prefetching means migrating data to a processor's memory and mapping it in that processor's page tables before the processor begins accessing that data. The intent of data prefetching is to avoid faults while also establishing data locality. This is most valuable for applications that access data primarily from a single processor at any given time. As the accessing processor changes during the lifetime of the application, the data can be prefetched accordingly to follow the execution flow of the application. Since work is launched in streams in CUDA, it is expected of data prefetching to also be a streamed operation as shown in the following API:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3.1. Data Prefetching - tabletrtdcudaErrort cudaMemPre......Consider a simple code example...",
    "content": "<table><tr><td>cudaError_t cudaMemPrefetchAsync(const void *devPtr, \n  size_t count, \n  int dstDevice, \n  cudaStream_t stream);</td></tr></table>\n\nwhere the memory region specified by devPtr pointer and count number of bytes, with ptr rounded down to the nearest page boundary and count rounded up to the nearest page boundary, is migrated to the dstDevice by enqueueing a migration operation in stream. Passing in cudaCpuDeviceId for dstDevice will cause data to be migrated to CPU memory.\n\nConsider a simple code example below:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3.1. Data Prefetching - void foocudaStreamt s  char da......Without performance hints the ...",
    "content": "void foo(cudaStream_t s) { char \\*data; cudaMallocManaged(&data, N); init_data(data, N); // execute on CPU cudaMemPrefetchAsync(data, N, myGpuId, s); // prefetch to GPU mykernel  $\\epsilon < <$  ..s  $\\geq \\geq \\geq$  (data, N, 1, compare); // execute on GPU cudaMemPrefetchAsync(data, N, cudaCpuDeviceId, s); // prefetch to CPU cudaStreamSynchronize(s); use_data(data, N); cudaFree(data); }\n\nWithout performance hints the kernel mykernel will fault on first access to data which creates additional overhead of the fault processing and generally slows down the application. By prefetching data in advance it is possible to avoid page faults and achieve better performance."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3.1. Data Prefetching - This API follows stream orderi...",
    "content": "This API follows stream ordering semantics, i.e. the migration does not begin until all prior operations in the stream have completed, and any subsequent operation in the stream does not begin until the migration has completed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3.2. Data Usage Hints - Data prefetching alone is insu......where advice specified for dat...",
    "content": "Data prefetching alone is insufficient when multiple processors need to simultaneously access the same data. In such scenarios, it's useful for the application to provide hints on how the data will actually be used. The following advisory API can be used to specify data usage:\n\ncudaError_t cudaMemAdvise(const void *devPtr, size_t count, enum cudaMemoryAdvise advice, int device);\n\nwhere advice, specified for data contained in region starting from devPtr address and with the length of count bytes, rounded to the nearest page boundary, can take the following values:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3.2. Data Usage Hints - cudaMemAdviseSetReadMostly Thi...",
    "content": "- cudaMemAdviseSetReadMostly: This implies that the data is mostly going to be read from and only occasionally written to. This allows the driver to create read-only copies of the data in a processor's memory when that processor accesses it. Similarly, if cudaMemPrefetchAsync is called on this region, it will create a read-only copy of the data on the destination processor. When a processor writes to this data, all copies of the corresponding page are invalidated except for the one where the write occurred. The device argument is ignored for this advice. This advice allows multiple processors to simultaneously access the same data at maximal bandwidth as illustrated in the following code snippet:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3.2. Data Usage Hints - char dataPtr sizet dataSize   ...",
    "content": "char \\*dataPtr; size_t dataSize  $=$  4096; // Allocate memory using malloc or cudaMallocManaged dataPtr  $=$  char \\*)malloc(dataSize); // Set the advice on the memory region cudaMemAdvise(dataPtr, dataSize, cudaMemAdviseSetReadMostly, 0); int outerLoopIter  $= \\theta$  . while (outerLoopIter  $<$  maxOuterLoopIter) { // The data is written to in the outer loop on the CPU initializeData(dataPtr, dataSize); // The data is made available to all GPUs by prefetching. // Prefetching here causes read duplication of data instead // of data migration for (int device  $= \\theta$  ; device  $<$  maxDevices; device++) { cudaMemPrefetchAsync(dataPtr, dataSize, device, stream); } // The kernel only reads this data in the inner loop int innerLoopIter  $= \\theta$  ."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3.2. Data Usage Hints - while innerLoopIter    maxInne...",
    "content": " while (innerLoopIter  $<$  maxInnerLoopIter) { kernel  $< < < 32$ $32 > > > >$  (const char \\*)dataPtr); innerLoopIter  $^{+ + }$  . } outerLoopIter  $^{+ + }$  . }"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3.2. Data Usage Hints - cudaMemAdviseSetPreferredLocat...",
    "content": "- cudaMemAdviseSetPreferredLocation: This advice sets the preferred location for the data to be the memory belonging to device. Passing in a value of cudaCpuDeviceId for device sets the preferred location as CPU memory. Setting the preferred location does not cause data to mi-"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3.2. Data Usage Hints - grate to that location immedia...",
    "content": "grate to that location immediately. Instead, it guides the migration policy when a fault occurs on that memory region. If the data is already in its preferred location and the faulting processor can establish a mapping without requiring the data to be migrated, then the migration will be avoided. On the other hand, if the data is not in its preferred location or if a direct mapping cannot be established, then it will be migrated to the processor accessing it. It is important to note that setting the preferred location does not prevent data prefetching done using cudaMemPrefetchAsync."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3.2. Data Usage Hints - cudaMemAdviseSetAccessedBy Thi...",
    "content": "- cudaMemAdviseSetAccessedBy: This advice implies that the data will be accessed by device. This does not cause data migration and has no impact on the location of the data per se. Instead, it causes the data to always be mapped in the specified processor's page tables, as long as the location of the data permits a mapping to be established. If the data gets migrated for any reason, the mappings are updated accordingly. This advice is useful in scenarios where data locality is not important, but avoiding faults is. Consider for example a system containing multiple GPUs with peer-to-peer access enabled, where the data located on one GPU is occasionally accessed by other GPUs."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3.2. Data Usage Hints - In such scenarios migrating da...",
    "content": " In such scenarios, migrating data over to the other GPUs is not as important because the accesses are infrequent and the overhead of migration may be too high. But preventing faults can still help improve performance, and so having a mapping set up in advance is useful. Note that on CPU access of this data, the data may be migrated to CPU memory because the CPU cannot access GPU memory directly. Any GPU that had the cudaMemAdviseSetAccessedBy flag set for this data will now have its mapping updated to point to the page in CPU memory."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3.2. Data Usage Hints - Each advice can be also unset ...",
    "content": "Each advice can be also unset by using one of the following values: cudaMemAdviseUnsetRead- Mostly, cudaMemAdviseUnsetPreferredLocation and cudaMemAdviseUnsetAccessedBy."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3.3. Querying Usage Attributes - A program can query memory ran......This function queries an attri...",
    "content": "A program can query memory range attributes assigned through cudaMemAdvise or cudaMemPrefetchAsync by using the following API:\n\ncudaMemRangeGetAttribute(void *data, size_t dataSize, enum cudaMemRangeAttribute attribute, const void *devPtr, size_t count);\n\nThis function queries an attribute of the memory range starting at devPtr with a size of count bytes. The memory range must refer to managed memory allocated via cudaMallocManaged or declared via __managed__ variables. It is possible to query the following attributes:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3.3. Querying Usage Attributes - cudaMemRangeAttributeReadMostl...",
    "content": "- cudaMemRangeAttributeReadMostly: the result returned will be 1 if all pages in the given memory range have read-duplication enabled, or 0 otherwise.- cudaMemRangeAttributePreferredLocation: the result returned will be a GPU device id or cudaCpuDeviceId if all pages in the memory range have the corresponding processor as their preferred location, otherwise cudaInvalidDeviceId will be returned. An application can use this query API to make decision about staging data through CPU or GPU depending on the preferred location attribute of the managed pointer. Note that the actual location of the pages in the memory range at the time of the query may be different from the preferred location."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3.3. Querying Usage Attributes - cudaMemRangeAttributeAccessedB...",
    "content": "- cudaMemRangeAttributeAccessedBy: will return the list of devices that have that advise set for that memory range.- cudaMemRangeAttributeLastPrefetchLocation: will return the last location to which all pages in the memory range were prefetched explicitly using cudaMemPrefetchAsync. Note that"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "22.3.3. Querying Usage Attributes - this simply returns the last l......Additionally multiple attribut...",
    "content": "this simply returns the last location that the application requested to prefetch the memory range to. It gives no indication as to whether the prefetch operation to that location has completed or even begun.\n\nAdditionally, multiple attributes can be queried by using corresponding cudaMemRangeGetAttributes function."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "Chapter 23. Lazy Loading",
    "content": "\n\n# Chapter 23. Lazy Loading\n"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "23.1. What is Lazy Loading? - Lazy Loading delays loading of......Lazy Loading is enabled by set...",
    "content": "Lazy Loading delays loading of CUDA modules and kernels from program initialization closer to kernels execution. If a program does not use every single kernel it has included, then some kernels will be loaded unnecessarily. This is very common, especially if you include any libraries. Most of the time, programs only use a small amount of kernels from libraries they include.\n\nThanks to Lazy Loading, programs are able to only load kernels they are actually going to use, saving time on initialization. This reduces memory overhead, both on GPU memory and host memory\n\nLazy Loading is enabled by setting the CUDA_MODULE_LOADING environment variable to LAZY."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "23.1. What is Lazy Loading? - Firstly CUDA Runtime will no l...",
    "content": "Firstly, CUDA Runtime will no longer load all modules during program initialization, with the exception of modules containing managed variables. Each module will be loaded on first usage of a variable or a kernel from that module. This optimization is only relevant to CUDA Runtime users; CUDA Driver users are unaffected. This optimization shipped in CUDA 11.8."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "23.1. What is Lazy Loading? - Secondly loading a module cuMo......Both of these optimizations ar...",
    "content": "Secondly, loading a module (cuModuleLoad\\*) ( ) family of functions) will not be loading kernels immediately, instead it will delay loading of a kernel until cuModuleGetFunction() is called. There are certain exceptions here, some kernels have to be loaded during cuModuleLoad\\*(), such as kernels of which pointers are stored in global variables. This optimization is relevant to both CUDA Runtime and CUDA Driver users. CUDA Runtime will only call cuModu1eGetFunction() when a kernel is used/referenced for the first time. This optimization shipped in CUDA 11.7.\n\nBoth of these optimizations are designed to be invisible to the user, assuming CUDA Programming Model is followed."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "23.2.1. Driver - Lazy Loading is a CUDA Runtime......Without  mathsfR515  user mode...",
    "content": "Lazy Loading is a CUDA Runtime and CUDA Driver feature. Upgrades to both might be necessary to utilize the feature.\n\n# 23.2.1. Driver\nLazy Loading requires  $\\mathsf{R}515+$  user- mode library, but it supports Forward Compatibility, meaning it can run on top of older kernel mode drivers.\n\nWithout  $\\mathsf{R}515+$  user- mode library, Lazy Loading is not available in any shape or form, even if toolkit version is  $11.7+$"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "23.2.2. Toolkit - Lazy Loading was introduced in......If only some of your libraries...",
    "content": "# 23.2.2. Toolkit\nLazy Loading was introduced in CUDA 11.7, and received a significant upgrade in CUDA 11.8.\n\nIf your application uses CUDA Runtime, then in order to see benefits from Lazy Loading your application must use  $11.7+$  CUDA Runtime.\n\nAs CUDA Runtime is usually linked statically into programs and libraries, this means that you have to recompile your program with CUDA  $11.7+$  toolkit and use CUDA  $11.7+$  libraries.\n\nOtherwise you will not see the benefits of Lazy Loading, even if your driver version supports it.\n\nIf only some of your libraries are  $11.7+$  you will only see benefits of Lazy Loading in those libraries. Other libraries will still load everything eagerly."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "23.3. Triggering loading of kernels in lazy mode - Lazy Loading does not require ......However if for any reason you ...",
    "content": "# 23.2.3. Compiler\nLazy Loading does not require any compiler support. Both SASS and PTX compiled with pre- 11.7 compilers can be loaded with Lazy Loading enabled, and will see full benefits of the feature. However,  $11.7+$  CUDA Runtime is still required, as described above.\n\n# 23.3. Triggering loading of kernels in lazy mode\nLoading kernels and variables happens automatically, without any need for explicit loading. Simply launching a kernel or referencing a variable or a kernel will automatically load relevant modules and kernels.\n\nHowever, if for any reason you wish to load a kernel without executing it or modifying it in any way, we recommend the following."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "23.3.2. CUDA Runtime API - Loading of kernels happens dur......This will ensure that the kern...",
    "content": "Loading of kernels happens during cuModuleGetFunction() call. This call is necessary even without Lazy Loading, as it is the only way to obtain a kernel handle.\n\nHowever, you can also use this API to control with finer granularity when kernels are loaded.\n\n# 23.3.2. CUDA Runtime API\nCUDA Runtime API manages module management automatically, so we recommend simply using cudaFuncGetAttributes() to reference the kernel.\n\nThis will ensure that the kernel is loaded without changing the state."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "23.4. Querying whether Lazy Loading is turned on - In order to check whether user......cinclude cudahinclude asserthi...",
    "content": "# 23.4. Querying whether Lazy Loading is turned on\nIn order to check whether user enabled Lazy Loading, CUresult cuModuleGetLoadingMode ( CU- moduleLoadingMode\\* mode ) can be used.\n\nIt's important to note that CUDA must be initialized before running this function. Sample usage can be seen in the snippet below.\n\n```c#include \"cuda.h\"#include \"assert.h\"#include \"iostream\"int main() {    CUModuleLoadingMode mode;    assert(CUDA_SUCCESS == cuInit(0));    assert(CUDA_SUCCESS == cuModuleGetLoadingMode(&mode));    std::cout << \"CUDA Module Loading Mode is \" << ((mode == CU_MODULE_LAZYLOADING) ? \"Lazy\" : \"eager\") << std::endl;    return 0;}```"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "23.5. Possible issues when adopting lazy loading - Lazy Loading is designed so th...",
    "content": "Lazy Loading is designed so that it should not require any modifications to applications to use it. That said, there are some caveats, especially when applications are not fully compliant with CUDA Programming Model."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "23.5.1. Concurrent execution - Loading kernels might require ......If kernel A will be spinning i...",
    "content": "Loading kernels might require context synchronization. Some programs incorrectly treat the possibility of concurrent execution of kernels as a guarantee. In such cases, if program assumes that two kernels will be able to execute concurrently, and one of the kernels will not return without the other kernel executing, there is a possibility of a deadlock.\n\nIf kernel A will be spinning in an infinite loop until kernel B is executing. In such case launching kernel B will trigger lazy loading of kernel B. If this loading will require context synchronization, then we have a deadlock: kernel A is waiting for kernel B, but loading kernel B is stuck waiting for kernel A to finish to synchronize the context."
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "23.5.1. Concurrent execution - Such program is an anti patter......preload all kernels that you h...",
    "content": "Such program is an anti- pattern, but if for any reason you want to keep it you can do the following:\n\n- preload all kernels that you hope to execute concurrently prior to launching them"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "23.5.2. Allocators - Lazy Loading delays loading co......Possible solutions",
    "content": "Lazy Loading delays loading code from initialization phase of the program closer to execution phase. Loading code onto the GPU requires memory allocation.\n\nIf your application tries to allocate the entire VRAM on startup, e.g. to use it for its own allocator, then it might turn out that there will be no more memory left to load the kernels. This is despite the fact that overall Lazy Loading frees up more memory for the user. CUDA will need to allocate some memory to load each kernel, which usually happens at first launch time of each kernel. If your application allocator greedily allocated everything, CUDA will fail to allocate memory.\n\nPossible solutions:"
  },
  {
    "filename": "CUDA_C_Programming_Guide_v12.1_(Feb_28_2023)-19-498_MinerU__20250831054819.md",
    "paraname": "文档 - Some applications launch sever......do at least one warmup interac...",
    "content": "- use cudaMallocAsync() instead of an allocator that allocates the entire VRAM on startup- add some buffer to compensate for the delayed loading of kernels- preload all kernels that will be used in the program before trying to initialize your allocator\n\n# 23.5.3. Autotuning\nSome applications launch several kernels implementing the same functionality to determine which one is the fastest. While it is overall advisable to run at least one warmup iteration, it becomes especially important with Lazy Loading. After all, including time taken to load the kernel will skew your results.\n\nPossible solutions:\n\n- do at least one warmup interaction prior to measurement- preload the benchmarked kernel prior to launching it"
  }
]